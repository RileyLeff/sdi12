---
DIRECTORY STRUCTURE
---
- .gitignore
- Cargo.lock
- Cargo.toml
- README.md
- sdi12.txt
- src/
  - common/
    - address.rs
    - command.rs
    - crc.rs
    - error.rs
    - frame.rs
    - hal_traits.rs
    - mod.rs
    - response.rs
    - timing.rs
    - types.rs
  - lib.rs
  - recorder/
    - mod.rs
    - sync_recorder/
      - io_helpers.rs
      - mod.rs
      - protocol_helpers.rs
      - transaction.rs
  - sensor/
    - async_sensor/
      - mod.rs
    - formatter.rs
    - handler.rs
    - mod.rs
    - parser.rs
    - response.rs
    - sync_sensor/
      - mod.rs
- updatedreadme.md

---
FILE CONTENTS
---

--- FILE: src/sensor/handler.rs ---


--- FILE: src/common/response.rs ---
// src/common/response.rs

use crate::common::address::Sdi12Addr;
use crate::common::types::Sdi12ParsingError; // Keep for error composition
use core::fmt;

/// Error type specific to parsing the framing/address/CRC of an SDI-12 response.
/// Does not cover errors from parsing the actual payload content (data values, ID fields etc.).
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ResponseParseError {
    /// Input buffer was empty.
    EmptyInput,
    /// Input buffer doesn't end with <CR><LF> (for ASCII responses).
    MissingCrLf,
    /// Response string is too short for basic structure (e.g., address or CRC).
    TooShort,
    /// Invalid or unexpected address character at the start (e.g., '?').
    InvalidAddressChar,
    /// CRC validation failed.
    CrcMismatch,
    /// Binary packet size/structure inconsistent (if library handles binary framing).
    InconsistentBinaryPacketSize,
    /// Feature needed for a specific check/parse is not enabled.
    FeatureNotEnabled,
    /// Generic framing or structural format error.
    InvalidFormat,
    // NOTE: Errors like ValueError, NumericError, InvalidIdentificationLength etc.
    // are removed as they relate to parsing the *payload*, which is now the user's responsibility
    // or handled by optional helpers. ResponseParseError focuses on the layer the library handles.
}

impl fmt::Display for ResponseParseError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         // Simple display for now
         write!(f, "{:?}", self)
     }
}

// If std feature is enabled, implement the Error trait
#[cfg(feature = "std")]
impl std::error::Error for ResponseParseError {}


/// Timing and count information returned directly by Measurement/Concurrent/Identify commands.
/// (Example: `aTTTN<CR><LF>`)
/// This is one structure the library *might* still parse directly, as it's not payload data.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct MeasurementTiming {
    /// The address of the responding sensor.
    pub address: Sdi12Addr,
    /// Time estimate in seconds until data is ready (ttt). 0-999.
    pub time_seconds: u16,
    /// Number of measurement values that will be returned (n, nn, or nnn). 0-999.
    pub values_count: u16,
}


// --- Placeholder for the Payload Slice Wrapper ---
// This struct would be returned by recorder methods after validating
// address, CRC, CRLF and stripping them.

/// Represents the validated payload of an SDI-12 response, borrowed from a read buffer.
/// Excludes the leading address, trailing CRC (if any), and trailing <CR><LF>.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct PayloadSlice<'a>(pub &'a [u8]);

impl<'a> PayloadSlice<'a> {
    /// Returns the payload as a byte slice.
    pub fn as_bytes(&self) -> &'a [u8] {
        self.0
    }

    /// Attempts to interpret the payload as a UTF-8 string slice.
    pub fn as_str(&self) -> Result<&'a str, core::str::Utf8Error> {
        core::str::from_utf8(self.0)
    }

    // Optional: Add helper methods here later under features?
    // #[cfg(feature = "alloc")]
    // pub fn parse_data_values(&self) -> Result<Vec<Sdi12Value>, ResponseParseError> { ... }
}

impl<'a> AsRef<[u8]> for PayloadSlice<'a> {
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

// No parsing functions like parse_response defined here anymore.
// That logic moves into internal recorder helpers or optional user-facing helpers.

// --- Tests ---
#[cfg(test)]
mod tests {
    use super::*;

     fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    #[test]
    fn test_measurement_timing_struct() {
        let mt = MeasurementTiming {
            address: addr('1'),
            time_seconds: 15,
            values_count: 4,
        };
        assert_eq!(mt.time_seconds, 15);
    }

     #[test]
    fn test_payload_slice_wrapper() {
        let data: &[u8] = b"+1.23-45";
        let payload = PayloadSlice(data);
        assert_eq!(payload.as_bytes(), b"+1.23-45");
        assert_eq!(payload.as_ref(), b"+1.23-45");
        assert_eq!(payload.as_str().unwrap(), "+1.23-45");

        let non_utf8: &[u8] = &[0x80, 0x81]; // Invalid UTF-8
        let payload_bad = PayloadSlice(non_utf8);
        assert!(payload_bad.as_str().is_err());
    }
}

--- FILE: src/common/hal_traits.rs ---
// src/common/hal_traits.rs
use core::time::Duration; // Add Duration
use core::fmt::Debug; // Already there

// Define an opaque Instant marker trait within our library
// This avoids depending directly on embedded_hal::timer::Instant in the core trait
pub trait Sdi12Instant: Sized + Copy + Debug + Ord + core::ops::Add<Duration, Output = Self> + core::ops::Sub<Self, Output = Duration> {}

// Blanket implementation for any type that satisfies the bounds
impl<T> Sdi12Instant for T where T: Sized + Copy + Debug + Ord + core::ops::Add<Duration, Output = Self> + core::ops::Sub<Self, Output = Duration> {}


/// Abstraction for timer/delay operations required by SDI-12.
pub trait Sdi12Timer {
    /// Associated type for representing a moment in time.
    /// Must implement necessary traits for comparison and duration arithmetic.
    type Instant: Sdi12Instant; // Use our marker trait

    /// Delay for at least the specified number of microseconds.
    fn delay_us(&mut self, us: u32);

    /// Delay for at least the specified number of milliseconds.
    fn delay_ms(&mut self, ms: u32);

    /// Returns the current time as an `Instant`.
    fn now(&self) -> Self::Instant;
}

// ... (rest of hal_traits.rs remains the same)
use super::frame::FrameFormat;

// We need these traits potentially for the NativeSdi12Uart bounds
#[cfg(feature = "impl-native")]
use embedded_hal; // Use version 1.0
#[cfg(all(feature = "async", feature = "impl-native"))]
use embedded_hal_async; // Use version 1.0


/// Abstraction for synchronous (non-blocking) SDI-12 serial communication.
pub trait Sdi12Serial {
    /// Associated error type for communication errors.
    /// Must implement Debug for error reporting.
    type Error: Debug;

    /// Attempts to read a single byte from the serial interface.
    ///
    /// Returns `Ok(byte)` if a byte was read, or `Err(nb::Error::WouldBlock)`
    /// if no byte is available yet. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn read_byte(&mut self) -> nb::Result<u8, Self::Error>;

    /// Attempts to write a single byte to the serial interface.
    ///
    /// Returns `Ok(())` if the byte was accepted for transmission, or `Err(nb::Error::WouldBlock)`
    /// if the write buffer is full. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn write_byte(&mut self, byte: u8) -> nb::Result<(), Self::Error>;

    /// Attempts to flush the transmit buffer, ensuring all written bytes have been sent.
    ///
    /// Returns `Ok(())` if the flush completed, or `Err(nb::Error::WouldBlock)` if
    /// transmission is still in progress. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn flush(&mut self) -> nb::Result<(), Self::Error>;

    /// Sends the SDI-12 break condition (>= 12ms of spacing).
    ///
    /// Implementations must ensure the line is held low for the required duration.
    /// This might block or return `WouldBlock` depending on the implementation strategy.
    fn send_break(&mut self) -> nb::Result<(), Self::Error>;

    /// Changes the serial configuration (e.g., between 7E1 and 8N1).
    ///
    /// This operation might be blocking or complex, hence `Result` instead of `nb::Result`.
    /// Errors could occur if the hardware doesn't support the format or reconfiguration fails.
    fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

/// Abstraction for asynchronous SDI-12 serial communication (requires 'async' feature).
#[cfg(feature = "async")]
pub trait Sdi12SerialAsync {
    /// Associated error type for communication errors.
    /// Must implement Debug for error reporting.
    type Error: Debug;

    /// Asynchronously reads a single byte from the serial interface.
    async fn read_byte(&mut self) -> Result<u8, Self::Error>;

    /// Asynchronously writes a single byte to the serial interface.
    async fn write_byte(&mut self, byte: u8) -> Result<(), Self::Error>;

    /// Asynchronously flushes the transmit buffer.
    async fn flush(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously sends the SDI-12 break condition.
    async fn send_break(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously changes the serial configuration.
    async fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}


/// Bundles standard embedded-hal serial traits with native SDI-12 specific operations.
///
/// Implement this trait for a HAL's UART peripheral if it provides native support
/// for sending break signals and changing configuration efficiently. Then, use the
/// `NativeAdapter` to make it compatible with `sdi12-rs`.
///
/// Requires `embedded-hal` v1.0 traits and is enabled by the `impl-native` feature.
#[cfg(feature = "impl-native")]
pub trait NativeSdi12Uart:
    embedded_hal::serial::ErrorType // Use fully qualified path
    // Specify Error association for dependent traits using qualified syntax
    + embedded_hal::serial::Read<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    + embedded_hal::serial::Write<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    + embedded_hal::serial::Flush<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    // Add Debug bound on the associated Error type for our own trait requirements
    + where <Self as embedded_hal::serial::ErrorType>::Error: Debug
{
    // Note: The associated Error type comes from embedded_hal::serial::ErrorType

    /// Sends the SDI-12 break condition using native hardware capabilities.
    fn native_send_break(&mut self) -> Result<(), Self::Error>;

    /// Changes the serial configuration using native hardware capabilities.
    fn native_set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

/// Async version of `NativeSdi12Uart`.
/// Requires `embedded-hal-async` traits and is enabled by the `async` and `impl-native` features.
#[cfg(all(feature = "async", feature = "impl-native"))]
pub trait NativeSdi12UartAsync:
    embedded_hal_async::serial::ErrorType // Use fully qualified path
    // Specify Error association for dependent traits using qualified syntax
    + embedded_hal_async::serial::Read<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    + embedded_hal_async::serial::Write<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    + embedded_hal_async::serial::Flush<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    // Add Debug bound on the associated Error type for our own trait requirements
    + where <Self as embedded_hal_async::serial::ErrorType>::Error: Debug
{
    // Note: The associated Error type comes from embedded_hal_async::serial::ErrorType

    /// Asynchronously sends the SDI-12 break condition using native hardware capabilities.
    async fn native_send_break(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously changes the serial configuration using native hardware capabilities.
    async fn native_set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

--- FILE: src/recorder/mod.rs ---
// src/recorder/mod.rs

// Declare the new sub-module
pub mod sync_recorder;

// Re-export the public SyncRecorder struct
pub use sync_recorder::SyncRecorder;

// Keep async placeholders if needed
#[cfg(feature = "async")]
use crate::common::{address::Sdi12Addr, error::Sdi12Error, hal_traits::Sdi12Timer};
#[cfg(feature = "async")]
use core::fmt::Debug;

#[cfg(feature = "async")]
pub struct AsyncRecorder<IF> {
    interface: IF,
    // ... state ...
     last_activity_time: Option<<IF as Sdi12Timer>::Instant>, // Use associated type
}

#[cfg(feature = "async")]
impl<IF> AsyncRecorder<IF>
where
    IF: crate::common::hal_traits::Sdi12SerialAsync + Sdi12Timer,
    IF::Error: Debug,
    // Add Sdi12Instant bound here too if needed for async state tracking
    <IF as Sdi12Timer>::Instant: crate::common::hal_traits::Sdi12Instant,
{
     pub fn new(interface: IF) -> Self {
         AsyncRecorder {
            interface,
            last_activity_time: None,
         }
     }

     pub async fn acknowledge(&mut self, _address: Sdi12Addr) -> Result<(), Sdi12Error<IF::Error>> {
         unimplemented!("Async acknowledge not implemented")
     }
     // ... other async methods and helpers ...
}

// No tests needed here anymore, they moved to sync_recorder/mod.rs

--- FILE: Cargo.lock ---
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "crc"
version = "3.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69e6e4d7b33a94f0991c26729976b10ebde1d34c3ee82408fb536164fa10d636"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "embedded-hal"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "361a90feb7004eca4019fb28352a9465666b24f840f5c3cddf0ff13920590b89"

[[package]]
name = "embedded-hal-async"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4c685bbef7fe13c3c6dd4da26841ed3980ef33e841cddfa15ce8a8fb3f1884"
dependencies = [
 "embedded-hal",
]

[[package]]
name = "hash32"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47d60b12902ba28e2730cd37e95b8c9223af2808df9e902d4df49588d1470606"
dependencies = [
 "byteorder",
]

[[package]]
name = "heapless"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bfb9eb618601c89945a70e254898da93b13be0388091d42117462b265bb3fad"
dependencies = [
 "hash32",
 "stable_deref_trait",
]

[[package]]
name = "nb"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d5439c4ad607c3c23abf66de8c8bf57ba8adcd1f129e699851a6e43935d339d"

[[package]]
name = "proc-macro2"
version = "1.0.94"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "sdi12"
version = "0.1.0"
dependencies = [
 "arrayvec",
 "crc",
 "embedded-hal",
 "embedded-hal-async",
 "heapless",
 "nb",
 "thiserror",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "syn"
version = "2.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

--- FILE: Cargo.toml ---
[package]
name = "sdi12"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "A Rust library for the SDI-12 communication protocol"
repository = "https://github.com/rileyleff/sdi12-rs"
readme = "README.md"
keywords = ["sdi12", "embedded", "no-std", "sensors", "datalogger"]
categories = ["embedded", "hardware-support", "no-std"]

[dependencies]
crc = { version = "3.2.1", default-features = false }
nb = "1.1.0"

# arrayvec is needed for command formatting, make it non-optional
arrayvec = { version = "0.7.6", default-features = false } # Use 0.7.x, ensure no_std

# Heapless is optional for main library, maybe used for alloc alternatives
heapless = { version = "0.8", optional = true } # Make optional

# For embedded-hal support later
embedded-hal = { version = "1.0.0", optional = true }
embedded-hal-async = { version = "1.0.0", optional = true }
thiserror = { version = "2.0.12", default-features = false }


[dev-dependencies]
# Heapless is needed for tests that check formatting errors
heapless = { version = "0.8" }


[features]
default = [] # no_std by default

# Core features
# Decide if 'alloc' enables 'heapless' use cases within the library, or if they are separate.
# Option 1: alloc enables alloc crate directly
alloc = []
# Option 2: Feature to specifically enable heapless-based alternatives
use_heapless = ["dep:heapless"]
# Option 3: alloc feature also enables heapless (simpler if heapless is the primary no_std collection)
# alloc = ["dep:heapless"]

std = ["alloc", "thiserror/std"] # std usually implies alloc
async = ["dep:embedded-hal-async"] # async requires embedded-hal-async

# Implementation Strategy Features (choose one or more when using the library)
impl-native = ["dep:embedded-hal"] # Native impl requires embedded-hal traits
impl-generic-hal = ["dep:embedded-hal"] # Generic HAL impl also uses embedded-hal
impl-bitbang = ["dep:embedded-hal"] # Bitbang likely needs digital/delay traits from embedded-hal

# Optional: HAL-Specific Native Adapters (Examples)
# impl-adapter-stm32 = ["impl-native", "stm32f4xx-hal"] # Example, needs actual hal dep added too
# impl-adapter-rp2040 = ["impl-native", "rp2040-hal"] # Example

# Note: The async versions of impl-native, impl-generic-hal, impl-bitbang
# would likely also depend on the "async" feature itself.

--- FILE: src/lib.rs ---
// src/lib.rs

#![no_std] // Specify no_std at the crate root

#[cfg(feature = "alloc")]
extern crate alloc;

pub mod common;
pub mod recorder;
pub mod sensor;

// Re-export key types for convenience
pub use common::Sdi12Addr;
pub use common::Sdi12Error;

--- FILE: src/common/error.rs ---
// src/common/error.rs

#[cfg(feature = "alloc")]
use alloc::string::String;

// Import the specific command error types
use crate::common::command::{CommandFormatError, CommandIndexError};

// No more cfg_attr needed here, thiserror is always available
#[derive(Debug, PartialEq, Eq, thiserror::Error)]
pub enum Sdi12Error<E = ()>
where
    E: core::fmt::Debug, // Still need Debug for the generic Io error
{
    /// Underlying I/O error from the HAL implementation.
    #[error("I/O error: {0:?}")] // Format string requires Debug on E
    Io(E),

    /// Operation timed out.
    #[error("Operation timed out")]
    Timeout,

    /// Invalid character received where it's not allowed (e.g., non-printable ASCII).
    #[error("Invalid character received: {0:#04x}")]
    InvalidCharacter(u8),

    /// Provided address character is not a valid SDI-12 address.
    #[error("Invalid SDI-12 address character: '{0}'")]
    InvalidAddress(char),

    /// Received response format is invalid or unexpected.
    #[error("Invalid response format")]
    InvalidFormat,

    /// Buffer provided was too small.
    #[error("Buffer overflow: needed {needed}, got {got}")]
    BufferOverflow { needed: usize, got: usize },

    /// UART framing error detected by HAL.
    #[error("UART framing error")]
    Framing,

    /// UART parity error detected by HAL.
    #[error("UART parity error")]
    Parity,

    /// Received CRC does not match calculated CRC.
    #[error("CRC mismatch: expected {expected:#06x}, calculated {calculated:#06x}")]
    CrcMismatch { expected: u16, calculated: u16 },

    /// Got a validly formatted response, but not the one expected in the current state.
    #[error("Unexpected response received")]
    UnexpectedResponse, // Consider adding details later

    /// Bus contention detected (multiple devices responding simultaneously).
    #[error("Bus contention detected")]
    BusContention,

    /// Error related to command index validation.
    #[error("Invalid command index: {0}")] // Uses Display impl of CommandIndexError
    InvalidCommandIndex(CommandIndexError), // Wrap CommandIndexError

    /// Error during command formatting.
    #[error("Command formatting failed: {0}")] // Uses Display impl of CommandFormatError
    CommandFormatFailed(CommandFormatError), // Wrap CommandFormatError

    /// An error specific to the sensor's implementation/handler.
    /// Only available when the "alloc" feature is enabled.
    #[cfg(feature = "alloc")]
    #[error("Sensor specific error: {0}")] // String implements Display
    SensorSpecific(String),

    // Add other variants as needed...
}

// Allow mapping from underlying HAL error if From is implemented
impl<E: core::fmt::Debug> From<E> for Sdi12Error<E> {
    fn from(e: E) -> Self {
        Sdi12Error::Io(e)
    }
}

// Map command index errors into the main error type (with default E=())
// This resolves the E0119 conflict.
impl From<CommandIndexError> for Sdi12Error<()> {
    fn from(e: CommandIndexError) -> Self {
        Sdi12Error::InvalidCommandIndex(e)
    }
}

// Map command format errors into the main error type (with default E=())
// This resolves the E0119 conflict.
impl From<CommandFormatError> for Sdi12Error<()> {
    fn from(e: CommandFormatError) -> Self {
        Sdi12Error::CommandFormatFailed(e)
    }
}

--- FILE: src/sensor/response.rs ---


--- FILE: src/sensor/async_sensor/mod.rs ---


--- FILE: src/sensor/formatter.rs ---


--- FILE: src/sensor/mod.rs ---
// src/sensor/mod.rs

// Declare the modules within the sensor directory.
// These modules contain the different logical parts of the sensor implementation.

// Shared logic (used by both sync and async sensor runners)
pub mod handler;      // Defines the SensorHandler trait (user implements this)
mod response;     // Defines the internal SensorResponse enum and related structs
mod formatter;    // Logic to format SensorResponse -> byte stream
mod parser;       // Logic to parse byte stream -> Command

// Specific runner implementations
pub mod sync_sensor; // Synchronous sensor runner

// Asynchronous sensor runner (feature-gated)
#[cfg(feature = "async")]
pub mod async_sensor;

// --- Public Re-exports ---
// Re-export the essential types that users of the library will interact with
// when implementing a sensor.

// The core trait the user needs to implement.
// pub use handler::SensorHandler;

// The synchronous runner struct the user will instantiate and run.
// pub use sync_sensor::SyncSensor;

// Conditionally re-export the asynchronous runner struct.
#[cfg(feature = "async")]
pub use async_sensor::AsyncSensor;

// Potential re-exports for response types if they are directly used
// in the SensorHandler trait signatures (might need adjustment later).
// pub use response::{ SensorResponse, IdentificationInfo, /* ... */ };

--- FILE: .gitignore ---
/target

--- FILE: src/recorder/sync_recorder/io_helpers.rs ---
// src/recorder/sync_recorder/io_helpers.rs

use super::SyncRecorder; // Access SyncRecorder definition
use crate::common::{
    error::Sdi12Error,
    hal_traits::{Sdi12Instant, Sdi12Serial, Sdi12Timer},
    timing, FrameFormat,
};
use core::fmt::Debug;
use core::ops::Sub;
use core::time::Duration;
use nb::Result as NbResult;

// Implementation block for I/O related helpers
impl<IF> SyncRecorder<IF>
where
    IF: Sdi12Serial + Sdi12Timer,
    IF::Error: Debug,
    IF::Instant: Sdi12Instant,
{
    /// Executes a non-blocking I/O operation (`f`) repeatedly until it
    /// stops returning `WouldBlock`, returning the final result or a timeout error.
    pub(super) fn execute_blocking_io_with_timeout<FN, T>( // Make pub(super)
        &mut self,
        timeout: Duration,
        mut f: FN,
    ) -> Result<T, Sdi12Error<IF::Error>>
    where
        FN: FnMut(&mut IF) -> NbResult<T, IF::Error>,
    {
        let start_time = self.interface.now();
        let deadline = start_time + timeout;

        loop {
            match f(&mut self.interface) {
                Ok(result) => return Ok(result),
                Err(nb::Error::WouldBlock) => {
                    if self.interface.now() >= deadline {
                        return Err(Sdi12Error::Timeout);
                    }
                    // Optional delay - small delay might prevent busy-spinning 100% CPU
                    self.interface.delay_us(100); // e.g., 100us delay
                }
                Err(nb::Error::Other(e)) => return Err(Sdi12Error::Io(e)),
            }
        }
    }

     /// Checks timing state and sends a break if necessary.
     pub(super) fn check_and_send_break(&mut self) -> Result<(), Sdi12Error<IF::Error>> { // Make pub(super)
        let now = self.interface.now();
        let mut break_needed = true;

        if let Some(last_time) = self.last_activity_time {
            let elapsed = now.sub(last_time);
            if elapsed <= timing::PRE_COMMAND_BREAK_MARKING_THRESHOLD {
                break_needed = false;
            }
        }

        if break_needed {
            let break_timeout = timing::BREAK_DURATION_MIN + Duration::from_millis(5);
            self.execute_blocking_io_with_timeout(break_timeout, |iface| iface.send_break())?;
            self.interface.delay_us(timing::POST_BREAK_MARKING_MIN.as_micros() as u32);
            // Update time *after* break sequence completes successfully
            self.last_activity_time = Some(self.interface.now());
        }

        Ok(())
    }

    /// Sends the already formatted command bytes over the serial interface.
    pub(super) fn send_command_bytes(&mut self, cmd_bytes: &[u8]) -> Result<(), Sdi12Error<IF::Error>> { // Make pub(super)
        self.interface
            .set_config(FrameFormat::Sdi12_7e1)
            .map_err(Sdi12Error::Io)?;

        let write_duration = timing::BYTE_DURATION * cmd_bytes.len() as u32;
        let write_timeout = write_duration + Duration::from_millis(20); // 20ms buffer

        for byte in cmd_bytes {
            self.execute_blocking_io_with_timeout(write_timeout, |iface| {
                iface.write_byte(*byte)
            })?;
        }

        let flush_timeout = Duration::from_millis(10);
        self.execute_blocking_io_with_timeout(flush_timeout, |iface| iface.flush())?;

        // NOTE: Do not update last_activity_time here. Update only after successful response.
        Ok(())
    }

     /// Reads a complete response line (up to <CR><LF>) into the buffer.
     pub(super) fn read_response_line<'buf>( // Make pub(super)
        &mut self,
        buffer: &'buf mut [u8],
    ) -> Result<&'buf [u8], Sdi12Error<IF::Error>> {
        // Calculate timeout: Response start time + time for max standard response length
        let max_resp_len = 96; // Generous buffer
        let read_allowance = timing::BYTE_DURATION * max_resp_len;
        let read_timeout = timing::RESPONSE_START_TIME_MAX + read_allowance + Duration::from_millis(50);

        let mut bytes_read = 0;
        loop {
            if bytes_read >= buffer.len() {
                return Err(Sdi12Error::BufferOverflow {
                    needed: bytes_read + 1,
                    got: buffer.len(),
                });
            }

            // Define a shorter timeout for subsequent bytes once the first byte arrived
            let current_timeout = if bytes_read == 0 {
                read_timeout
            } else {
                 // Timeout based on inter-character spacing + buffer
                timing::INTER_CHARACTER_MARKING_MAX + Duration::from_millis(5)
            };

            match self.execute_blocking_io_with_timeout(current_timeout, |iface| iface.read_byte()) {
                Ok(byte) => {
                    buffer[bytes_read] = byte;
                    bytes_read += 1;

                    // Check for <CR><LF>
                    if bytes_read >= 2
                        && buffer[bytes_read - 2] == b'\r'
                        && buffer[bytes_read - 1] == b'\n'
                    {
                        return Ok(&buffer[..bytes_read]);
                    }
                }
                Err(Sdi12Error::Timeout) => {
                    if bytes_read > 0 {
                        // Received some bytes but didn't get CRLF in time
                        return Err(Sdi12Error::InvalidFormat);
                    } else {
                        // Timed out waiting for the first byte
                        return Err(Sdi12Error::Timeout);
                    }
                }
                Err(e) => return Err(e),
            }
        }
    }
}
// src/recorder/sync_recorder/io_helpers.rs
// ... (main code) ...

// --- Unit Tests for IO Helpers ---
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::{
        address::Sdi12Addr, // Keep needed imports for tests
        command::Command,
        hal_traits::{Sdi12Serial, Sdi12Timer}, // Remove Sdi12Instant from here
        FrameFormat, Sdi12Error,
    };
    use core::time::Duration;
    use nb::Result as NbResult; // FIX: Added import for tests
    use nb; // Keep nb for errors like nb::Error::WouldBlock

    // --- Mock Instant ---
    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
    struct MockInstant(u64);
    impl core::ops::Add<Duration> for MockInstant { /* ... */
        type Output = Self;
        fn add(self, rhs: Duration) -> Self {
            MockInstant(self.0.saturating_add(rhs.as_micros() as u64))
        }
     }
    impl core::ops::Sub<MockInstant> for MockInstant { /* ... */
        type Output = Duration;
        fn sub(self, rhs: MockInstant) -> Duration {
            Duration::from_micros(self.0.saturating_sub(rhs.0))
        }
    }
    // --- Mock Comm Error ---
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct MockCommError;
    // --- Mock Interface ---
    #[derive(Clone)]
    struct MockInterface { /* ... */
        break_sent: bool,
        pub config: FrameFormat,
        current_time_us: u64,
        read_queue: [Option<u8>; 96],
        read_pos: usize,
        write_log: [Option<u8>; 96],
        write_pos: usize,
        #[cfg(feature = "std")]
        io_call_counts: std::collections::HashMap<&'static str, u32>,
        #[cfg(not(feature = "std"))]
        _marker: core::marker::PhantomData<&'static str>,
    }
     impl MockInterface { /* ... */
        fn new() -> Self {
             MockInterface {
                break_sent: false,
                config: FrameFormat::Sdi12_7e1,
                current_time_us: 0,
                read_queue: [None; 96],
                read_pos: 0,
                write_log: [None; 96],
                write_pos: 0,
                 #[cfg(feature = "std")]
                 io_call_counts: std::collections::HashMap::new(),
                 #[cfg(not(feature = "std"))]
                 _marker: core::marker::PhantomData,
            }
        }
        fn advance_time(&mut self, us: u64) {
             self.current_time_us = self.current_time_us.saturating_add(us);
        }
         #[cfg(feature = "std")]
        fn increment_call_count(&mut self, name: &'static str) {
            *self.io_call_counts.entry(name).or_insert(0) += 1;
        }
        #[cfg(not(feature = "std"))]
        fn increment_call_count(&mut self, _name: &'static str) {}
         #[cfg(feature = "std")]
        fn get_call_count(&self, name: &'static str) -> u32 {
             *self.io_call_counts.get(name).unwrap_or(&0)
        }
         #[cfg(not(feature = "std"))]
        fn get_call_count(&self, _name: &'static str) -> u32 { 0 }
        fn stage_read_data(&mut self, data: &[u8]) {
             self.read_pos = 0;
             self.read_queue = [None; 96];
             assert!(data.len() <= self.read_queue.len());
             for (i, byte) in data.iter().enumerate() {
                 self.read_queue[i] = Some(*byte);
             }
        }
     }
     impl Sdi12Timer for MockInterface { /* ... Use MockInstant ... */
        type Instant = MockInstant;
        fn delay_us(&mut self, us: u32) { self.advance_time(us as u64); }
        fn delay_ms(&mut self, ms: u32) { self.advance_time((ms as u64) * 1000); }
        fn now(&self) -> Self::Instant { MockInstant(self.current_time_us) }
     }
     impl Sdi12Serial for MockInterface { /* ... Use NbResult ... */
         type Error = MockCommError;
         fn read_byte(&mut self) -> NbResult<u8, Self::Error> { /* ... */
            self.increment_call_count("read_byte");
            if self.read_pos < self.read_queue.len() {
                if let Some(byte) = self.read_queue[self.read_pos] {
                    self.read_pos += 1;
                    Ok(byte)
                } else {
                     Err(nb::Error::WouldBlock)
                }
            } else {
                 Err(nb::Error::WouldBlock)
            }
         }
         fn write_byte(&mut self, byte: u8) -> NbResult<(), Self::Error> { /* ... */
            self.increment_call_count("write_byte");
             if self.write_pos < self.write_log.len() {
                 self.write_log[self.write_pos] = Some(byte);
                 self.write_pos += 1;
                 Ok(())
             } else {
                 Err(nb::Error::Other(MockCommError))
             }
         }
         fn flush(&mut self) -> NbResult<(), Self::Error> { self.increment_call_count("flush"); Ok(()) } // Uses NbResult
         fn send_break(&mut self) -> NbResult<(), Self::Error> { self.increment_call_count("send_break"); self.break_sent = true; Ok(()) } // Uses NbResult
         fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error> { self.increment_call_count("set_config"); self.config = config; Ok(()) }
     }
     // Helper
     fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    // ... (All tests copied from previous mod.rs tests block) ...
    #[test]
    #[cfg(feature = "std")]
    fn test_execute_blocking_io_with_timeout() { /* ... as before ... */
        let mut mock_interface = MockInterface::new();
       let mut recorder = SyncRecorder::new(mock_interface);
       // Test Ok path
        let result_ok: Result<i32, _> = recorder.execute_blocking_io_with_timeout(
            Duration::from_millis(10),
            |iface| {
                let count = iface.get_call_count("timeout_ok");
                iface.increment_call_count("timeout_ok");
                iface.advance_time(1_000);
                if count < 3 { Err(nb::Error::WouldBlock) } else { Ok(123) }
            }
        );
        assert_eq!(result_ok, Ok(123));
        assert_eq!(recorder.interface.get_call_count("timeout_ok"), 4);
        assert_eq!(recorder.interface.current_time_us, 4_000);

        // Reset
        recorder.interface.current_time_us = 0;
        recorder.interface.io_call_counts.clear();

       // Test Timeout path
        let result_timeout: Result<(), _> = recorder.execute_blocking_io_with_timeout(
            Duration::from_millis(5),
            |iface| {
                iface.increment_call_count("timeout_err");
                 iface.advance_time(2_000);
                 Err(nb::Error::WouldBlock)
            }
        );
         assert!(matches!(result_timeout, Err(Sdi12Error::Timeout)));
         assert_eq!(recorder.interface.get_call_count("timeout_err"), 3);
         assert_eq!(recorder.interface.current_time_us, 6_000);

         // Reset
         recorder.interface.current_time_us = 0;
         recorder.interface.io_call_counts.clear();

        // Test IO Error path
         let result_io_err: Result<(), _> = recorder.execute_blocking_io_with_timeout(
             Duration::from_millis(10),
             |iface| {
                 let count = iface.get_call_count("timeout_io_err");
                 iface.increment_call_count("timeout_io_err");
                 iface.advance_time(1_000);
                 if count < 2 {
                     Err(nb::Error::WouldBlock)
                 } else {
                     Err(nb::Error::Other(MockCommError))
                 }
             }
         );
         assert!(matches!(result_io_err, Err(Sdi12Error::Io(MockCommError))));
         assert_eq!(recorder.interface.get_call_count("timeout_io_err"), 3);
         assert_eq!(recorder.interface.current_time_us, 3_000);
    }
    #[test]
    fn test_read_response_line_success() { /* ... as before ... */
         let mut mock_if = MockInterface::new();
        let data_to_read = b"1+12.3\r\n";
        mock_if.stage_read_data(data_to_read);
        let mut recorder = SyncRecorder::new(mock_if);
        let mut buffer = [0u8; 32];

        let result = recorder.read_response_line(&mut buffer);
        assert!(result.is_ok());
        let line_slice = result.unwrap();
        let len = line_slice.len();
        assert_eq!(line_slice, data_to_read);
        assert_eq!(len, data_to_read.len());
        assert_eq!(&buffer[..len], data_to_read);
    }
    #[test]
    fn test_read_response_line_timeout_no_data() { /* ... as before ... */
         let mock_if = MockInterface::new();
         let mut recorder = SyncRecorder::new(mock_if);
         let mut buffer = [0u8; 32];
         let result = recorder.read_response_line(&mut buffer);
         assert!(matches!(result, Err(Sdi12Error::Timeout)));
    }
    #[test]
    fn test_read_response_line_timeout_partial_data() { /* ... as before ... */
         let mut mock_if = MockInterface::new();
         mock_if.stage_read_data(b"1+12.3");
         let mut recorder = SyncRecorder::new(mock_if);
         let mut buffer = [0u8; 32];
         let result = recorder.read_response_line(&mut buffer);
         assert!(matches!(result, Err(Sdi12Error::InvalidFormat)));
    }
     #[test]
    fn test_read_response_line_buffer_overflow() { /* ... as before ... */
         let mut mock_if = MockInterface::new();
         mock_if.stage_read_data(b"1+12.345\r\n"); // 10 bytes
         let mut recorder = SyncRecorder::new(mock_if);
         let mut buffer = [0u8; 8]; // Buffer too small
         let result = recorder.read_response_line(&mut buffer);
         assert!(matches!(result, Err(Sdi12Error::BufferOverflow{needed: 9, got: 8})));
    }
    #[test]
    fn test_send_command_bytes_success() { /* ... as before ... */
        let mock_if = MockInterface::new();
        let mut recorder = SyncRecorder::new(mock_if.clone());
        let cmd_bytes = b"1M!";
        let result = recorder.send_command_bytes(cmd_bytes);

        assert!(result.is_ok());
        assert_eq!(recorder.interface.write_log[0], Some(b'1'));
        assert_eq!(recorder.interface.write_log[1], Some(b'M'));
        assert_eq!(recorder.interface.write_log[2], Some(b'!'));
        assert_eq!(recorder.interface.write_pos, 3);
        assert_eq!(recorder.interface.config, FrameFormat::Sdi12_7e1);
        #[cfg(feature="std")]
        assert_eq!(recorder.interface.get_call_count("flush"), 1);
    }
    #[test]
    fn test_check_and_send_break_needed() { /* ... as before ... */
         let mut mock_if = MockInterface::new();
        mock_if.current_time_us = 200_000;
        let mut recorder = SyncRecorder::new(mock_if);
        recorder.last_activity_time = Some(MockInstant(10_000));

        let result = recorder.check_and_send_break();
        assert!(result.is_ok());
        assert!(recorder.interface.break_sent);
        assert!(recorder.interface.current_time_us as u128 >= 200_000 + crate::common::timing::POST_BREAK_MARKING_MIN.as_micros());
        assert!(recorder.last_activity_time.is_some());
    }
     #[test]
    fn test_check_and_send_break_not_needed() { /* ... as before ... */
        let mut mock_if = MockInterface::new();
        mock_if.current_time_us = 50_000;
        let mut recorder = SyncRecorder::new(mock_if);
         recorder.last_activity_time = Some(MockInstant(10_000));

        let result = recorder.check_and_send_break();
        assert!(result.is_ok());
        assert!(!recorder.interface.break_sent);
        assert_eq!(recorder.interface.current_time_us, 50_000);
        assert_eq!(recorder.last_activity_time, Some(MockInstant(10_000)));
    }
}

--- FILE: src/recorder/sync_recorder/protocol_helpers.rs ---
// src/recorder/sync_recorder/protocol_helpers.rs

use super::SyncRecorder;
use crate::common::{
    address::Sdi12Addr,
    command::{Command, IdentifyMeasurementParameterCommand}, // Import Command and sub-enums
    error::Sdi12Error,
    hal_traits::{Sdi12Instant, Sdi12Serial, Sdi12Timer},
    response::PayloadSlice, // Only needed for test helper function now
};
use core::fmt::Debug;

impl<IF> SyncRecorder<IF>
where
    IF: Sdi12Serial + Sdi12Timer,
    IF::Error: Debug,
    IF::Instant: Sdi12Instant,
{
    /// Parses the raw response line, checking address, CRC (if needed),
    /// and returns the start/end indices of the payload within the original line buffer.
    pub(super) fn process_response_payload(
        &mut self,
        response_line: &[u8],
        original_cmd: &Command,
    ) -> Result<(usize, usize), Sdi12Error<IF::Error>> { // Return (start, end) indices

        if response_line.len() < 3 { // Must have at least address + CR + LF
            return Err(Sdi12Error::InvalidFormat);
        }

        // 1. Check and strip <CR><LF>
        let crlf_len = 2;
        let data_end_idx = response_line.len() - crlf_len;
        if response_line[data_end_idx..] != [b'\r', b'\n'] {
            return Err(Sdi12Error::InvalidFormat); // Missing or incorrect terminator
        }
        let response_without_crlf = &response_line[..data_end_idx];

        if response_without_crlf.is_empty() { // Needs at least address
             return Err(Sdi12Error::InvalidFormat);
        }

        // 2. Check address
        let received_addr_char = response_without_crlf[0] as char;
        let expected_addr = match original_cmd {
             Command::AddressQuery => None, // Special case, accept any valid address
             _ => Some(original_cmd.address()),
        };

        let received_addr = Sdi12Addr::new(received_addr_char)
            .map_err(|_| Sdi12Error::InvalidAddress(received_addr_char))?; // Map error

        if let Some(expected) = expected_addr {
             if received_addr != expected {
                return Err(Sdi12Error::UnexpectedResponse);
             }
        }

        // 3. Determine payload boundaries and process CRC if needed
        let payload_start_index = 1; // Payload starts after the address byte
        let mut payload_end_index = response_without_crlf.len(); // End is before CRLF initially

        let crc_expected = matches!(
            original_cmd,
            Command::StartMeasurementCRC { .. }
                | Command::StartConcurrentMeasurementCRC { .. }
                | Command::ReadContinuousCRC { .. }
                | Command::StartHighVolumeASCII { .. }
                | Command::StartHighVolumeBinary { .. }
                | Command::IdentifyMeasurementParameter(
                    IdentifyMeasurementParameterCommand::MeasurementCRC { .. }
                    | IdentifyMeasurementParameterCommand::ConcurrentMeasurementCRC { .. }
                    | IdentifyMeasurementParameterCommand::ReadContinuousCRC { .. }
                    | IdentifyMeasurementParameterCommand::HighVolumeASCII { .. }
                    | IdentifyMeasurementParameterCommand::HighVolumeBinary { .. }
                    )
        );

        if crc_expected {
             // TODO: Handle binary CRC case differently if needed
            let crc_len = 3; // Assuming ASCII CRC
            if response_without_crlf.len() < payload_start_index + crc_len { // Need address + CRC
                return Err(Sdi12Error::InvalidFormat);
            }
            // CRC verification uses the slice *including* address but *excluding* CRLF
            crate::common::crc::verify_response_crc_ascii(response_without_crlf)
                 .map_err(|e| match e {
                     Sdi12Error::CrcMismatch{..} => e, // Pass through CRC error
                     _ => Sdi12Error::InvalidFormat,    // Other verification errors become InvalidFormat
                 })?;
             // Adjust payload end index to be before the CRC
             payload_end_index = response_without_crlf.len() - crc_len;
        }

        // Return the calculated indices relative to the start of the original response_line buffer
        Ok((payload_start_index, payload_end_index))
    }
}

// --- Unit Tests for Protocol Helpers ---
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::{
        address::Sdi12Addr,
        command::{Command, DataIndex, MeasurementIndex},
        hal_traits::{Sdi12Serial, Sdi12Timer}, // Removed Sdi12Instant
        FrameFormat, Sdi12Error,
        response::PayloadSlice, // Keep for test helper
    };
    use core::time::Duration;
    use nb::Result as NbResult;
    use nb;

    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
    struct MockInstant(u64);
    impl core::ops::Add<Duration> for MockInstant { type Output = Self; fn add(self, rhs: Duration) -> Self { MockInstant(self.0.saturating_add(rhs.as_micros() as u64)) } }
    impl core::ops::Sub<MockInstant> for MockInstant { type Output = Duration; fn sub(self, rhs: MockInstant) -> Duration { Duration::from_micros(self.0.saturating_sub(rhs.0)) } }
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct MockCommError;
    #[derive(Clone)]
    struct MockInterface;
    impl Sdi12Timer for MockInterface { type Instant = MockInstant; fn delay_us(&mut self, _us: u32) {} fn delay_ms(&mut self, _ms: u32) {} fn now(&self) -> Self::Instant { MockInstant(0) } }
    impl Sdi12Serial for MockInterface { type Error = MockCommError; fn read_byte(&mut self) -> NbResult<u8, Self::Error> { Err(nb::Error::WouldBlock) } fn write_byte(&mut self, _byte: u8) -> NbResult<(), Self::Error> { Ok(()) } fn flush(&mut self) -> NbResult<(), Self::Error> { Ok(()) } fn send_break(&mut self) -> NbResult<(), Self::Error> { Ok(()) } fn set_config(&mut self, _config: FrameFormat) -> Result<(), Self::Error> { Ok(()) } }
    fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    // Helper to create PayloadSlice from indices and buffer for tests
    fn slice_from_indices<'a>(buffer: &'a [u8], start: usize, end: usize) -> PayloadSlice<'a> {
         PayloadSlice(&buffer[start..end])
    }

    #[test]
    fn test_process_response_payload_simple_ack() {
        let mock_if = MockInterface;
        let mut recorder = SyncRecorder::new(mock_if);
        let line = b"0\r\n";
        let cmd = Command::AcknowledgeActive{ address: addr('0') };
        let result = recorder.process_response_payload(line, &cmd);
        assert!(result.is_ok());
        let (start, end) = result.unwrap();
        assert_eq!((start, end), (1, 1)); // Indices for empty payload
        assert_eq!(slice_from_indices(line, start, end).as_bytes(), b"");
    }
     #[test]
    fn test_process_response_payload_data_no_crc() {
        let mock_if = MockInterface;
        let mut recorder = SyncRecorder::new(mock_if);
        let line = b"1+12.3-45\r\n"; // 11 bytes total
        let cmd = Command::SendData{ address: addr('1'), index: DataIndex::new(0).unwrap() };
        let result = recorder.process_response_payload(line, &cmd);
         assert!(result.is_ok());
        let (start, end) = result.unwrap();
        assert_eq!(start, 1);
        assert_eq!(end, 9); // line length 11, minus 2 for CRLF = 9
        assert_eq!(slice_from_indices(line, start, end).as_bytes(), b"+12.3-45");
    }
    #[test]
    fn test_process_response_payload_data_with_crc_ok() {
         let mock_if = MockInterface;
        let mut recorder = SyncRecorder::new(mock_if);
        let line = b"0+3.14OqZ\r\n"; // 10 bytes total
        let cmd = Command::StartMeasurementCRC{ address: addr('0'), index: MeasurementIndex::Base };
        let result = recorder.process_response_payload(line, &cmd);
        assert!(result.is_ok());
        let (start, end) = result.unwrap();
        assert_eq!(start, 1);
        assert_eq!(end, 6); // line len 10, minus 2 CRLF, minus 3 CRC = 5 -> end index is 1+5 = 6
        assert_eq!(slice_from_indices(line, start, end).as_bytes(), b"+3.14");
    }
     #[test]
    fn test_process_response_payload_data_with_crc_bad() {
        let mock_if = MockInterface;
        let mut recorder = SyncRecorder::new(mock_if);
        let line = b"0+3.14OqX\r\n"; // Bad CRC
        let cmd = Command::StartMeasurementCRC{ address: addr('0'), index: MeasurementIndex::Base };
        let result = recorder.process_response_payload(line, &cmd);
        assert!(matches!(result, Err(Sdi12Error::CrcMismatch { .. })));
    }
     #[test]
    fn test_process_response_payload_wrong_address() {
        let mock_if = MockInterface;
        let mut recorder = SyncRecorder::new(mock_if);
        let line = b"1+12.3\r\n";
        let cmd = Command::SendData{ address: addr('0'), index: DataIndex::new(0).unwrap() }; // Sent to 0
        let result = recorder.process_response_payload(line, &cmd);
        assert!(matches!(result, Err(Sdi12Error::UnexpectedResponse)));
    }
    #[test]
    fn test_process_response_payload_address_query() {
         let mock_if = MockInterface;
        let mut recorder = SyncRecorder::new(mock_if);
        let line = b"5\r\n"; // Response from sensor 5
        let cmd = Command::AddressQuery; // Query command
        let result = recorder.process_response_payload(line, &cmd);
        assert!(result.is_ok());
        let (start, end) = result.unwrap();
        assert_eq!((start, end), (1, 1)); // Empty payload
        assert_eq!(slice_from_indices(line, start, end).as_bytes(), b"");
    }
     #[test]
    fn test_process_response_payload_invalid_format() {
        let mock_if = MockInterface;
        let mut recorder = SyncRecorder::new(mock_if);
        let cmd = Command::AcknowledgeActive{ address: addr('0') };

        assert!(matches!(recorder.process_response_payload(b"0", &cmd), Err(Sdi12Error::InvalidFormat))); // Too short
        assert!(matches!(recorder.process_response_payload(b"0\r", &cmd), Err(Sdi12Error::InvalidFormat))); // Too short
        assert!(matches!(recorder.process_response_payload(b"\r\n", &cmd), Err(Sdi12Error::InvalidFormat))); // No address
        // Check valid empty payload case
        let (start, end) = recorder.process_response_payload(b"0\r\n", &cmd).unwrap();
        assert_eq!((start, end), (1, 1));
    }
}

--- FILE: src/common/types.rs ---
// src/common/types.rs

use core::fmt;
use core::str::FromStr; // For parsing strings to numbers

// --- SDI-12 Standard Data Value (`<values>`) ---

/// Represents a single data value as returned in the `<values>` part of D or R commands.
/// Format: `p[d.d]` where p is '+' or '-', d are digits, '.' is optional. Max 7 digits. Max 9 chars total.
///
/// We store it internally potentially as a scaled integer or a float, depending on needs.
/// Using f32 might be simplest for representation, but parsing needs care.
/// Alternatively, parse into integer + scale factor. Let's try f32 for now.
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]
pub struct Sdi12Value(f32); // Store as f32 for simplicity

impl Sdi12Value {
    /// Creates a new Sdi12Value.
    pub fn new(value: f32) -> Self {
        // TODO: Potentially add checks/clamping based on SDI-12 format limits?
        // The format itself limits precision/range implicitly.
        Self(value)
    }

    /// Returns the value as f32.
    pub fn as_f32(&self) -> f32 {
        self.0
    }

    /// Parses a single value string (like "+1.23", "-10", "+1234567") into an Sdi12Value.
    /// Does not handle multiple values in one string.
    pub fn parse_single(s: &str) -> Result<Self, Sdi12ParsingError> {
        // Validate basic structure and length (max 9 chars: sign + 7 digits + opt decimal)
        if s.is_empty() || s.len() > 9 {
            return Err(Sdi12ParsingError::InvalidFormat);
        }
        let mut chars = s.chars();
        let sign_char = chars.next().ok_or(Sdi12ParsingError::InvalidFormat)?;
        let sign = match sign_char {
            '+' => 1.0,
            '-' => -1.0,
            _ => return Err(Sdi12ParsingError::InvalidSign),
        };

        let rest = chars.as_str();
        // Validate remaining chars are digits or a single '.'
        let mut decimal_found = false;
        let mut digit_count = 0;
        for c in rest.chars() {
            match c {
                '0'..='9' => digit_count += 1,
                '.' => {
                    if decimal_found { return Err(Sdi12ParsingError::MultipleDecimals); }
                    decimal_found = true;
                }
                _ => return Err(Sdi12ParsingError::InvalidCharacter),
            }
        }
        if digit_count == 0 || digit_count > 7 {
            return Err(Sdi12ParsingError::InvalidDigitCount);
        }

        // Attempt to parse the numeric part (without sign)
        let num_part = f32::from_str(rest).map_err(|_| Sdi12ParsingError::ParseFloatError)?;

        Ok(Self(sign * num_part))
    }

    // TODO: Implement formatting logic later if needed (e.g., for sensor implementation)
    // pub fn format(&self, buffer: &mut [u8]) -> Result<usize, Sdi12FormattingError> { ... }
}

/// Error during parsing of SDI-12 <values>.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Sdi12ParsingError {
    InvalidFormat,
    InvalidSign,
    MultipleDecimals,
    InvalidCharacter,
    InvalidDigitCount,
    ParseFloatError, // Error converting string part to float
}

impl fmt::Display for Sdi12ParsingError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use Sdi12ParsingError::*;
        match self {
            InvalidFormat => write!(f, "Invalid SDI-12 value format"),
            InvalidSign => write!(f, "Invalid or missing sign character"),
            MultipleDecimals => write!(f, "Multiple decimal points found"),
            InvalidCharacter => write!(f, "Invalid character in numeric part"),
            InvalidDigitCount => write!(f, "Invalid number of digits (must be 1-7)"),
            ParseFloatError => write!(f, "Failed to parse numeric part as float"),
        }
    }
}


// --- High Volume Binary Data Types (Sec 5.2.1, Table 16) ---

/// Data types used in High-Volume Binary command responses.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[repr(u8)]
pub enum BinaryDataType {
    InvalidRequest = 0, // Indicates an invalid DBn request index
    SignedI8 = 1,
    UnsignedU8 = 2,
    SignedI16 = 3,
    UnsignedU16 = 4,
    SignedI32 = 5,
    UnsignedU32 = 6,
    SignedI64 = 7,
    UnsignedU64 = 8,
    Float32 = 9, // IEEE 754 Single Precision
    Float64 = 10, // IEEE 754 Double Precision
}

impl BinaryDataType {
    /// Tries to convert a u8 into a BinaryDataType.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BinaryDataType::InvalidRequest),
            1 => Some(BinaryDataType::SignedI8),
            2 => Some(BinaryDataType::UnsignedU8),
            3 => Some(BinaryDataType::SignedI16),
            4 => Some(BinaryDataType::UnsignedU16),
            5 => Some(BinaryDataType::SignedI32),
            6 => Some(BinaryDataType::UnsignedU32),
            7 => Some(BinaryDataType::SignedI64),
            8 => Some(BinaryDataType::UnsignedU64),
            9 => Some(BinaryDataType::Float32),
            10 => Some(BinaryDataType::Float64),
            _ => None,
        }
    }

    /// Returns the size in bytes of a single value of this data type.
    /// Returns 0 for InvalidRequest.
    pub fn size_in_bytes(&self) -> usize {
        match self {
            BinaryDataType::InvalidRequest => 0,
            BinaryDataType::SignedI8 => 1,
            BinaryDataType::UnsignedU8 => 1,
            BinaryDataType::SignedI16 => 2,
            BinaryDataType::UnsignedU16 => 2,
            BinaryDataType::SignedI32 => 4,
            BinaryDataType::UnsignedU32 => 4,
            BinaryDataType::SignedI64 => 8,
            BinaryDataType::UnsignedU64 => 8,
            BinaryDataType::Float32 => 4,
            BinaryDataType::Float64 => 8,
        }
    }
}


// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sdi12value_parsing_valid() {
        assert_eq!(Sdi12Value::parse_single("+1.23").unwrap(), Sdi12Value(1.23));
        assert_eq!(Sdi12Value::parse_single("-0.456").unwrap(), Sdi12Value(-0.456));
        assert_eq!(Sdi12Value::parse_single("+100").unwrap(), Sdi12Value(100.0));
        assert_eq!(Sdi12Value::parse_single("-5").unwrap(), Sdi12Value(-5.0));
        assert_eq!(Sdi12Value::parse_single("+1234567").unwrap(), Sdi12Value(1234567.0));
        assert_eq!(Sdi12Value::parse_single("-9999999").unwrap(), Sdi12Value(-9999999.0));
        assert_eq!(Sdi12Value::parse_single("+.1").unwrap(), Sdi12Value(0.1));
        assert_eq!(Sdi12Value::parse_single("-0.").unwrap(), Sdi12Value(-0.0)); // Note: -0.0 comparison
        assert_eq!(Sdi12Value::parse_single("+0").unwrap(), Sdi12Value(0.0));
    }

    #[test]
    fn test_sdi12value_parsing_invalid() {
        assert_eq!(Sdi12Value::parse_single(""), Err(Sdi12ParsingError::InvalidFormat));
        assert_eq!(Sdi12Value::parse_single("+"), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("-"), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("1.23"), Err(Sdi12ParsingError::InvalidSign));
        assert_eq!(Sdi12Value::parse_single(" +1.23"), Err(Sdi12ParsingError::InvalidSign));
        assert_eq!(Sdi12Value::parse_single("+1.2.3"), Err(Sdi12ParsingError::MultipleDecimals));
        assert_eq!(Sdi12Value::parse_single("+1a2"), Err(Sdi12ParsingError::InvalidCharacter));
        assert_eq!(Sdi12Value::parse_single("+."), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("+12345678"), Err(Sdi12ParsingError::InvalidDigitCount)); // 8 digits, len 9 -> OK length, bad digit count

        // Input "+123.45678" (Length 10) - Should fail length check first.
        assert_eq!(
            Sdi12Value::parse_single("+123.45678"), // This was line 186
            Err(Sdi12ParsingError::InvalidFormat) // CORRECTED: Expect InvalidFormat due to length > 9
        );

        // Input "+1234567." (Length 9) - Should parse OK if trailing '.' is allowed
        assert!(Sdi12Value::parse_single("+1234567.").is_ok());

        // Input "+1234567.0" (Length 10) - Should fail length check first.
        assert_eq!(
            Sdi12Value::parse_single("+1234567.0"),
            Err(Sdi12ParsingError::InvalidFormat) // Expect InvalidFormat due to length > 9
        );
        // Input "+12345.678" (Length 10) - This also fails length check first.
         assert_eq!(
            Sdi12Value::parse_single("+12345.678"), // This was previously expecting InvalidDigitCount incorrectly
            Err(Sdi12ParsingError::InvalidFormat) // CORRECTED: Expect InvalidFormat due to length > 9
        );
        assert_eq!(Sdi12Value::parse_single("+123456789"), Err(Sdi12ParsingError::InvalidFormat)); // Too long (len 10)
    }

    #[test]
    fn test_binary_data_type_from_u8() {
        assert_eq!(BinaryDataType::from_u8(0), Some(BinaryDataType::InvalidRequest));
        assert_eq!(BinaryDataType::from_u8(1), Some(BinaryDataType::SignedI8));
        assert_eq!(BinaryDataType::from_u8(2), Some(BinaryDataType::UnsignedU8));
        assert_eq!(BinaryDataType::from_u8(3), Some(BinaryDataType::SignedI16));
        assert_eq!(BinaryDataType::from_u8(4), Some(BinaryDataType::UnsignedU16));
        assert_eq!(BinaryDataType::from_u8(5), Some(BinaryDataType::SignedI32));
        assert_eq!(BinaryDataType::from_u8(6), Some(BinaryDataType::UnsignedU32));
        assert_eq!(BinaryDataType::from_u8(7), Some(BinaryDataType::SignedI64));
        assert_eq!(BinaryDataType::from_u8(8), Some(BinaryDataType::UnsignedU64));
        assert_eq!(BinaryDataType::from_u8(9), Some(BinaryDataType::Float32));
        assert_eq!(BinaryDataType::from_u8(10), Some(BinaryDataType::Float64));
        assert_eq!(BinaryDataType::from_u8(11), None);
        assert_eq!(BinaryDataType::from_u8(255), None);
    }

     #[test]
    fn test_binary_data_type_size() {
        assert_eq!(BinaryDataType::InvalidRequest.size_in_bytes(), 0);
        assert_eq!(BinaryDataType::SignedI8.size_in_bytes(), 1);
        assert_eq!(BinaryDataType::UnsignedU8.size_in_bytes(), 1);
        assert_eq!(BinaryDataType::SignedI16.size_in_bytes(), 2);
        assert_eq!(BinaryDataType::UnsignedU16.size_in_bytes(), 2);
        assert_eq!(BinaryDataType::SignedI32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::UnsignedU32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::SignedI64.size_in_bytes(), 8);
        assert_eq!(BinaryDataType::UnsignedU64.size_in_bytes(), 8);
        assert_eq!(BinaryDataType::Float32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::Float64.size_in_bytes(), 8);
    }
}

--- FILE: README.md ---
# SDI-12 Rust Library (`sdi12-rs`) - Design & Status Report

**Date:** 2025-03-30 (Updated)

## 1. Overview

`sdi12-rs` aims to be a comprehensive, robust, and developer-friendly Rust library for interacting with the SDI-12 (Serial-Digital Interface at 1200 baud) protocol, commonly used for environmental sensors and dataloggers.

The library targets embedded systems (`no_std` by default) but is designed to be usable in `std` environments as well. It provides first-class support for both implementing SDI-12 recorder (e.g. datalogger, host) functionality and implementing SDI-12 sensor firmware. The goal is to abstract the complexities of the SDI-12 protocol (timing, framing, commands, responses, CRC, state management) behind an idiomatic and safe Rust API.

This document outlines the library's goals, design philosophy, architecture, key decisions, current status, and future directions.

## 2. Goals & Requirements

*   **Standard Compliance:** Implement the **SDI-12 Standard Version 1.4** (Feb 20, 2023), including all basic, concurrent, high-volume (ASCII & Binary), and metadata commands/responses.
*   **Target Audience:** Support developers building both **Recorders** and **Sensors**.
*   **Environment:** Be `#[no_std]` compatible by default. Provide optional, feature-gated support for `std` and `alloc`.
*   **Concurrency Models:** Offer first-class support for both **synchronous** and **asynchronous** operation patterns.
*   **Hardware Abstraction:** Integrate cleanly with the embedded Rust ecosystem, primarily via `embedded-hal` (v1.0+) traits or custom traits, remaining hardware-agnostic at its core.
*   **Framework Compatibility:** Be usable with async frameworks like Embassy, but without requiring Embassy as a direct dependency.
*   **Error Handling:** Utilize `thiserror` for robust, specific, and ergonomic error reporting.
*   **Modularity:** Organize code logically into modules for recorder logic, sensor logic, and shared common components.

## 3. Core Design Philosophy

*   **Robustness & Safety:** Leverage Rust's type system to make invalid states unrepresentable where possible (e.g., validated command indices). Provide strong error handling (`Sdi12Error`). Ensure correct protocol implementation according to the standard.
*   **Ergonomics (DX):** Offer intuitive, high-level APIs for both recorder and sensor implementors, abstracting away byte-level protocol details and state machine complexity where appropriate. Provide lower-level access (like `send_command`) for flexibility.
*   **Flexibility:** Support the four key use-case quadrants: sync `no_std`, sync `std`, async `no_std`, async `std`. Allow users to choose the hardware implementation strategy that best fits their constraints (native HAL features, generic HAL, bit-banging).
*   **Portability & Agnosticism:** Decouple the core protocol logic from specific hardware implementations via library-defined traits (`Sdi12Serial`, `Sdi12Timer`). The library provides the framework; the user provides the hardware-specific implementation or uses optional adapters.
*   **Maintainability:** Structure the code logically. Use external crates (like `crc`) for well-solved problems. Limit the burden of maintaining HAL-specific code *within* the core library.
*   **Standard Compliance:** Adhere strictly to the timings, formats, and procedures outlined in SDI-12 v1.4.

## 4. Architecture & Modules

The library uses the standard Rust crate structure (`src/lib.rs`) with the following primary modules:

*   **`common/`**: Contains foundational types, traits, and logic shared between recorder and sensor implementations. (Largely complete and stable).
    *   `address.rs`: `Sdi12Addr` struct for validated addresses.
    *   `command.rs`: `Command` enum (covering v1.4), validated index types (`MeasurementIndex`, etc.), formatting via `format_into` using `arrayvec`.
    *   `crc.rs`: CRC-16/ARC calculation (using `crc` crate) and SDI-12 specific ASCII/binary encoding/decoding/verification helpers.
    *   `error.rs`: `Sdi12Error<E>` generic protocol error enum using `thiserror`, wrapping specific command errors.
    *   `frame.rs`: `FrameFormat` enum (`Sdi12_7e1`, `Binary8N1`).
    *   `hal_traits.rs`: Defines the core hardware abstraction traits:
        *   `Sdi12Timer`: Now includes `type Instant: Sdi12Instant;` and `fn now()`.
        *   `Sdi12Instant`: Marker trait for time instants.
        *   `Sdi12Serial` (sync/nb): Defines serial operations including `send_break` and `set_config`.
        *   `Sdi12SerialAsync` (async).
        *   `NativeSdi12Uart`/`Async` (for optimized HAL integration, gated).
    *   `response.rs`: Defines `ResponseParseError`, `MeasurementTiming`, and `PayloadSlice`. Reflects the "Middle Ground" parsing approach.
    *   `timing.rs`: `const Duration` values for specified protocol timings.
    *   `types.rs`: `Sdi12Value` parsing/representation, `BinaryDataType` enum, `Sdi12ParsingError`.
*   **`recorder/`**: Contains logic for the Recorder (Datalogger) role.
    *   `mod.rs`: Declares `sync_recorder` submodule and re-exports `SyncRecorder`. Placeholder for `AsyncRecorder`.
    *   **`sync_recorder/`**: Implementation for synchronous recorder.
        *   `mod.rs`: Defines `SyncRecorder` struct, `new()` constructor, and public API methods (`acknowledge`, `send_command`).
        *   `io_helpers.rs`: Contains `execute_blocking_io_with_timeout`, `check_and_send_break`, `send_command_bytes`, `read_response_line`.
        *   `protocol_helpers.rs`: Contains `process_response_payload` (checks address, CRC, returns indices).
        *   `transaction.rs`: Contains the core `execute_transaction` logic (handles break, send, read, process, basic retries, returns indices).
*   **`sensor/`**: Contains logic and traits for the Sensor role. (Not yet implemented).
*   **`implementations/` (Directory)**: (Not yet implemented) Intended for optional, feature-gated HAL adapters.

## 5. Key Design Decisions & Rationale

*   **`no_std` First:** Default `#[no_std]` compilation. Optional `alloc` and `std` features.
*   **Sync/Async Separation:** Distinct structs (`SyncRecorder`, `AsyncRecorder`) for clarity.
*   **Hardware Abstraction Strategy:**
    *   Core logic relies on library-defined `Sdi12Serial` and `Sdi12Timer` traits.
    *   `Sdi12Timer` now includes `now()` and an associated `Instant` type constrained by `Sdi12Instant` for robust timeout handling without direct `embedded-hal` dependency in the core logic.
    *   Tiered implementation options (Native HAL, Generic HAL, Bitbang) via adapters remain the goal.
*   **Response Parsing ("Middle Ground"):**
    *   The core recorder transaction logic (`execute_transaction`) validates framing (address, CRC, CRLF) and returns the start/end **indices** of the valid payload within the user-provided buffer.
    *   Public API methods (like the planned `send_identification`) use these indices to extract the `PayloadSlice` and then perform specific payload parsing. Simpler methods like `acknowledge` might just check if the indices indicate an empty payload.
    *   **Rationale:** Keeps core library lean, `no_alloc` friendly by default, handles non-standard formats, delegates complex parsing. Optional helpers for common payloads can be added later.
*   **Command Input:**
    *   The primary way to send commands is via the type-safe `Command` enum, constructed using validated index types.
    *   The `SyncRecorder::send_command` method allows sending any pre-constructed `Command`.
    *   **Deferred:** Parsing command strings (e.g., `TryFrom<&str>` for `Command`) is deferred.
*   **Error Handling:** Using `thiserror` for `Sdi12Error<E>`; specific command/parsing errors are wrapped.
*   **CRC Handling:** Leverages the `crc` crate. Helpers for ASCII/binary CRC provided. Verification integrated into `process_response_payload`.

## 6. Current Implementation Status (2025-03-30)

*   **Crate Structure:** `common`, `recorder`, `sensor` modules established. `recorder::sync_recorder` submodule created and populated.
*   **`common` Module:** Largely complete and tested. Foundational types, traits (including enhanced `Sdi12Timer`), CRC, errors, commands are defined. `Command::format_into` implemented.
*   **`recorder::sync_recorder` Module:**
    *   `SyncRecorder` struct defined with `new` constructor.
    *   Core transaction logic (`execute_transaction`) implemented, including break checks, command sending, response reading (with timeout via `Sdi12Timer`), payload validation (address, CRC, framing), and basic retry logic for timeouts/read errors. Returns payload indices.
    *   Internal helpers (`check_and_send_break`, `send_command_bytes`, `read_response_line`, `process_response_payload`) implemented.
    *   Public API methods `acknowledge` and the flexible `send_command` are implemented.
*   **Features:** `alloc`, `std`, `async` features defined. Builds and tests pass for default (`no_std`) and `--features alloc`.
*   **Dependencies:** Updated based on needs (`arrayvec`, `crc`, `nb`, `thiserror`). `embedded-hal` is optional for adapters.

## 7. Remaining Core Implementation ("Minimum Viable Product")

*   **`recorder::SyncRecorder` Public Methods:** Implement remaining high-level methods (`identify`, `change_address`, `start_measurement`, `send_data`, etc.) using `execute_transaction` and adding necessary payload parsing logic (potentially gated by `alloc`/`heapless` features for returning structured data).
*   **Refine Retry Logic:** Review and potentially enhance the retry logic in `execute_transaction`, particularly regarding break conditions on retries as per Spec 7.2.
*   **Sensor Implementation:**
    *   Define `sensor::SensorHandler` trait.
    *   Implement `sensor::SyncSensor` runner (command parsing, handler dispatch, response formatting, state management).
    *   Requires implementing command *parsing* logic (likely `Command::try_from_bytes` or similar).
*   **Adapters (Minimal):** Implement at least the `NativeAdapter` (`implementations/native.rs`) using `NativeSdi12Uart` and a basic `GenericHalAdapter` to bridge `embedded-hal` traits to `Sdi12Serial`/`Sdi12Timer`.
*   **Basic Examples:** Create simple examples demonstrating recorder usage (e.g., `acknowledge`, `send_identification` on real hardware like Pico). A loopback test example would also be valuable.

## 8. Tech Debt / Future Improvements

*   **Command String Parsing:** Implement `TryFrom<&[u8]>` or similar for `Command` for user convenience and sensor-side implementation.
*   **`alloc`/`heapless` Features:** Fully integrate these features. Provide `heapless`-based alternatives for `Command::ExtendedCommand` and response parsing helpers. Offer `alloc`-based parsing helpers that return `Vec<Sdi12Value>`, `IdentificationInfo`, etc.
*   **Refine Retry Logic:** Implement the more complex break-on-retry timing specified in Sec 7.2 if needed for robustness.
*   **Payload Parsing Helpers:** Implement optional (`alloc`/`heapless` gated) functions to parse common payload types (`IdentificationInfo`, `MeasurementTiming`, `Sdi12Value` vectors) from the indices/buffer provided by `send_command`.
*   **Async Implementation:** Fully implement `AsyncRecorder`, `AsyncSensor`, and async adapters (`Sdi12SerialAsync`, async `Sdi12Timer`).
*   **Sensor Implementation:** Complete the sensor-side logic. Consider a macro helper (`#[sdi12_handler]`) for defining `SensorHandler` implementations.
*   **More Adapters:** Provide feature-gated adapters for popular `embedded-hal` families (STM32, RP2040, ESP-HAL, etc.) and `std` (using `serialport`).
*   **Documentation & Examples:** Add comprehensive `rustdoc`, usage examples (especially for Pico target), and potentially a small book/tutorial. Enforce documentation with `#![forbid(missing_docs)]`.
*   **Timeout Configuration:** Allow users to configure default timeout durations for transactions.
*   **Testing:** Add integration tests (simulated loopback, hardware loopback), hardware-in-the-loop tests with real sensors/recorders. Test edge cases and error conditions more thoroughly. Test async race conditions. Clean up test mock inconsistencies (e.g., `Clone` derive).
*   **Buffer Sizes:** Review fixed buffer sizes (like `MAX_FORMATTED_LEN`) and consider making them configurable or using alternatives where appropriate.

## 9. Conclusion

The `sdi12-rs` library has made significant progress. The `common` module is robust, and the core synchronous recorder transaction logic (`execute_transaction` with its helpers) is now implemented, including timeout handling via the enhanced `Sdi12Timer` trait and basic retries. The flexible `send_command` public API method provides immediate utility for testing and interacting with sensors. The next steps involve building out the remaining specific public recorder methods, implementing the sensor side, providing HAL adapters, and creating examples for real-world usage.

--- FILE: src/common/address.rs ---
// src/common/address.rs

use super::error::Sdi12Error;
use core::convert::TryFrom;
use core::fmt;

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
pub struct Sdi12Addr(char);

impl Sdi12Addr {
    pub const DEFAULT_ADDRESS: Sdi12Addr = Sdi12Addr('0');
    pub const QUERY_ADDRESS: Sdi12Addr = Sdi12Addr('?');

    /// Creates a new `Sdi12Addr` if the given character is a valid address.
    /// Returns `Result<Self, Sdi12Error<()>>` because validation itself
    /// cannot cause an I/O error.
    pub fn new(address_char: char) -> Result<Self, Sdi12Error<()>> {
        if Self::is_valid_address_char(address_char) || address_char == '?' {
            Ok(Sdi12Addr(address_char))
        } else {
            // Directly create the specific error variant with E = ()
            Err(Sdi12Error::InvalidAddress(address_char))
        }
    }

    // Unsafe constructor remains the same
    pub const unsafe fn new_unchecked(address_char: char) -> Self {
        Sdi12Addr(address_char)
    }

    #[inline]
    pub const fn as_char(&self) -> char {
        self.0
    }

    #[inline]
    pub const fn is_query(&self) -> bool {
        self.0 == '?'
    }

    #[inline]
    pub const fn is_standard(&self) -> bool {
        // This one was okay because '0'..='9' is a single range pattern
        matches!(self.0, '0'..='9')
    }

    #[inline]
    pub const fn is_extended(&self) -> bool {
        // CORRECTED: Use '|' directly as a pattern separator
        matches!(self.0, 'a'..='z' | 'A'..='Z')
    }

    #[inline]
    pub const fn is_valid_address_char(c: char) -> bool {
        // CORRECTED: Use '|' directly as a pattern separator
        matches!(c, '0'..='9' | 'a'..='z' | 'A'..='Z')
    }
}

impl Default for Sdi12Addr {
    fn default() -> Self {
        Self::DEFAULT_ADDRESS
    }
}

// CORRECTED: Implement TryFrom<char> without the generic E
impl TryFrom<char> for Sdi12Addr {
    // The error type here is specific: Sdi12Error with no I/O error possibility
    type Error = Sdi12Error<()>;

    /// Attempts to convert a character into an `Sdi12Addr`.
    fn try_from(value: char) -> Result<Self, Self::Error> {
        // Reuse the validation logic from Self::new()
        // Since Self::new() now returns Result<_, Sdi12Error<()>>, this works directly.
        Self::new(value)
        // Or, implement directly:
        // if Sdi12Addr::is_valid_address_char(value) || value == '?' {
        //     Ok(Sdi12Addr(value))
        // } else {
        //     Err(Sdi12Error::InvalidAddress(value))
        // }
    }
}


impl From<Sdi12Addr> for char {
    fn from(value: Sdi12Addr) -> Self {
        value.0
    }
}

impl fmt::Display for Sdi12Addr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    // Mock error type is no longer strictly needed inside the tests for `new` or `try_from`
    // because they now return `Sdi12Error<()>` which doesn't involve a generic `E`.
    // We might still need it later for testing functions that *do* take an E.
    #[derive(Debug, Clone, PartialEq, Eq)]
    struct MockIoError;
    impl fmt::Display for MockIoError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "Mock I/O Error") }
    }

    #[test]
    fn test_valid_addresses() {
        assert!(Sdi12Addr::new('0').is_ok());
        assert!(Sdi12Addr::new('5').is_ok());
        assert!(Sdi12Addr::new('9').is_ok());
        assert!(Sdi12Addr::new('a').is_ok());
        assert!(Sdi12Addr::new('z').is_ok());
        assert!(Sdi12Addr::new('A').is_ok());
        assert!(Sdi12Addr::new('Z').is_ok());
        assert!(Sdi12Addr::new('?').is_ok());
    }

    #[test]
    fn test_invalid_addresses() {
        assert!(matches!(Sdi12Addr::new(' '), Err(Sdi12Error::InvalidAddress(' '))));
        assert!(matches!(Sdi12Addr::new('$'), Err(Sdi12Error::InvalidAddress('$'))));
        assert!(matches!(Sdi12Addr::new('\n'), Err(Sdi12Error::InvalidAddress('\n'))));
        assert!(matches!(Sdi12Addr::new('é'), Err(Sdi12Error::InvalidAddress('é'))));
    }

    // test_default_address, test_query_address, test_address_types remain the same

    #[test]
    fn test_try_from_char() {
        assert_eq!(Sdi12Addr::try_from('1').unwrap(), Sdi12Addr('1'));
        assert_eq!(Sdi12Addr::try_from('b').unwrap(), Sdi12Addr('b'));
        assert_eq!(Sdi12Addr::try_from('C').unwrap(), Sdi12Addr('C'));
        assert_eq!(Sdi12Addr::try_from('?').unwrap(), Sdi12Addr('?'));
        assert!(matches!(Sdi12Addr::try_from('*'), Err(Sdi12Error::InvalidAddress('*'))));
    }

    // test_into_char, test_display, test_as_char, test_is_valid_address_char, test_new_unchecked remain the same
}

--- FILE: updatedreadme.md ---


--- FILE: src/common/timing.rs ---
// src/common/timing.rs

use core::time::Duration;

// Note: Tolerances are generally +/- 0.40 ms according to the spec (Sec 7.0),
// except for inter-character time. We define the nominal values here.
// Implementations using these should factor in tolerances where appropriate,
// especially when checking received timings.

// === Break Timing (Sec 7.0, 7.1) ===

/// Minimum duration for a valid break signal (recorder must send >= 12 ms).
pub const BREAK_DURATION_MIN: Duration = Duration::from_millis(12);
/// Sensor must recognize a break if spacing > 12 ms.
pub const BREAK_RECOGNITION_MAX: Duration = Duration::from_millis(12);
/// Sensor will *not* recognize a break if spacing < 6.5 ms.
pub const BREAK_IGNORE_MAX: Duration = Duration::from_micros(6500);
/// Marking time required after a break before sensor looks for an address.
pub const POST_BREAK_MARKING_MIN: Duration = Duration::from_micros(8330);

// === Command/Response Timing (Sec 7.0) ===

/// Maximum time from end of command stop bit for recorder to release line.
pub const RECORDER_RELEASE_TIME_MAX: Duration = Duration::from_micros(7_900); // 7.5ms + 0.4ms tol
/// Nominal marking time sent by sensor before starting response.
pub const SENSOR_PRE_RESPONSE_MARKING: Duration = Duration::from_micros(8330);
/// Maximum time from end of command stop bit to start bit of first response byte.
pub const RESPONSE_START_TIME_MAX: Duration = Duration::from_micros(15_400); // 15ms + 0.4ms tol
/// Maximum time from end of response stop bit for sensor to release line.
pub const SENSOR_RELEASE_TIME_MAX: Duration = Duration::from_micros(7_900); // 7.5ms + 0.4ms tol
/// Maximum marking time allowed between characters in a command or response.
pub const INTER_CHARACTER_MARKING_MAX: Duration = Duration::from_micros(1660);


// === Sensor Wake/Sleep Timing (Sec 7.0) ===

/// Maximum time for sensor to wake up after detecting a break and be ready for command start bit.
pub const SENSOR_WAKEUP_TIME_MAX: Duration = Duration::from_millis(100);
/// Marking time after which sensor returns to low-power standby (if not actively processing/responding).
pub const SENSOR_SLEEP_MARKING_TIME: Duration = Duration::from_millis(100);
/// Time threshold after which a break *must* precede the next command if line was marking.
/// (Spec says > 87 ms in Sec 7.1 implies break needed, aligned with retry logic in Sec 7.2).
pub const PRE_COMMAND_BREAK_MARKING_THRESHOLD: Duration = Duration::from_millis(87);

// === Retry Timing (Sec 7.2) ===

/// Minimum wait time after a command before recorder issues a retry (if no response).
pub const RETRY_WAIT_MIN: Duration = Duration::from_micros(16670); // 16.67 ms
/// Maximum wait time after a command before recorder issues a retry without a preceding break.
/// (This period also covers the RETRY_WAIT_MIN).
pub const RETRY_WAIT_MAX_NO_BREAK: Duration = Duration::from_millis(87);
/// Minimum delay after the *end of the break* before issuing at least one retry,
/// to ensure sensor has had SENSOR_WAKEUP_TIME_MAX to wake up.
pub const RETRY_POST_BREAK_DELAY_MIN: Duration = SENSOR_WAKEUP_TIME_MAX;

// === Other ===

/// Time between lines for multi-line text responses (Sec 4.4.13.1). Max 150ms.
pub const MULTILINE_INTER_LINE_DELAY_MAX: Duration = Duration::from_millis(150);

// === Byte Timing at 1200 Baud (7E1) ===
// 1 start bit + 7 data bits + 1 parity bit + 1 stop bit = 10 bits per byte
// Time per bit = 1 / 1200 seconds = 0.8333... ms
// Time per byte = 10 * (1 / 1200) seconds = 10 / 1200 s = 1 / 120 s = 8.333... ms

/// Nominal duration of a single bit at 1200 baud.
pub const BIT_DURATION: Duration = Duration::from_nanos(833_333); // Approx 0.833 ms
/// Nominal duration of a single byte (10 bits total) at 1200 baud (7E1 format).
pub const BYTE_DURATION: Duration = Duration::from_micros(8333); // Approx 8.33 ms

--- FILE: src/common/mod.rs ---
// src/common/mod.rs

// --- Declare all public modules within common ---
pub mod address;
pub mod command;
pub mod crc;
pub mod error;
pub mod frame;
pub mod hal_traits;
pub mod response; // Points to the single file
pub mod timing;
pub mod types;

// --- Re-export key types/traits/functions for easier access ---

// From address.rs
pub use address::Sdi12Addr;

// From command.rs
pub use command::{
    Command, CommandIndexError, CommandFormatError, // Added FormatError
    MeasurementIndex, ContinuousIndex, DataIndex, IdentifyParameterIndex,
    IdentifyMeasurementCommand, IdentifyMeasurementParameterCommand,
};

// From crc.rs
pub use crc::{
    calculate_crc16, encode_crc_ascii, decode_crc_ascii, verify_response_crc_ascii,
    encode_crc_binary, decode_crc_binary, verify_packet_crc_binary,
};

// From error.rs
pub use error::Sdi12Error;

// From frame.rs
pub use frame::FrameFormat;

// From hal_traits.rs
pub use hal_traits::{Sdi12Serial, Sdi12Timer}; // Core sync traits

// From response.rs (Simplified re-exports)
pub use response::{
    ResponseParseError, // The error enum for frame/crc/address issues
    MeasurementTiming,  // The struct for specifically parsed timing responses
    PayloadSlice,       // The wrapper for returned raw payloads
};

// From timing.rs (constants)

// From types.rs
pub use types::{BinaryDataType, Sdi12ParsingError, Sdi12Value};


// --- Feature-gated re-exports ---

// Async traits (from hal_traits.rs)
#[cfg(feature = "async")]
pub use hal_traits::Sdi12SerialAsync;

// Native HAL integration traits (from hal_traits.rs)
#[cfg(feature = "impl-native")]
pub use hal_traits::NativeSdi12Uart;
#[cfg(all(feature = "async", feature = "impl-native"))]
pub use hal_traits::NativeSdi12UartAsync;

// Note: No alloc-dependent response types re-exported from common::response
// Types like IdentificationInfo, DataInfo etc. are now internal details
// potentially used by optional parsing helpers.

--- FILE: src/recorder/sync_recorder/mod.rs ---
// src/recorder/sync_recorder/mod.rs

// Declare the implementation detail modules
mod io_helpers;
mod protocol_helpers;
mod transaction;

// Necessary imports for struct definition and public methods
use crate::common::{
    address::Sdi12Addr,
    command::Command,
    error::Sdi12Error,
    hal_traits::{Sdi12Instant, Sdi12Serial, Sdi12Timer},
    // response::PayloadSlice, // Not needed directly in this file anymore
};
use core::fmt::Debug;
// use core::time::Duration;

#[derive(Debug)]
pub struct SyncRecorder<IF>
where
    IF: Sdi12Serial + Sdi12Timer,
    IF::Error: Debug,
    IF::Instant: Sdi12Instant,
{
    interface: IF,
    last_activity_time: Option<IF::Instant>,
}

// Implementation block for constructor and public methods
impl<IF> SyncRecorder<IF>
where
    IF: Sdi12Serial + Sdi12Timer,
    IF::Error: Debug,
    IF::Instant: Sdi12Instant,
{
    pub fn new(interface: IF) -> Self {
        SyncRecorder {
            interface,
            last_activity_time: None,
        }
    }

    // --- Public Blocking Methods ---

    pub fn acknowledge(&mut self, address: Sdi12Addr) -> Result<(), Sdi12Error<IF::Error>> {
        let cmd = Command::AcknowledgeActive { address };
        const ACK_BUF_SIZE: usize = 96;
        let mut read_buffer = [0u8; ACK_BUF_SIZE];
        let (start, end) = self.execute_transaction(&cmd, &mut read_buffer)?;

        if start == end { Ok(()) } else { Err(Sdi12Error::InvalidFormat) }
    }

    /// Sends a pre-constructed SDI-12 command and returns the raw payload indices.
    ///
    /// This method allows sending any command supported by the `Command` enum,
    /// including basic, concurrent, high-volume, metadata, and (with 'alloc') extended commands.
    /// It handles break generation, command formatting, retries, response reading,
    /// address/CRC validation, and returns the start/end indices of the validated payload
    /// within the provided read buffer on success.
    ///
    /// # Arguments
    /// * `command`: The `sdi12::common::Command` to send.
    /// * `read_buffer`: A mutable byte slice to store the sensor's response line.
    ///                  A size of ~96 bytes is recommended for standard commands.
    ///
    /// # Returns
    /// * `Ok((usize, usize))` containing the start and end indices of the payload within `read_buffer`.
    /// * `Err(Sdi12Error)` on communication error, timeout, or invalid response framing/CRC.
    pub fn send_command<'buf>( // Add lifetime marker for read_buffer
        &mut self,
        command: &Command,
        read_buffer: &'buf mut [u8],
    ) -> Result<(usize, usize), Sdi12Error<IF::Error>> {
        // Directly use the core transaction logic defined in transaction.rs
        self.execute_transaction(command, read_buffer)
    }

    // TODO: Implement other specific public methods like send_identification etc.

} // End impl SyncRecorder

// --- Unit Tests ---
#[cfg(test)]
mod tests {
   // Minimal tests for construction remain. Tests for acknowledge/send_command
   // behavior are better placed with execute_transaction tests as they rely heavily on it.
    use super::*;
    use crate::common::address::Sdi12Addr; // Keep for potential future tests
    use crate::common::hal_traits::{Sdi12Instant, Sdi12Serial, Sdi12Timer};
    use crate::common::{FrameFormat, Sdi12Error};
    use core::time::Duration;
    use nb::Result as NbResult;
    use nb;

    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
    struct MockInstant(u64);
    impl core::ops::Add<Duration> for MockInstant { type Output = Self; fn add(self, rhs: Duration) -> Self { MockInstant(self.0.saturating_add(rhs.as_micros() as u64)) } }
    impl core::ops::Sub<MockInstant> for MockInstant { type Output = Duration; fn sub(self, rhs: MockInstant) -> Duration { Duration::from_micros(self.0.saturating_sub(rhs.0)) } }
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct MockCommError;
    #[derive(Clone)]
    struct MockInterface;
    impl Sdi12Timer for MockInterface { type Instant = MockInstant; fn delay_us(&mut self, _us: u32) {} fn delay_ms(&mut self, _ms: u32) {} fn now(&self) -> Self::Instant { MockInstant(0) } }
    impl Sdi12Serial for MockInterface { type Error = MockCommError; fn read_byte(&mut self) -> NbResult<u8, Self::Error> { Err(nb::Error::WouldBlock) } fn write_byte(&mut self, _byte: u8) -> NbResult<(), Self::Error> { Ok(()) } fn flush(&mut self) -> NbResult<(), Self::Error> { Ok(()) } fn send_break(&mut self) -> NbResult<(), Self::Error> { Ok(()) } fn set_config(&mut self, _config: FrameFormat) -> Result<(), Self::Error> { Ok(()) } }

    #[test]
    fn test_recorder_construction_in_mod() {
        let mock_interface = MockInterface;
        let recorder = SyncRecorder::new(mock_interface);
        assert!(recorder.last_activity_time.is_none());
    }
}

--- FILE: sdi12.txt ---
SDI-12
A Serial-Digital Interface Standard
for
Microprocessor-Based Sensors
Version 1.4

February 20, 2023

Prepared By
SDI-12 Support Group
(Technical Committee)
165 East 500 South
River Heights, Utah
435-752-4200
435-752-1691 (FAX)
www.sdi-12.org

SDI-12 is not currently registered by any professional society, standards organization, or Government agency. Document
copies, current document status, and other information can be obtained by contacting the SDI-12 Support Group at 165 East
500 South, River Heights, Utah 84321, 435-752-4200, FAX 435-752-1691.

TABLE OF CONTENTS

1.0 INTRODUCTION....................................................................................................................1
2.0 ADVANTAGES OF SDI-12 ....................................................................................................1
3.0 SDI-12 ELECTRICAL INTERFACE....................................................................................2
3.1 Serial Data Line .............................................................................................................3
3.1.1 Voltage Transitions .........................................................................................3
3.1.2 Impedance .......................................................................................................3
3.2 Ground Line ...................................................................................................................4
3.2.1 Transient Protection ........................................................................................4
3.3 12-Volt Line ...................................................................................................................4
3.4 Connectors .....................................................................................................................5
4.0 SDI-12 COMMUNICATIONS PROTOCOL........................................................................5
4.1 Baud Rate and Byte Frame Format ................................................................................6
4.2 Allowable Characters .....................................................................................................6
4.3 Device Addresses ...........................................................................................................6
4.4 SDI-12 Commands and Responses ................................................................................7
4.4.1 Acknowledge Active Command (a!) ..............................................................9
4.4.1.1 Examples of the Acknowledge Active Command (a!) ..................9
4.4.2 Send Identification Command (aI!) ................................................................9
4.4.2.1 Example of the Send Identification Command ............................10
4.4.3 Address Query Command (?!) ......................................................................10
4.4.4 Change Address Command (aAb!) ...............................................................11
4.4.5 Start Measurement Command (aM!) ............................................................11
4.4.5.1 Aborting a Measurement ..............................................................12
4.4.6 Service Request .............................................................................................13

2/20/2023 Version 1.4

ii

4.4.7 Start Concurrent Measurement Command....................................................13
4.4.7.1 Aborting a Concurrent Measurement ...........................................14
4.4.8 Send Data Command (aD0! ... aD9!) ............................................................14
4.4.8.1 Continuous Measurements (aR0! ... aR9!) .................................. 16
4.4.8.2 Example of the aR0! Command .................................................. 16
4.4.8.3 Return of Multiple Measurements (Parameters) by a Sensor (D1!
… D9!) .....................................................................................................16
4.4.8.4 Examples of the Start Measurement Command (aM!) and the
Send Data Commands ..............................................................................17
4.4.8.5 Example of the Concurrent Measurement Command (aC!) and the
Send Data Command (aD0!) ................................................................... 18
4.4.9 Additional Measurement Commands (aM1! . . . aM9!) ...............................18
4.4.9.1 Examples of the Additional M Commands (aMn!) ......................19
4.4.10 Additional Concurrent Measurement Commands (aC1! … aC9!) .............19
4.4.11 Start Verification (aV!) ...............................................................................19
4.4.11.1 Examples of the Start Verification Command (aV!) ..................20
4.4.12 Requesting a Cyclic Redundancy Check ....................................................20
4.4.12.1 CRC-16 Computation.................................................................20
4.4.12.2 Encoding the CRC as ASCII Characters ....................................21
4.4.12.3 Examples of the CRC-16 Start Measurement Command (aMC!)
and the Send Data Command .................................................................. 21
4.4.13 Extended Commands ..................................................................................22
4.4.13.1 Extended Commands Returning Multiple Lines of Text .............23

4.4.14 Transparent Mode .......................................................................................24

2/20/2023 Version 1.4

iii

5.0 HIGH-VOLUME COMMANDS ......................................................................................... 24
5.1 Start High-Volume ASCII Measurement.....................................................................24
5.1.1 Example of High-Volume ASCII Measurement.......................................................25
5.2 Start High-Volume Binary Measurement ....................................................................26
5.2.1 High-Volume Binary Data Types .....................................................27
5.2.2 Example of High-Volume Binary Command .................................. 28
5.3 Concurrency of High-Volume Commands ................................................................. 29
5.4 Compliance with High-Volume Commands ............................................................... 29
6.0 METADATA COMMANDS .................................................................................................29
6.1 Identify Measurement Commands ...............................................................................29
6.1.1 Examples of the Identify Measurement Commands .........................30
6.2 Identify Measurement Parameter Commands ..............................................................30
6.2.1 Field One ...........................................................................................31
6.2.2 Field Two ..........................................................................................31
6.2.3 Optional Fields ..................................................................................31
6.2.4 Examples of the Identify Measurement Parameter Commands ........33
6.3 Compliance with Metadata Commands .......................................................................33
7.0 SDI-12 Timing ........................................................................................................................34
7.1 Rules for the Break ......................................................................................................35
7.2 Retries ..........................................................................................................................36

2/20/2023 Version 1.4

iv

APPENDICES ..............................................................................................................................37
Appendix A:
Appendix B:
Appendix C:
Appendix D:

2/20/2023 Version 1.4

Suggested SDI-12 Circuits .................................................................... A-1
Suggested SDI-12 Flow Control for SDI-12 Data Recorders ................B-1
& SDI-12 Sensors...................................................................................B-2
SDI-12 Glossary .....................................................................................C-1
Revisions ............................................................................................... D-1

v

LIST OF TABLES

Table 1. Logic and Voltage Levels for Serial Data .......................................................................3
Table 2. SDI-12 Byte Frame Format .............................................................................................6
Table 3. Printable Characters .........................................................................................................6
Table 4. Sensor Address Codes .....................................................................................................7
Table 5. The SDI-12 Basic Command/Response Set ....................................................................8
Table 6. The Acknowledge Active Command (a!) ........................................................................9
Table 7. The Send Identification Command (aI!) ........................................................................10
Table 8. The Change Address Command (aAb!) ........................................................................11
Table 9. The Start Measurement Command (aM!) ......................................................................11
Table 10. The Start Concurrent Measurement Command (aC!) ....................................................14
Table 11. The Send Data Command (aD0!, aD1 . . . aD9!) ...........................................................15
Table 12. High-Volume ASCII Measurement ...............................................................................24
Table 13. High-Volume Binary Measurement...............................................................................25
Table 14. Data Packet ....................................................................................................................26
Table 15. Empty Data Packet.........................................................................................................26
Table 16. Data Types .....................................................................................................................27
Table 17. Data Values in High-Volume Binary Command Example ............................................28
Table 18. Data Packet Examples ...................................................................................................28
Table 19. The Identify Measurement Commands................................................................ 29 & 30
Table 20. The Identify Measurement Parameter Commands .............................................. 32 & 33

2/20/2023 Version 1.4

vi

LIST OF FIGURES

Figure 1. The SDI-12 Bus ................................................................................................................. 3
Figure 2. Equivalent Circuit.............................................................................................................. 4
Figure 3. SDI-12 Timing................................................................................................................. 34

2/20/2023 Version 1.4

vii

SDI-12
A SERIAL-DIGITAL INTERFACE STANDARD
FOR MICROPROCESSOR-BASED SENSORS
SDI-12 Version 1.4

1.0 INTRODUCTION
This document describes Version 1.4 of the SDI-12 standard. Version 1.4 is an upgrade
from Version 1.3, dated January 28, 2016. The purpose of this document is to describe SDI-12 in
detail and to provide examples of all SDI-12 commands and responses. (See appendix D for a list
of upgrades made since Version 1.0.)
SDI-12 is a standard for interfacing data recorders with microprocessor-based sensors.
SDI-12 stands for serial/digital interface at 1200 baud. This document describes the electrical
interface, the communications protocol, and the timing requirements for SDI-12 data recorders
and SDI-12 sensors.
SDI-12 is intended for applications with the following requirements:
• Battery powered operation with minimal current drain
• Low system cost
• Use of a single data recorder with multiple sensors on one cable (see section 3.0
for details)
2.0 ADVANTAGES OF SDI-12
A serial-digital interface is a logical choice for interfacing microprocessor-based sensors
with a data recorder. This has advantages for sensors and data recorders.
• Unique and complex self-calibration algorithms can be done in
microprocessor-based sensors.
• Sensors can be interchanged without reprogramming the data recorder with
calibration or other information.
• Power is supplied to sensors through the interface.
• Hybrid circuit and surface mount technologies make it practical to include the
power supply regulator, a microprocessor, and other needed circuitry in small
sensor packages.
2/20/2023 Version 1.4

1

• Sensors can use low cost EEPROMs (electrically erasable programmable read
only memory) for calibration coefficients and other information instead of internal
trimming operations.
• The use of a standard serial interface eliminates significant complexity in the
design of data recorders.
• Data recorders can be designed and produced independently of future sensor
development.
• SDI-12 data recorders interface with a variety of sensors.
• SDI-12 sensors interface with a variety of data recorders.
• Personnel trained in SDI-12 will have skills to work with a variety of SDI-12
data recorders and SDI-12 sensors.
• SDI-12 sensors with the most recent version of SDI-12 will work with data
recorders using earlier versions of SDI-12 and vice versa.

3.0 SDI-12 ELECTRICAL INTERFACE
The SDI-12 electrical interface uses the SDI-12 bus to transmit serial data between
SDI-12 data recorders and sensors. The SDI-12 bus is the cable that connects multiple SDI-12
devices. This is a cable with three conductors:
1) a serial data line
2) a ground line
3) a 12-volt line
In the following specifications, all values not indicating specific limits, have an allowable
tolerance of ±10% of the value.
Figure 1 shows the SDI-12 bus connecting one data recorder with two sensors. The
SDI-12 bus is capable of having at least 10 sensors connected to it, each with 200 feet of cable.
With fewer sensors, longer cable lengths are possible.

2/20/2023 Version 1.4

2

3.1 Serial Data Line
The data line is a bidirectional, three-state, data transfer line. Table 1 shows the logic and
voltage levels for the transmission of serial data for the SDI-12 standard. The data line uses
negative logic.
Condition

Binary state

Voltage range

marking

1

-0.5 to 1.0 volts

spacing

0

3.5 to 5.5 volts

transition

undefined

1.0 to 3.5 volts

Table 1. Logic and voltage levels for serial data
3.1.1 Voltage Transitions
During normal operation, the data line voltage slew rate must not be greater than 1.5
volts per microsecond.
3.1.2 Impedance
When an SDI-12 device has its transmitter on, its direct current (DC) source resistance
must be greater than 1000 ohms and less than 2000 ohms. Due to this impedance, the maximum
cable length depends on the capacitance of all cables connected to the data line. When any
SDI-12 device's transmitter is off, including during a low-power standby mode, the DC
resistance to ground must be within 160K to 360K ohms. If an SDI-12 sensor does not use the
12-volt line for power, its data line resistance to ground while powered down must be within
160K to 360K ohms. Figure 2 shows an equivalent circuit.
2/20/2023 Version 1.4

3

3.2 Ground Line
The ground line must be connected to the circuit ground and the earth ground at the data
recorder. The sensor circuit ground also must be connected to the ground line, but not normally
to its own earth ground. If it is necessary to connect the sensor circuitry to earth ground, a heavy
(12 AWG or larger) ground wire should be connected between the sensor earth ground and the
data recorder earth ground for lightning protection.
The ground conductor should be large enough to keep the voltage drop between the data
recorder and all sensors less than 0.5 volts during the maximum combined sensor current drain.
3.2.1 Transient Protection
Transient protection is recommended on the SDI-12 bus. See appendix A for a suggested
SDI-12 transient protection method.
3.3 12 Volt-Line
The data recorder (or the external power supply) provides between 9.6 volts and 16 volts
to the 12-volt line, with respect to ground, as measured under a maximum sensor load of 0.5
amperes. SDI-12 does not require the data recorder to be the source of power to the 12-volt line.

2/20/2023 Version 1.4

4

For sensors connected to the 12-volt line that exhibit an inductive load, a series diode is
recommended. SDI-12 does not require voltage limiting for transient protection in the sensor.
Transient protection is, however, recommended. See appendix A for suggested circuits for
transient protection.
3.4 Connectors
A connector type for SDI-12 is not specified.
4.0 SDI-12 COMMUNICATIONS PROTOCOL
SDI-12 data recorders and sensors communicate by an exchange of ASCII characters on
the data line. The data recorder sends a break to wake up the sensors on the data line. A break is
continuous spacing on the data line for at least 12 milliseconds. The data recorder then sends a
command. The sensor, in turn, returns the appropriate response. Each command is for a specific
sensor. The first character of each command is a unique sensor address that specifies with which
sensor the recorder wants to communicate. Other sensors on the SDI-12 bus ignore the command
and return to low-power standby mode. When a data recorder tells a sensor to start its
measurement procedure, the recorder does not communicate with any other sensor until the data
collection from the first sensor is complete. (During a concurrent measurement command,
however, a data recorder can communicate with other sensors while one or more sensors are
taking measurements. See section 4.4.7.)
A typical recorder/sensor measurement sequence proceeds as follows:
Step 1. The data recorder wakes all sensors on the SDI-12 bus with a break.
Step 2. The recorder transmits a command to a specific, addressed sensor, instructing it
to make a measurement.
Step 3. The addressed sensor responds within 15.0 milliseconds returning the maximum
time until the measurement data will be ready and the number of data values it will
return.
Step 4. If the measurement is immediately available, the recorder transmits a command
to the sensor instructing it to return the measurement(s). If the measurement is not ready,
the data recorder waits for the sensor to send a request to the recorder, which indicates
that the data are ready. The recorder then transmits a command to get the data.
Step 5. The sensor responds, returning one or more measurements.

2/20/2023 Version 1.4

5

4.1 Baud Rate and Byte Frame Format
The baud rate for SDI-12 is 1200. Table 2 shows the byte frame format for SDI-12.
1 start bit
7 data bits, least significant bit transmitted first
1 parity bit, even parity
1 stop bit

Table 2. SDI-12 byte frame format

4.2 Allowable Characters
All characters transmitted on the SDI-12 bus must be printable ASCII characters. Table 3
shows the printable characters.
space, 32 decimal
through
~, 126 decimal

Table 3. Printable characters

There are three exceptions:
1) all responses from an SDI-12 sensor end with a carriage return (0D hex, 13 decimal)
and a line feed (0A hex, 10 decimal) character, shown as <CR><LF> in this document;
2) in some cases the second and third character of a CRC code may not be printable
ASCII characters;
3) the contents of data packets returned by the high-volume binary command.
4.3 Device Addresses
The first character of every command must be a sensor address. Likewise, the first
character of a response is also the address character. This lets an SDI-12 recorder verify that the
response has come from the correct sensor. (An address is a single character used to indicate
which sensor is to respond to the command.) Table 4 shows the address codes.

2/20/2023 Version 1.4

6

ASCII address
(a single character)

Decimal

Hex

Description

"0" (zero)

48

30

Default address, all sensors are initially set to
"0" (zero) by the manufacturer for use in single
sensor systems

"1" to "9"

49 to 57

31 to 39

Addresses for additional sensors on the SDI-12
bus

Table 4. Sensor address codes

ASCII '0' through ASCII '9' are the standard addresses which all sensors and data
recorders must support. Should there be a need for more than 10 sensors, use an address in the
range ASCII 'A' through ASCII 'Z' (decimal 65 through 90) and ASCII 'a' through ASCII 'z'
(decimal 97 through 122).

4.4 SDI-12 Commands and Responses
Table 5 lists each basic SDI-12 command, its format, and the format of each response to a
command. All SDI-12 Version 1.4 sensors and data recorders must support all commands in this
table. None of the basic commands should affect the sensor’s calibration. In addition, sensors
may support extended commands as described in section 4.4.13. The terms in this table
(a,ll,cccccccc,mmmmmm,vvv,xxx,<values>, etc.) are described in sections 4.4.1 to 4.4.12.

2/20/2023 Version 1.4

7

Name

Command

Response

Break

Continuous
spacing for at least
12 milliseconds
a!
aI!
aAb!

None

Acknowledge Active
Send Identification
Change Address
Address Query
Start Measurement*
Start Measurement and Request
CRC*
Send Data

Additional Measurements*

?!
aM!
aMC!

a<CR><LF>
allccccccccmmmmmmvvvxxx...xx<CR><LF>
b<CR><LF> (support for this command is required only if
the sensor supports software changeable addresses)
a<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aD0!
.
.
.
aD9!
aM1!
.
.
.
aM9!
aMC1! ... aMC9!

a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

Additional Measurements and
Request CRC*
Start Verification*
aV!
Start Concurrent Measurement
aC!
Start Concurrent Measurement and aCC!
Request CRC
Additional Concurrent
aC1!
Measurements
.
.
.
aC9!
Additional Concurrent
aCC1! ... aCC9!
Measurements and Request CRC
Continuous Measurements
aR0! ... aR9!
Continuous Measurements and
aRC0! ... aRC9!
Request CRC
*

or
or
or
or
or

a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>

atttn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
a<values><CR><LF> (formatted like the D commands)
a<values><CRC><CR><LF> (formatted like the D
commands)

This command may result in a service request. See section 4.4.6.

Table 5. The SDI-12 basic command/response set
See Tables 12 and 13 for the high-volume commands (pages 24-25), Table 19 for the identify measurement
commands (page 29), and Table 20 for the identify measurement parameter commands (page 32).

2/20/2023 Version 1.4

8

The first character of all commands and responses is always a device address. The last
character of a command is the "!" character. The “!” can only be in a command as the command
terminator. The last two bytes of a response are a carriage return and line feed (<CR><LF>).
The maximum number of characters that can be returned in the <values> part of the
response to a D command is either 35 or 75. If the D command is issued to retrieve data in
response to a concurrent measurement command, or in response to a high-volume ASCII
measurement command, the maximum is 75. The maximum is also 75 in response to a
continuous measurement command. Otherwise, the maximum is 35.

4.4.1 Acknowledge Active Command (a!)
This command is used to ensure that a sensor is responding to a data recorder or another
SDI-12 device. It asks a sensor to acknowledge its presence on the SDI-12 bus. Table 6 shows
the acknowledge active command.
Command

Response

a!

a<CR><LF>

a - the sensor address

a - the sensor address

! - terminates the command

<CR><LF> - terminates the response

Table 6. The acknowledge active command (a!)

4.4.1.1 Examples of the Acknowledge Active Command (a!)
0!0<CR><LF>
1!1<CR><LF>

4.4.2 Send Identification Command (aI!)
This command is used to query sensors for their SDI-12 compatibility level, model
number, and firmware version number. Table 7 shows the send identification command.

2/20/2023 Version 1.4

9

Command

Response

aI!

allccccccccmmmmmmvvvxxx . . . xxx<CR><LF>

a - the sensor address

a - the sensor address

I – the send identification
command

ll - the SDI-12 version number, indicating SDI-12 version
compatibility; for example, version 1.4 is encoded as 14

! - terminates the command

cccccccc - an 8 character vendor identification, usually a company
name or its abbreviation
mmmmmm - 6 characters specifying the sensor model number
vvv - 3 characters specifying the sensor version
xxx . . . xx - an optional field, up to 13 characters, used for a serial
number or other specific sensor information that is not relevant for
operation of the data recorder
<CR><LF> - terminates the response

Table 7. The send identification command (aI!)
4.4.2.1 Example of the Send Identification Command (AI!)

4.4.3 Address Query Command (?!)
When a question mark (?) is used as the address character with the acknowledge active
command (a!), the sensor will respond as if it is being addressed on the SDI-12 bus. For
example, if a sensor detects ?!, it will respond with a<CR><LF>, no matter what its address may
be. This will allow a user to determine the address of a sensor. The user should understand that if
more than one sensor is connected to the bus, they will all respond, causing a bus contention. A
sensor is required to support the wild card address character (?) with the acknowledge active
command (?!). The sensor may also support the wild card address with all other commands; this
is not, however, a requirement.

2/20/2023 Version 1.4

10

4.4.4 Change Address Command (aAb!)
This command changes the address of a sensor. If the sensor supports software
changeable addresses, it must support the change address command. Table 8 shows this
command.
After this command has been issued and responded to, the sensor is not required to
respond to another command for one second. This gives the sensor time to write the new address
to non-volatile memory.
Command

Response

aAb!

b<CR><LF>

a - the sensor address

b - the address of the sensor (will equal the new address or
the original address if the sensor is unable to change the
address)

A - the change address command
b - the address to change to
! - terminates the command

<CR><LF> - terminates the response

Table 8. The change address command (aAb!)
4.4.5 Start Measurement Command (aM!)
This command tells the sensor to take a measurement. The sensor does not, however,
return the measurement to the data recorder after this command. It returns the time until one or
more measurements will be ready and the number of measurements that it will make. The send
data (D0!) command must be issued to get the measurement(s). Table 9 shows the start
measurement command.

Command

Response

aM!

atttn<CR><LF>

a - the sensor address

a - the sensor address

M - the start measurement

ttt - the specified time, in seconds, until the sensor will have the
measurement(s) ready

! - terminates the command

n - the number of measurement values the sensor will make and return
in one or more subsequent D commands; n is a single digit integer with
a valid range of 1 to 9

Table 9. The start measurement command (aM!)

2/20/2023 Version 1.4

11

If the sensor returns 000 (ttt), the measurement is immediately available for transfer to
the data recorder. The data recorder should issue the D0 command to get the data.
If ttt is not equal to zero (000), the data recorder must wait for the specified time to
elapse. The ttt time period begins upon completion of the transmission of the line feed character.
Then it wakes the sensor with a break and issues the D0 command. If, however, the sensor has
the measurement ready before ttt seconds elapse, it will send a service request to the recorder.
This tells the recorder to stop marking time and issue the D0 command.
When a data recorder issues an M command, it must complete the command/response
sequence with the sensor before it sends any command to any other sensor. For example,
suppose that following the issuance of the M command, the sensor responds
0M!00101<CR><LF>
This response shows that one data value will be ready in 10 seconds. The data recorder
must wait for either of two events to occur before issuing a D0 command:
1) receipt of a service request (a<CR><LF>) from the sensor
2) the specified time to elapse (10 seconds)
The recorder then issues the D0 command to get the data. After the M command and
before the sensor issues the service request, the data recorder will not communicate with any
other sensor. The sensor must not drive the data line until it sends a service request. The
recorder must not drive the data line while waiting for the service request.
A sensor should return a ttt value greater than the time it takes to make a measurement, to
allow for timing tolerances and for the service request. (See section 4.4.6.) The data recorder
may wait for the entire ttt time. Therefore, the tolerance above the measurement, added to ttt,
should be minimal.
After a sensor finishes its measurement procedure, the sensor must retain the measured
data in memory until it receives another M or V command, or another command that returns data
via the D0 command.
See the send data command, aD0!, aD1! . . . aD9!, for examples of this command.
Because the start measurement command is closely related to the send data command, examples
for both commands are shown on page 17.
4.4.5.1 Aborting a Measurement
If a sensor detects a break after it receives an M command, but before it issues a service
request, it must abort its measurement procedure. The sensor address, followed by <CR><LF>,
(or followed by <CRC><CR><LF> if a CRC was requested) should be returned in response to

2/20/2023 Version 1.4

12

subsequent D commands. This requirement provides a way for a data recorder to abort a
measurement so it can communicate with another sensor, or this sensor, on the SDI-12 bus.

4.4.6 Service Request (a<CR><LF>)
A service request is a response from a sensor. It is not a command. It is sent, after an M
command, to tell the data recorder that the sensor has finished its measurement(s) and the data
are ready. A service request is issued by the sensor after an M, MC, or V command, when it has
finished its measurement. The entire service request must be returned before ttt seconds (see
Start Measurement Command, page 11) have elapsed. The time (ttt) is the maximum time that a
sensor will take before it has data available.
If a data recorder does not detect a service request, the data recorder must wait for the
specified time (ttt), given in response to the M or V command, and then issue the D0 command
to get the data. The minimum time before a data recorder can issue the D0 command to get the
data, in this case, is ttt seconds.
A sensor is required to issue a service request if it indicates that it will take one second or
longer before data are ready, in response to an M or V command. If a sensor says it will take zero
seconds before the data are ready, then a sensor must not issue a service request.
4.4.7 Start Concurrent Measurement Command (aC!)
This command, introduced in Version 1.2 of the SDI-12 Specification, tells the sensor to
take a concurrent measurement. A concurrent measurement is one which occurs while other
SDI-12 sensors on the bus are also taking measurements. The sensor does not, however, return
the measurement to the data recorder after this command. It returns the time until all
measurements will be ready and the number of measurement that it will make. The send data
(D0!) command must be issued to collect the measurements(s). Table 10 shows the start
concurrent measurement command.
If the sensor returns 000 (ttt), the measurement is immediately available for transfer to
the data recorder. The data recorder should issue the D0 command to get the data.
If ttt is not equal to zero (000), the data recorder must wait for the specified time to elapse
before attempting to retrieve the data. The ttt time period begins upon completion of the
transmission of the line feed character. During this time the data recorder can collect data from
sensors at other addresses. Communicating with other sensors will not abort a concurrent
measurement. After the specified time has elapsed, the data recorder wakes the sensor with a
break and issues the D0 command. The sensor will not issue a service request when it has
completed the measurement. The sensor must not drive the data line from the time it
completes its atttnn<CR><LF> response until it starts responding to the D0 command.

2/20/2023 Version 1.4

13

Command

Response

aC!

atttnn<CR><LF>

a - the sensor address

a - the sensor address

C - the start concurrent
measurement command

ttt - the specified time, in seconds, until the sensor will have the
measurement(s) ready

! - terminates the command

nn - the number of measurement values the sensor will make and
return in response to one or more subsequent D commands

Table 10. The start concurrent measurement command (aC!)
The data recorder should document the number of data values it can store in response to a
C command.
After a sensor finishes its measurement procedure, the sensor must retain the measured
data in memory until it receives another C, M, or V command, or another command that returns
data via the D0 command.
See the send data command, aD0!, aD1! . . . aD9!, section 4.4.8, for the data response
requirements. Because the start concurrent measurement command is closely related to the send
data command, examples for both commands are in sections 4.4.8.3 and 4.4.8.4.
For a sensor or data logger to claim support of Version 1.2 or higher of the SDI-12
Specification, it must support this command. Claiming zero data values in response to this
command (i.e. a response of a00000<CR><LF>) is not a valid support of this command. The
command must initiate a true measurement cycle. Sensors or data recorders that conform to a
previous version of SDI-12 will most likely not support this command, and will therefore not
respond to this command.
4.4.7.1 Aborting a Concurrent Measurement
If a sensor receives a valid command addressed to it while it is in the process of a
concurrent measurement, it should abort the measurement procedure. The sensor address
followed by <CR><LF> (or <CRC><CR><LF> if a CRC was requested) should be returned in
response to subsequent D commands. This requirement provides a way for a data recorder to
abort a measurement.
4.4.8 Send Data Command (aD0!, aD1! . . . aD9!)
This command is used to get groups of data from the sensor. D0! is issued after an M, MC, C,
CC, V, or HA command. The sensor responds by sending the data. If the expected number of
measurements is not returned in response to a D0! command, the data recorder issuesD1!, D2!,
etc. until all measurement values are received. (The expected number of measurements is given
in the response to an M, C, or V command.) Table 11 shows the send data command.
2/20/2023 Version 1.4

14

Command

Response

aD0! (aD1! . . . aD9!)

a<values><CR><LF>
or
a<values><CRC><CR><LF>

a - the sensor address

a - the sensor address

D0 - the send data command, D1 . .
. D9 additional send data
commands

values (see below)

! - terminates the command

<CR><LF> - terminates the response
<values> - pd.d
p - the polarity sign (+ or -)
d - numeric digits before the decimal place
. - the decimal point (optional)
d - numeric digits after the decimal point
the maximum number of digits for a data
value is 7, even without a decimal point
the minimum number of digits for a data
value (excluding the decimal point) is 1
the maximum number of characters in a
data value is 9 (the (polarity sign + 7
digits + the decimal point))
<CRC> - 3 character CRC code, appended if data was
requested with the aMC!, aMC1! ... aMC9!, aCC!, or
aCC1! ... aCC9! commands (see section 4.4.12)

Table 11. The send data command (aD0!, aD1! . . . aD9!)
If the response to a D command is valid, but no data are returned, the sensor has aborted
the measurement. To obtain data the recorder must issue another M, C, or V command.
Notes: in response to certain commands, the data returned after a D command may have a
Cyclic Redundancy Check (CRC) appended to it. See section 4.4.12. The hig1h volume ASCII
command, HA, extends the range of the send data commands. See section 5.1.

2/20/2023 Version 1.4

15

The maximum number of characters that can be returned in the <values> part of the
response to a D command is either 35 or 75. If the D command is issued to retrieve data in
response to a concurrent command, or a high-volume ASCII command, the maximum is 75.
Otherwise, the maximum is 35.
4.4.8.1 Continuous Measurements (aR0! ... aR9!)
Sensors that are able to continuously monitor the phenomena to be measured, such as a
shaft encoder, do not require a start measurement command (M!, M1! . . . M9!). They can be
read directly with the R commands (R0! ... R9!). For example:
if (the sensor is operating in a continuous measurement mode) then
aR0! will get and return the current reading of the sensor

The response to R commands (R0! ... R9!) are formatted like the D commands (D0! ...
D9!). The main difference is that the R commands do not need to be preceded with an M
command, which tells the sensor to take a measurement. The maximum number of characters
that can be returned in the <values> part of the response to an R command is 75.
Each R command is an independent measurement. For example, R5 need not be preceded
by R0 ... R4.
If a sensor is unable to take a continuous measurement, then it must return its address
followed by a carriage return/line feed (a<CR><LF>) in response to an R command. If a CRC
was requested, then the <CR><LF> must be preceded by the CRC. For example:
0AP@<CR><LF>.
4.4.8.2 Example of the aR0! Command
One measurement is immediately available after the R0! command:
0R0!0+3.14<CR><LF>

4.4.8.3 Return of Multiple Measurements (Parameters) by a Sensor (D1! . . . D9!)
The commands D1 . . . D9 are used with sensors that return multiple measurements. The
purpose of the D commands is for the sensor to return as many measurements as possible in
response to each command. The limiting constraint is that the total number of characters that can
be returned in the <values> field (see section 4.4.8). If the total number of characters exceeds the
maximum length of the <values> field, the sensor fragments the response, sending the first group
of measurements in response to D0, the next group in response to D1, and so on. A group can
have one or more measurements; data collection always begins with the D0 command. See
section 4.4.8.4 for examples.
The sensor must never split individual data values, sending part of a value in response to
one D command, sending the rest of the characters, for that value, in response to the next D
command.
2/20/2023 Version 1.4

16

If possible, a sensor should return all measurements in response to the D0 command. This
is not, however, a requirement.
4.4.8.4 Examples of the Start Measurement Command (aM!) and the Send Data
Commands
a. One measurement is immediately available after the M command:
0M!00001<CR><LF>
0D0!0+3.14<CR><LF>

b. Three measurements will be ready 5 seconds after the M command, and the sensor issues a
service request. All 3 measurements are returned in response to the D0 command:
0M!00053<CR><LF>
0<CR><LF>
0D0!0+3.14+2.718+1.414<CR><LF>

c. Nine measurements will be ready 35 seconds after the M command, and the sensor issues a
service request. Because the number of characters in all 9 measurements exceeds the limit in the
<values> field, a D1 command must be issued to get the second group of measurements:
0M!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66<CR><LF>
0D1!0+7.77+8.88+9.99<CR><LF>

d. Two measurements will be available in 1 second, and the sensor does not issue a service
request. After 1 second, the data recorder sends a break to wake the sensor and issues the D0
command:
0M!00012<CR><LF>
0D0!0+3.14+2.718<CR><LF>
Note: this example shows the proper operation of the data recorder, but the sensor is out of
compliance because it did not issue a service request.

2/20/2023 Version 1.4

17

e. Three measurements will be ready 5 seconds after the M command, and the sensor issues a
service request. Upon receipt of the service request, the data recorder issues D0 to get the data.
However, only 1 measurement is returned. The data recorder then issues the D1 command to get
the next group of data. In response, the second measurement is returned. Then the recorder issues
D2 to get the next, and last, group of data. In the example, each group contains only one
measurement.
0M!00053<CR><LF>
0<CR><LF>
0D0!0+3.14<CR><LF>
0D1!0+2.718<CR><LF>
0D2!0+1.414<CR><LF>
Note: This is in compliance with the standard. As many measurements as possible, however,
should be returned in response to each D command.
4.4.8.5 Example of the Concurrent Measurement Command (aC!) and the Send Data
Command (aD0!)
Two sensors, one returning 12 readings after 45 seconds and the other returning 4
readings after 15 seconds. The measurements are taken concurrently. Fifteen seconds after
starting a measurement from sensor 1, the data recorder issues a break followed by the D0
command to sensor address 1. Forty-five seconds (or longer) after starting a measurement from
the sensor at address 0, the data recorder sends a break and a D0 command to sensor 0. Note that
since a concurrent measurement was requested of sensor 0, it is allowed to return up to 75
characters in its <values> field of the response. An M command only allows 35 characters in its
<values> field to ensure compatibility with data recorders prior to version 1.2.
0C!004512<CR><LF>
1C!101504<CR><LF>
1D0!1+1.23+2.34+345+4.4678<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12<CR><LF>

4.4.9 Additional Measurement Commands (aM1! . . . aM9!)
Additional M commands provide a means to request different types of measurements
from a sensor or to instruct a sensor to do a calibration or a control function. For example, a
sensor could measure pressure and temperature: M tells it to measure pressure and M1 tells it to
measure the temperature.
Additional M commands have the same format as the aM! command. Data collection
always begins with the D0 command. If the sensor does not return the expected number of
measurements in response to the D0 command, the recorder should issue aD1, aD2, etc. until the
sensor returns all measurements.
To comply with Version 1.2 or higher of SDI-12, sensors must respond to the additional
measurement commands (aM1! . . . aM9!) and data recorders must be able to log data from the

2/20/2023 Version 1.4

18

additional measurement commands. If a sensor has no data defined for an additional
measurement command, it should return a0000<CR><LF>, saying that it has zero data values
ready. Not responding to the command is not acceptable.
4.4.9.1 Examples of the Additional M Commands (aMn!)
a. A sensor supports the aM1! command:
0M1!00011<CR><LF>
0<CR><LF>
0D0!0+3.14<CR><LF>
b. A sensor takes 9 measurements in response to the M2 command:
0M2!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66<CR><LF>
0D1!0+7.77+8.88+9.99<CR><LF>
4.4.10 Additional Concurrent Measurement Commands (aC1! . . . aC9!)
Additional C commands provide a means to request different types of measurements
from a sensor or to instruct a sensor to do a calibration or a control function. To comply with
Version 1.2 or higher of SDI-12, sensors must respond to the additional concurrent measurement
commands and data recorders must be able to log data from the additional concurrent
measurement commands. If a sensor has no parameters defined for an additional concurrent
measurement command, then it should return a00000<CR><LF>, saying that it has zero data
values ready. Not responding to the command is not acceptable.
Additional C commands have the same format and constraints as the aC! command. Data
collection always begins with the D0 command. If the sensor does not return the expected
number of measurements in response to the D0 command, the recorder should issue aD1, aD2,
etc., until the sensor returns all measurements.
4.4.11 Start Verification (aV!)
This command tells the sensor to return a verification in response to a subsequent D
command. A verification sequence may include ROM signatures, CRC's, RAM test results, or
the results of other diagnostics in the sensor. A standard response to the V command is not
specified.
The format of this command is the same as the M commands. The format of the response
is the same as the D commands.

2/20/2023 Version 1.4

19

4.4.11.1 Example of the Start Verification Command (aV!)
0V!00011<CR><LF>
0<CR><LF>
0D0!0+1<CR><LF>

4.4.12 Requesting a Cyclic Redundancy Check (CRC)
To enhance the error detection capability in SDI-12 data collection systems, a variation of
the Start Measurement Commands (M!, M1! ... M9!), Start Concurrent Measurement Commands
(C!, C1! ... C9!), and Continuous Measurement Commands (aR0! ... aR9!) request that the data
be returned with a 16 bit Cyclic Redundancy Check (CRC) appended to it. These commands
use the existing command letters with a C appended, namely: aMC!, aMC1! ... aMC9!, aCC!,
aCC1! ... aCC9!, and aRC0! ... aRC9!. When these commands are used, the data returned in
response to the D commands, or R commands, must have a CRC code appended to it.
The number of measurements returned in response to a CRC command should be the
same as the measurement that was made in response to a non-CRC command. In other words, the
CRC command causes the same measurements to be taken as the non-CRC command.
To be version 1.3 (or higher) compliant, the sensor must support CRCs.
4.4.12.1 CRC-16 Computation
The computation of the CRC is performed on the data response before parity is added.
All operations are assumed to be on 16 bit unsigned integers. The least significant bit is on the
right. Numbers preceded by 0x are in hexadecimal. All shifts shift in a zero. The algorithm is:
Initialize the CRC to zero. For each character beginning with the address, up to but not including, the carriage return
(<CR>).
{
Set the CRC equal to the exclusive OR of the character and itself
for count = 1 to 8
{
if the least significant bit of the CRC is one
{
right shift the CRC one bit
set CRC equal to the exclusive OR of 0xA001 and itself
}
else
{
right shift the CRC one bit
}
}
}

2/20/2023 Version 1.4

20

4.4.12.2 Encoding the CRC as ASCII Characters
The 16 bit CRC is encoded as three ASCII characters using the following algorithm:
1st character = 0x40 OR (CRC shifted right 12 bits)
2nd character = 0x40 OR ((CRC shifted right 6 bits) AND 0x3F)
3rd character = 0x40 OR (CRC AND 0x3F)

The three ASCII characters are placed after the data before the <CR><LF>. Parity is
applied to all three characters when they are transmitted. The AND and OR operators are bitwise
operators, not logical operators.
4.4.12.3 Examples of the CRC-16 Start Measurement Command (aMC!) and the Send Data
Command (aD0!)
a. One measurement is immediately available after the MC command:
0MC!00001<CR><LF>
0D0!0+3.14OqZ<CR><LF>
b. Three measurements will be ready 5 seconds after the MC command, and the sensor issues a
service request. All 3 measurements are returned in response to the D0 command:
0MC!00053<CR><LF>
0<CR><LF>
0D0!0+3.14+2.718+1.414Ipz<CR><LF>
c. Nine measurements will be ready 35 seconds after the MC command, and the sensor issues a
service request. Because the number of characters in all 9 measurements exceeds the limit for the
<values> field, a D1 command must be issued to get the second group of measurements:
0MC!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66I]q<CR><LF>
0D1!0+7.77+8.88+9.99IvW<CR><LF>
d. Two measurements will be available in one second, and the sensor does not issue a service
request. After one second, the data recorder sends a break to wake the sensor and issues the D0
command:
0MC!00012<CR><LF>
0D0!0+3.14+2.718IWO<CR><LF>
Note: this example shows the proper operation of the data recorder, but the sensor is out of
compliance because it did not issue a service request.
e. Three measurements will be ready five seconds after the MC command, and the sensor issues

2/20/2023 Version 1.4

21

a service request. Upon receipt of the service request, the data recorder issues D0 to get the data.
Only one measurement, however, is returned. The data recorder then issues the D1 command to
get the next group of data. In response, the second measurement is returned. Then the recorder
issues D2 to get the next, and last, group of data. In this example, each group contains only one
measurement.
0MC!00053<CR><LF>
0<CR><LF>
0D0!0+3.14OqZ<CR><LF>
0D1!0+2.718Gbc<CR><LF>
0D2!0+1.414GtW<CR><LF>
Note: this is in compliance with the standard. As many measurements as possible, however,
should be returned in response to each D command.
f. Two sensors, one returning 12 readings after 45 seconds and the other returning 4 readings
after 15 seconds. The measurements are taken concurrently. Fifteen seconds after starting a
measurement from sensor 1, the data recorder issues a break followed by the D0 command to
sensor address one. Forty-five seconds (or longer) after starting a measurement from the sensor
at address 0, the data recorder sends a break and a D0 command to sensor 0. Since a concurrent
measurement was requested of sensor 0, it is allowed to return up to 75 characters in the
<values> field of its response:
0CC!004512<CR><LF>
1CC!101504<CR><LF>
1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12
Ba]<CR><LF>
4.4.13 Extended Commands
Sensors are required only to respond to the basic SDI-12 command set. Sensors,
however, usually require calibration or other setup commands. Extended commands provide the
means for such functions. An extended command is a command for a specific make of sensor to
tell that sensor to do a specific task. Extended commands are defined and documented by the
manufacturer of each sensor.
Extended commands have the following attributes:
• an extended command must be prefixed with an address
• an extended command must be terminated with an exclamation point
• the response must be prefixed with an address
• the response must be terminated with <CR><LF>
• the transparent mode must support basic SDI-12 commands and extended
commands

2/20/2023 Version 1.4

22

Extended commands should be prefixed with an upper case X, for example, aXNNN!,
where X says that an extended command follows and NNN is the extended command. NNN is
not limited to three characters. Prefixing extended commands with an upper case X is a
recommendation only and is not a requirement. Future versions of SDI-12, however, may
require this.
4.4.13.1 Extended Commands Returning Multiple Lines of Text
Many SDI-12 sensors have sufficient memory to store and return multiple lines of text to
a data recorder, such as returning detailed documentation about the sensor. To support this, an
extended command may return multiple lines of text, with each line of text terminated with a
carriage return/line feed pair (<CR><LF>).
The transmission of each text line must conform with the same timing requirements for
all SDI-12 sensor responses.
When multiple lines of text are going to be returned, the sensor must indicate that two or
more lines of text will be returned in response to the extended command by placing the ASCII
character “start of text” (STX, decimal value 2) after the address character, in the first line of text
returned to the data recorder.
The sensor must indicate the last line of text with the ASCII character “end of text,”
(ETX, decimal value 3) after the <CR><LF> pair in the final line of text.
The maximum number of ASCII characters allowed in each line of text, exclusive of the
SDI-12 address, <STX>, <CR>, <LF>. and <ETX> characters, is 75.
ASCII CRC error detection characters are not appended to the lines of text.
The time between the transmission of each line of text must be less than or equal to 150
milliseconds. If the start bit of the first character in the next expected line of text is not received
in 150 milliseconds, then the data recorder should conclude that no more lines of text are
forthcoming.
Here is an example:
0XHELP!0<STX>This is the first line of text.<CR><LF>
This is the second line of text.<CR><LF>
This is the third and final line of text.<CR><LF> <ETX>

Sensor and data logger support for returning and receiving multiple lines of text is not an
SDI-12 requirement.

2/20/2023 Version 1.4

23

4.4.14 Transparent Mode
SDI-12 data recorders must have a mode in which extended commands can be sent to
sensors. This is called the transparent mode. The transparent mode has the following
characteristics.
• The data recorder buffers a command string received from a computer, terminal, or
modem, until the command string is terminated.
• The data recorder wakes the sensor with a break, then it sends the buffered command
to the sensor, using the SDI-12 protocol.
• The data recorder receives the response from the sensor and transmits the response to
the computer, the terminal, or the modem.

5.0 HIGH-VOLUME COMMANDS
The high-volume commands, introduced in version 1.4 of the SDI-12 Specification,
expand the concurrent measurement commands to allow up to 999 parameters to be returned
from a sensor.
5.1 Start High-Volume ASCII Measurement
Table 12 shows the high-volume ASCII measurement command.
Command Name

Command

Response

High-Volume ASCII

aHA!

atttnnn<CR><LF>

Table 12. High-Volume ASCII measurement
The commands to get high-volume data after the aHA! command are: aD0! … aD999!
If after obtaining the data values from aD9! there are still more data values to obtain,
continue to send data requests with aD10!...aD99! as needed. If after obtaining the data values
from aD99! there are still more data values to obtain, continue to the send data requests with
aD100!...aD999! as needed. Leading zeros are not placed after the “D”
The responses to the send data commands follow the same rules as with the Concurrent
Measurement send data commands. The maximum number of characters that can be returned in
the <values> part of the response is 75 and a three character <CRC> is appended to the data
before the <CR><LF>. The CRC must be present.

2/20/2023 Version 1.4

24

5.1.1 Example of High-Volume ASCII Measurement
In this example there are two sensors, one returning 12 data values after 45 seconds and
the other returning 4 data values after 15 seconds. The first measurement uses the high-volume
ASCII command; the second one uses the concurrent command with a CRC. Fifteen seconds
after requesting data from sensor one, the data recorder issues a break followed by the D0
command to sensor address 1. Forty-five seconds (or longer) after starting the measurement from
the sensor at address 0, the data recorder sends a break and a D0 command to sensor 0. Since a
high-volume ASCII measurement was requested of sensor 0, it is allowed to return up to 75
characters in the <values> field of its response, and it does not abort when sensor 1 is addressed:
0HA!0045012<CR><LF>
1CC!101504<CR><LF
1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12Ba]<CR><LF>

5.2 Start High-Volume Binary Measurement
The high-volume binary measurement allows for collection of large volumes of data from
a sensor more efficiently than the ASCII transfer methods.
Command Name

Command

Response

High-Volume Binary

aHB!

atttnnn<CR><LF>

Table 13. High-Volume binary measurement
The commands to get high-volume binary data after the aHB! command are: aDB0! …
aDB999!
If after obtaining the data values from aDB9! there are still more data values to obtain,
continue the send data requests with aDB10!...aDB99! as needed. If after obtaining the data
values from aDB99! there are still more data values to obtain, continue the send data requests
with aDB100!...aDB999! as needed.
Responses to the aDB0! … aDB999! commands are an exception to section 4.1 Table 2
because the byte frame format is 8 data bits, no parity bit. The SDI-12 address is
transmitted as the ASCII character, but no parity bit. The remaining fields are encoded as
binary numbers. The least significant byte is transferred first for multi-byte binary
numbers.

2/20/2023 Version 1.4

25

SDI-12
Address

ASCII

Packet Size

Data Type

16 bit unsigned integer, indicates
the size, in bytes, of the binary
data payload

8 bit unsigned
integer, indicates
the data type in
the binary data
payload

Binary Data
Payload

must be <= 1,000
bytes

CRC
16 bit CRC value, using
the same algorithm as the
other measurement
commands that request a
CRC, but encoded in
binary (not converted to
3 byte ASCII)

Table 14. Data packet
If the value of n in aDBn! is invalid due to being higher than necessary to return data values, then
the data package must be:
SDI-12
Address

Packet Size

Data Type

Binary Data
Payload

CRC

address

0

0

nil

16 bit CRC

Table 15. Empty data packet
All data values in a particular response must be of the same type, but data types can differ
between aDBn! commands.
Nil, as shown in Table 15, means that the binary data payload is empty: there are zero data
bytes in it. An empty data packet, therefore, has six bytes only:
1 byte:
2 bytes:
1 byte:
2 bytes:

the address;
the packet size (zero);
the data type (zero);
the CRC value.

2/20/2023 Version 1.4

26

5.2.1 High-Volume Binary Data Types
Table 16 shows the high-volume binary data types.
Data
Type

Range

Size

0

Indicates an invalid request

No data returned

1

-128 to 127

Signed 8-bit integer

2

0 to 255

Unsigned 8-bit integer

3

-32,768 to 32,767

Signed 16-bit integer

4

0 to 65,535

Unsigned 16-bit integer

5

-2,147,483,648 to 2,147,483,647

Signed 32-bit integer

6

0 to 4,294,967,295

Unsigned 32-bit integer

7

-9,223,372,036,854,775,808 to
9,223,372,036,854,775,807

Signed 64-bit integer

8

0 to 18,446,744,073,709,551,615

Unsigned 64-bit integer

9

±1.18×10−38 to ±3.4×1038

IEEE 32-bit floating point single
precision/binary32

10

±2.23×10−308 to ±1.80×10308

IEEE-64 bit floating point double
precision/binary64

Table 16. Data types

2/20/2023 Version 1.4

27

5.2.2 Example of High-Volume Binary Command
In this example a data recorder transmits a high-volume binary command and the sensor
responds, indicating that four data values will be available after five seconds:
1HB!1005004<CR><LF>
Table 17 shows the data values, returned in binary data packets, that are used in this
example. Two of the four data values are returned in a data packet as signed 16-bit integers; the
other two data values are returned in a data packet as 32-bit single precision floating point
numbers.
Data Type

Size

Data Value

Data Value in Hexadecimal

3

Signed 16-bit integer

-1

0xFFFF

3

Signed 16-bit integer

1

0x0001

9

IEEE-32 bit floating point

3.14

0x4048F5C3

9

IEEE-32 bit floating point

1.0

0x3F800000

Table 17. Data values in the high-volume binary command example
Table 18 shows each data packet returned in response to the commands 1DB0!,1DB1!,
and 1DB2! as a string of bytes, shown in hexadecimal.
The commands, 1DB0!, 1DB1!, and 1DB2 are transmitted to the sensor as 7 bit ASCII
characters with even parity. The SDI-12 address, 0x31 in this example, is returned as an 8 bit
ASCII character, without a parity bit.
Table 18 also shows that it was unnecessary to transmit the command 1DB2!, because all
four data values were already received. Therefore, the sensor returned an empty data packet.
Command

Data Packet

1DB0!

0x31 0x04 0x00 0x03 0xFF 0xFF 0x01 0x00 0xC2 0xAC

1DB1!

0x31 0x08 0x00 0x09 0xC3 0xF5 0x48 0x40 0x00 0x00 0x80 0x3F 0x3B 0x6E

1DB2!

0x31 0x00 0x00 0x00 0x0E 0xFC
Table 18. Data packet examples

2/20/2023 Version 1.4

28

5.3 Concurrency of High-Volume Commands
The high-volume commands are concurrent commands, as described in section 4.4.7,
with section 4.4.7.1 explaining how to abort a concurrent measurement command.
5.4 Compliance with High-Volume Commands
To claim compliance with version 1.4, SDI-12 data recorders must support the
high-volume commands.
No requirement is imposed on SDI-12 sensors to support the high-volume commands.
The functionality of an SDI-12 sensor dictates the need to support the high-volume commands,
because there is no advantage in collecting a low number of parameters from a sensor with a
high-volume command.
Version 1.4 sensors that do not support the high-volume ASCII command, or the
high-volume binary command, should respond with a000000<CR><LF> saying that it has zero
data values ready.
6.0 METADATA COMMANDS
The metadata commands, introduced in version 1.4 of the SDI-12 Specification, provide
a means to get the response to a command without actually initiating a measurement.
6.1 Identify Measurement Commands
The identify measurement commands are formed by placing the capital letter I into the
measurement commands immediately after the address. The response is identical to having
issued the command without the capital letter I following the address. The format is
atttn<CR><LF>, atttnn<CR><LF>, or atttnnn<CR><LF> depending on the measurement
command.
The continuous measurement commands (aR0! … aR9! And aRC0! … aRC9!) provide their data
instantly and therefore do not have an identify measurement command.
Command

Response

aIM!

atttn<CR><LF>

aIMC!

atttn<CR><LF>

aIM1!
.
.
.
aIM9!

atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aIMC1!

atttn<CR><LF>

2/20/2023 Version 1.4

29

Command

Response

.
.
.
aIMC9!

atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aIV!

atttn<CR><LF>

aIC!

atttnn<CR><LF>

aICC!

atttnn<CR><LF>

aIC1!
.
.
.
aIC9!

atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>

aICC1!
.
.
.
aICC9!

atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>

aIHA!

atttnnn<CR><LF>

aIHB!

atttnnn<CR><LF>

Table 19. The identify measurement commands
6.1.1 Examples of the Identify Measurement Commands
a. One data value will be immediately available after the M command:
8IM!80001<CR><LF>
b. Nine data values will be available 10 seconds after the M command:
8IM!80109<CR><LF>
c. Ninety-nine data values will be available 10 seconds after the C5 command:
8IC5!801099<CR><LF>
6.2 Identify Measurement Parameter Commands
The identify measurement parameter commands provide details about the parameters
returned by a particular command. The form of the command is an expansion of the Identify

2/20/2023 Version 1.4

30

Measurement Commands. An underscore character ("_") plus a three-digit decimal number is
placed immediately before the exclamation point ("!"). The decimal number is the data value of
interest.
The response is a comma separated value (CSV) string with several fields that provide
information about the data value of interest. Two fields are required. Additional fields can be
added by the sensor manufacturer. Fields are expected to contain printable ASCII characters
other than the comma character (“,”) or the semicolon character (“;”) since they are used to
delimit fields.
6.2.1 Field One
The first field contains a concise identification of the parameter, which is the data value
of interest. The recommendation is to use a Standard Hydrometeorological Exchange Format
(SHEF) code.
SHEF codes are published by the National Oceanic and Atmospheric Administration
(NOAA), National Weather Service in the “Standard Hydrometeorological Exchange Format
(SHEF) Code Manual.” This document is available on the Internet at:
http://www.nws.noaa.gov/oh/hrl/shef/indexshef.htm
The SHEF codes are listed in “Appendix G, Physical Element Definitions,” in the NOAA
document.
If an appropriate SHEF code does not exist for the parameter, or if the sensor
manufacturer chooses not to use a SHEF code for the parameter, then field one may contain a
concise identification of the parameter as determined by the sensor manufacturer. The
recommendation, however, is to use a SHEF code when an appropriate SHEF code does exist.
6.2.2 Field Two
Field two contains the units for the parameter. If the parameter is unit-less, the field must
still be present. A single space character is recommended for an empty field to make it easier to
read.
6.2.3 Optional Fields
The sensor manufacturer may provide additional information relevant to the parameter by
adding additional fields. This may be a more descriptive name than found in field one. For
example, it may contain calibration data or dates. If the parameter represents a probe that has a
unique serial number, there may be a field that contains that serial number. The only limit on the
number of additional fields is that the maximum length of the response, through the terminating
semicolon, is 75 characters.
The last field is terminated by a semicolon “;” and then followed by either the
<CR><LF> sequence or a three character CRC followed by the <CR><LF> sequence if the
measurement command was one that returns a CRC.
2/20/2023 Version 1.4

31

If the parameter number, nnn, is invalid for the measurement, then the response shall be:
a<CR><LF> or a<CRC><CR><LF> if a CRC was expected.
To poll the Continuous Measurement commands (aR0! … aR9! and aRC0! … aRC9!) to
identify their measurement parameters, increment sequentially through the parameters until the
response indicates the parameter number, nnn, is invalid for the measurement.
Command

Response

aIM_001!
.
.
.
aIM_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIMC_001!
.
.
.
aIMC_009!

a,field1,field2;<CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIM1_001! … aIM1_009!
.
.
.
aIM9_001! … aIM9_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIMC1_001! … aIMC1_009!
.
.
.
aIMC9_001! … aIMC9_009!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIV_001! … aIV_009!

a,field1,field2;<CR><LF>

aIC_001! … aIC_099!

a,field1,field2;<CR><LF>

aICC_001! … aICC_099!

a,field1,field2; <CRC><CR><LF>

aIC1_001 … aIC1_009!
.
.
.
aIC9_001 … aIC9_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aICC1_001! … aICC1_099!
.
.

a,field1,field2;< CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

2/20/2023 Version 1.4

32

Command

Response

.
aICC9_001! … aICC9_099!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIR0_001! … aIR0_099!
.
.
.
aIR9_001! … aIR9_099!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIRC0_001! … aIRC0_099!
.
.
.
aIRC9_001! … aIRC9_099!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIHA_001! … aIHA_999!

a,field1,field2; <CRC><CR><LF>

aIHB_001! … aIHB_999!

a,field1,field2; <CRC><CR><LF>

Table 20. The identify measurement parameter commands
6.2.4 Examples of the Identify Measurement Parameter Commands
a. Generic example:
0IM!0001!<CR><LF>
0IM_001!0,field1,field2,field3;<CR><LF>
b. Metadata for an M command, showing that the M command takes a precipitation
measurement, using optional field 3 to describe the data value:
0IM!00001<CR><LF>
0IM_001!0,PR,mm,precipitation rate per day;<CR><LF>
c. Metadata CC command, showing that the CC command takes an average air temperature
measurement, using additional/optional fields to provide additional metadata, with a CRC
appended to the response:
0ICC!000502<CR><LF>
0ICC_001!0,CU,degrees C,average air temperature,calibration data,40,1235;@|e<CR><LF>
6.3 Compliance with Metadata Commands
To claim compliance with version 1.4, an SDI-12 sensor must support the metadata
commands. Because there is no requirement for an SDI-12 data recorder to manage or store the
metadata, the transparent mode (section 4.4.13.1) on the data recorder is sufficient support for
these commands. Explicit data recorder support for these commands is not otherwise required.
2/20/2023 Version 1.4

33

7.0 SDI-12 TIMING
Figure 3 shows a timing diagram for an SDI-12 command and its response. The tolerance for all
SDI-12 timing is ± 0.40 milliseconds. The only exception to this is the time between the stop bit
of one character and the start bit of the next character. The maximum time for this is 1.66
milliseconds, with no tolerance.

• A data recorder transmits a break by setting the data line to spacing for at least 12
milliseconds.
• The sensor will not recognize a break condition for a continuous spacing time of less
than 6.5 milliseconds and will always recognize a break when the line is continuously
spacing for more than 12 milliseconds.
• Upon receiving a break, a sensor must detect 8.33 milliseconds of marking on the data
line before it looks for an address.

2/20/2023 Version 1.4

34

• A sensor must wake up from a low-power standby mode and be capable of detecting a
start bit from a valid command within 100 milliseconds after detecting a break.
• After a data recorder transmits the last character of a command, it must relinquish
control of the data line within 7.5 milliseconds following the end of the stop bit.
(Tolerance: +0.40 milliseconds.)
• After receiving the break and the command, the addressed sensor sets the data line to
marking for 8.33 milliseconds and then send the response. (Tolerance: -0.40
milliseconds.) The start bit of the first response byte must start within 15 milliseconds
after the stop bit of the last byte of the command. (Tolerance: +0.40 milliseconds.
• After a sensor transmits the last character of a response, it must relinquish control of
the data line within 7.5 milliseconds. (Tolerance: +0.40 milliseconds.)
• No more than 1.66 milliseconds of marking are allowed between the end of the stop bit
and the start bit (e.g., between characters) on any characters in the command or the
response. (No tolerance.) This permits a response to an M command to be sent within a
380 millisecond window.
• Sensors must return to a low-power standby mode after receiving an invalid address or
after detecting a marking state on the data line for 100 milliseconds. (Tolerance: +0.40
milliseconds.)
• When a recorder addresses a different sensor, or if the data line has been in the
marking state for more than 87 milliseconds, the next command must be preceded by a
break.
Note: The low power standby mode, in addition to being a power consumption state, is a
protocol state and a break is required to leave that state.
7.1 Rules for the Break
The data recorder sends a break when it is necessary to wake a sensor from low-power
standby mode. An SDI-12 sensor is required to return to low-power standby mode after
receiving an invalid address or after detecting a marking state on the data line for 100
milliseconds. For this reason, a break must precede a command whenever a new sensor is
addressed and after 87 milliseconds of marking on the data line.
When a data recorder receives a service request, it does not have to send a break if it
issues the D0 command within 87 milliseconds after the service request. If, however, more than
87 milliseconds elapse, the D0 command must be preceded with a break.

2/20/2023 Version 1.4

35

7.2 Retries
A data recorder must support retries. Sensors have up to 100 milliseconds to wake up
after detecting a break and will not respond to any commands until they have awakened. Also,
sensors will go to sleep after detecting 100 milliseconds of idle time (marking) on the SDI-12
bus.
When issuing retries, if no response is received from a sensor, the recorder must wait for
at least 16.67 milliseconds after the last stop bit of the command, but no longer than 87
milliseconds, and then issue a retry (without a break). (This period of 87 milliseconds includes
the 16.67 milliseconds spent waiting for a response from the sensor.) If a correct response is not
received after re-transmitting the command at least two more times, with at least one of those
retries more than 100 milliseconds after the end of the break, the entire sequence (including
the break and the retries) should be repeated at least two more times. The flow chart in appendix
B of this document illustrates this retry logic. At least one of the retries must be issued after 100
milliseconds after the falling edge of the break to ensure that the sensor has been given the full
100 milliseconds to wake up after the break. A retry is needed if one of the following three
conditions exist:
1) no response from the sensor;
2) 8.33 milliseconds of marking on the data line, after receiving the start bit of the
response;
3) an invalid response.
Invalid responses include responses in an incorrect format, parity errors, framing errors,
CRC errors, or bus contentions. The data recorder must wait for the response to complete before
sending a retry. If one of the above conditions exists, the data recorder will issue retries. Under
extraordinary conditions, not as normal operating procedure, the data recorder has the option of
not issuing retries.

2/20/2023 Version 1.4

36

APPENDICES

2/20/2023 Version 1.4

37

Appendix A
Suggested SDI-12 Circuits

s
e
ns
orordat
ar
e
c
or
de
r
i
nt
e
r
f
ac
ec
i
r
c
ui
t
wi
t
h
t
r
ans
i
e
ntpr
ot
e
c
t
i
on

2/20/2023

Version 1.4

Appendix B
Suggested SDI-12 Flow Control
for
SDI-12 Data Recorders and Sensors

2/20/2023 Version 1.4

B-1

start

SDI-12 Sensor
Flow Chart

!

!

2/20/2023 Version 1.4

Page B-2

Appendix C
SDI-12 Glossary

2/20/2023 Version 1.4

B-3

Appendix C: SDI-12 Glossary

Address. A single character used to identify each sensor on the SDI-12 bus. The first character
of every command and the first character of every response is an address. The normal address
characters are "0" to "9."
Basic command set. The following SDI-12 commands: a!, aAb!, ?!, aI!, aM!, aM1! . . . aM9!,
aC!, aC1! . . . aC9!, aD0! . . . aD9!, aR0! . . . aR9!, aV!, aMC!, aMC1! . . . aMC9!, aCC!, aCC1!
.. . .aCC9!, aRC0! . . . aRC9!
Break. Continuous spacing, by the data recorder, on the data line for at least 12 milliseconds.
This is a special condition used to wake sensors from a low power standby mode.
Buffer. Memory in the sensor that holds the sensor's most recent measurement. A sensor is
required to keep this information until it receives a new M or V command. When a sensor has a
measurement in its buffer, repeated D commands cause it to return the same data each time the D
command is issued. If, however, a break occurs while a sensor is making a measurement in
response to an M or V command, the sensor must abort its measurement and empty its data
buffer. In this case, no data is returned in response to a D command.
Byte frame format. The manner in which a character is encoded for serial transmission. SDI-12
uses 1 start bit, 7 data bits, even parity, and 1 stop bit.
CRC. Cyclical redundancy check, a form of error checking. The sensor appends a number,
which is encoded as ASCII characters, that is related mathematically to the characters to be
transmitted to the data recorder. Upon receiving the data, the data recorder recomputed the CRC
value to verify that the data was received without error.
Data bits. The bits in a character that carry information, as opposed to the start bit, the parity bit,
and the stop bit. SDI-12 uses 7 data bits.
Extended command. A command not in the basic SDI-12 command set. Extended commands
are defined by the manufacturer of the sensor. Extended commands calibrate sensors, run
diagnostic tests in sensors, and perform other tasks specific to a sensor.
Even parity. Setting the parity bit to 0 or 1, as needed, to ensure that the total number of binary
ones in the data bits and the parity bit are an even number. SDI-12 uses even, as opposed to odd,
parity.
Marking. A binary state of 1 on the SDI-12 data line, with a voltage range of -0.5 to 1.0 volts.
Parity bit. A bit after the data bits in a character, used for error detection. SDI-12 uses even
parity.

2/20/2022 Version 1.4

C-1

Printable characters. ASCII characters in the range 20 hex (a space) through 7E hex (~).
SDI-12 command. A string with 2 or more printable characters that will be sent to an SDI-12
sensor. The first character of an SDI-12 command is an address and the last character is an
exclamation point (!).
SDI-12 bus. A cable with three conductors: (1) serial data, (2) ground, and (3) 12 volts--used to
connect an SDI-12 data recorder with one to ten SDI-12 sensors.
SDI-12 data recorder. A data acquisition device that can be interfaced with one or more SDI-12
sensors. The recorder polls the sensor using the SDI-12 electrical interface and the SDI-12
communications protocol.
SDI-12 response. A string with 3 or more characters, returned to an SDI-12 data recorder by an
SDI-12 sensor. The first character of an SDI-12 response is an address and the last two
characters are a carriage return/line feed (<CR><LF>). Other than the carriage return/line feed,
all characters must be printable ASCII characters.
SDI-12 sensor. A measurement device that can be polled by an SDI-12 data recorder, using the
SDI-12 electrical interface and the SDI-12 communications protocol.
Service request. An address followed by carriage return/line feed (a<CR><LF). This is issued
by a sensor, after an M or V command, to tell the data recorder that the requested measurements
are ready.
Spacing. A binary state of 0 on the SDI-12 data line, with a voltage range of 3.5 to 5.5 volts.
Start bit. A bit indicating the start of a new character in an SDI-12 command or response.
Stop bit. A bit indicating the end of a character in an SDI-12 command or response. SDI-12
specifies one stop bit.
Transparent mode. A mode in an SDI-12 data recorder in which extended commands (or basic
commands), received from a computer, a terminal, or a modem can be sent to a sensor. In
transparent mode the data recorder buffers characters until terminated, wakes the sensor with a
break, and sends the command string to the sensor. An example of transparent mode is a data
recorder interfaced to a PC via a serial port. The user enters SDI-12 commands on the keyboard,
and the command is transmitted to the data recorder. The recorder reads the command, transmits
it to the sensor, and returns the response to the PC. The PC then displays the response.

2/20/2022 Version 1.4

C-2

<values> A string of one or more data values (e.g. measurements) returned from a sensor in
response to a D or an R command; each data value is in this format:
pd.d
where:
p - the polarity sign (+ or -) (required)
d - numeric digits before the decimal point
. - the decimal point (optional)
d - numeric digits after the decimal point
the maximum number of digits for a data value is 7, even without a decimal point
the minimum number of digits for a data value (excluding the decimal point) is 1
the maximum number of characters in a data value is 9 (polarity sign + 7 digits +
the decimal point)

2/20/2022 Version 1.4

C-3

Appendix D
Revisions

Appendix D: Revisions
Version 1.4 February 20, 2023
Added section 4.4.13.1, Extended Commands Returning Multiple Lines of Text.
Changed all instances of “high volume” to “high-volume.”
SDI-12 remains at Version 1.4 because the specification was not changed.
Version 1.4 January 30, 2021
Added two clarifications without changing the specification.
Paragraph 7.2, Retries, was modified by deleting two sentences and removing the word
master from this document. The use of the word master, and the two deleted sentences are
unneeded in describing retries. The word master was removed to join others in the digital design,
software, and information technology industries, eliminating the words master, slave, or both.
Modified the sensor flow chart in Appendix B-2, by making it clear what a sensor is
expected to do when it receives another command while in the processing of a concurrent
measurement. This was done by adding the decision, D command and processing done, when
executing the logic to manage a C command. Also added a title to the sensor flow chart.
Version 1.4 January 10, 2018
No changes or clarifications made to the specification. Added a sentence to Table 5, The
SDI-12 basic command/response set, on page 8: “See Tables 12 and 13 for the high-volume
commands (pages 24-25), Table 19 for the identify measurement commands (page 29), and
Table 20 for the identify measurement parameter commands (page 32),” so that references to all
SDI-12 commands are included on page 8.
Version 1.4 December 1, 2017
No changes or clarifications made to the specification. Made internal formatting changes
only, adding bookmarks for Portable Document File (PDF) readers to quickly see and go to
specific sections.
Version 1.4 May 1, 2017
Clarifications only made to the specification:
1) Page 10, Table 7, the send identification command, had numerous typographic errors
and omissions, introduced when this document was upgraded from version 1.3 to version 1.4.
Restored the content in the table to its original condition, correcting the errors.

2/20/2023 Version 1.4

D-1

2) Page 32, Section 6.2.4, examples of the identify measurement parameter commands:
example (a) and example (c) were missing the letter “I” in the command. Added the letter “I”.
3) Pages 31 and 32, Table 20, the identify measurement parameter commands, column
two was missing <CRC> for the measurement commands that return a CRC. It said:
a,field1,field2;<CR><LF>
rather than:
a,field1,field2;<CRC><CR><LF>
Added <CRC> for all of the measurement commands that return a CRC.
4) Page 28, Section 5.4, Compliance with High-Volume Command, omitted stating what
the required response is, to the aHA! and aHB! commands, for sensors that do not support the
high-volume commands. Added the following paragraph to correct this omission, as the same
requirement is imposed on the other measurement commands.
“Version 1.4 sensors that do not support the high-volume ASCII command, or the
high-volume binary command, should respond with a000000<CR><LF> saying that it has zero
data values ready.”
5) Appendix A-1, Suggested SDI-12 Circuits, had the same label for both circuits.
Restored the label for the bottom circuit to:
“sensor or data recorder interface circuit with transient protection”
Version 1.4 August 15, 2016
Corrected an error: Page 27, Table 17, Rows 1 and 2, Column 2, incorrectly said
“Signed-32 bit integer,” rather than “Signed-16 bit integer.”
Version 1.4 July 14, 2016
Added Sections:
5.0 High-volume Commands
6.0 Metadata Commands
This adds the High-volume ASCII Command, the High-volume Binary Command,
extends the use of the D commands to get up to 999 data values, adds binary data packets in
response to the High-volume Binary Command, adds the Identify Measurement Commands, and
the Identify Measurement Parameter Commands.

2/20/2023 Version 1.4

D-2

Renumbered section 5.0 SDI-Timing to 7.0 SDI-12 Timing.
Updated the table of contents to include the additions.
Other modifications, as needed, to include text about the High-volume Commands and
the Metadata Commands, throughout the document.
Numerous clarifications in response to a full review by the SDI-12 Support Group’s
Technical Committee: some rewording, moved (without changing) some sentences and
paragraphs, corrected some typo-graphical errors, and corrected some minor formatting issues.
Version 1.3 January 28, 2016
Clarifications only made to the specification:
1) Page 26, Section 5.2. Added “CRC error” to the first sentence of the last paragraph as
one of five invalid response conditions, from a sensor, that require a data recorder retry.
2) Page 26, Section 5.2. Deleted the word three in the sentence, “If one of the above three
conditions exists the data recorder will issue retries.”
3) Appendix B-2, SDI-12 Sensor Flow Chart. Added “set data line to marking for 8.33
ms” to the box between “valid command?” and “more processing?” This clarifies the
supporting text on page 24, Section 5.0, which says, “After receiving the break and the
command, the addressed sensor sets the data line to marking for 8.33 milliseconds and then
sends the response.”
4) Appendices B-1 and B-2, SDI-12 Data Recorder Flow Chart/SDI-12 Sensor Flow
Chart. Changed all instances of “msec” to the correct abbreviation of “ms.”
Version 1.3 January 26, 2013
Clarifications only made to the specification:
1) Page 1, Section 1.0. Added “see section 3.0 for details” to the third bullet.
2) Page 1, Section 1.0. Deleted the fourth bullet, “Up to 200 feet of cable between a
sensor and data recorder.”
3) Page 11, Table 9. Made a correction. Changed “a valid range of 0 to 9" to “a valid
range of 1 to 9" in row 3, column 2.
4) Page 14, Table 10. Deleted this text, “(a data recorder must be able to read and store at
least 20 parameters from a sensor, nn = 20)”

2/20/2023 Version 1.4

D-3

5) Page 14, Section 4.4.7. Deleted this text, “The maximum number of data values a
sensor can return for nn is 20. A data recorder is also required to store 20 values. Future versions
of SDI-12 may increase this to a maximum of up to 99 values.”
6) Page 14, Section 4.4.7. Added this text, “The data recorder should document the
number of data values it can store in response to a C command.”
7) Page 14, Section 4.4.7. Changed the last paragraph from:
See the send data command, aD0!, aD1! . . . Ad9! for examples of this command. Because the
start concurrent measurement command is closely related to the send data command, examples
for both commands are in sections 4.4.8.3 and 4.4.8.4.
To:
“See the send data command, aD0!, aD1! . . . aD9!, section 4.4.8, for the data response
requirements. Because the start concurrent measurement command is closely related to the send
data command, examples for both commands are in sections 4.4.8.3 and 4.4.8.4.”
8) Page 14, Section 4.4.8. Change the paragraph heading from “aD0! ... aD9!” to “aD0!,
...aD1 ... aD9!.”
Version 1.3

January 3, 2012

Clarifications only made to the specification:
1) Page 5, Section 4.0. Reference to page 14 changed to reference to section 4.4.7.
2) Page 12, Section 4.4.5.1. Deleted the sentence, “It must also empty its buffer so that no
data are returned in response to a D command.” This sentence was deleted because the sentence
after it specifically states what information is to be returned to the sensor in response to
subsequent D commands.
3) Page 14, Section 4.4.7.1. Deleted the sentence, “It must also empty is buffer so that no
data are returned in response to a D command.” This sentence was deleted because the sentence
after it specifically states what information is to be returned to the sensor in response to
subsequent D commands.
4) Page 16, Section 4.4.8.3. Reference to section 4.4 changed to section 4.4.8.
5) Page 16, Section 4.4.8.3. Circular reference to section 4.4.8.3 changed to section
4.4.8.4.
6) Page 23, Section 4.4.13. Corrected typographical error. Deleted the letter s from

2/20/2023 Version 1.4

D-4

“extendeds.”
7) Formatted all paragraph headings in bold.
8) Changed Appendix B, Suggested SDI-12 Flow Control for SDI-12 Data Recorded so
that the logic for the concurrent command matches the text in the body of the document:
a) top left rectangle: deleted the text “in its buffer”
b) top left oval: changed “making” to “marking.”
c) bottom left rectangle: deleted the phrase “empty buffer so”
d) bottom right rectangle: changed the text so that it matches the text in the bottom left
rectangle
e) the “yes” branch of the “C command” decision now goes to the oval “look for address,
break, or 100 msec timeout while processing the command,” rather than the oval “look
for break while processing the command”
f) the “no” branch of “valid command” in the C command processing section now goes to
the oval “look for address, break, or 100 msec timeout while processing the command,”
rather than the oval “look for break while processing the command” oval
g) switched the positions of the two columns of logic for the C command logic to
minimize the crossing of lines
Version 1.3

January 12, 2009

Clarifications only made to the specification:
1) Page 2, Section 3.0. Appended a phrase and a sentence: “, each with 200 feet of cable.
With fewer sensors, longer cable lengths are possible.”
2) Page 4, Section 3.12. Added a sentence: “Due to this impedance, the maximum cable
length depends on the capacitance of all cables connected to the SDI-12 data line.”
3) Page 12, Section 4.4.5. Added a sentence: “The data recorder may wait for the entire
ttt time. Therefore, the tolerance above the measurement time, added to ttt, should be minimal
Version 1.3

July 18, 2005

Clarifications only made to the specification:
1) Page 7, Section 4.4. Added a sentence: “None of the basic commands should affect the
sensor’s calibration.”
2) Page 12, Section 4.4.5.1. Added “or this sensor,” to the sentence at the bottom of the
page.
3) Page 16. Corrected a typographical error.

2/20/2023 Version 1.4

D-5

Version 1.3

July 25, 2004

Clarifications only made to the specification:
1) Page 8, Table 5. Changed “same as the D commands” to “formatted like the D
commands.”
2) Page 16. Changed “The R commands (R0! ... R9!) work exactly like the D commands
(D0! ... D9!).” to “The response to R commands (R0! ... R9!) are formatted like the D commands
(D0! ... D9!).”
3) Page 16. Changed “The only difference is that the R commands do not need to be
preceded with an M command ...” to “The main difference is that the R commands do not need
to be precede with an M command ...”
4) Page 16. Added a new paragraph:
Each R command is an independent measurement. For example, R5 need not be preceded
by R0 ... R4.
5) Page 16. Changed “If a CRC was requested then a CRC must be appended to the
address.” to “If a CRC was requested then the <CR><LF> must be preceded by the CRC.”
6) Page 20. Changed “When these commands are used, the data returned in response to
the D commands must have a CRC code appended to it.” to “When these commands are used,
the data returned in response to the D commands, or R commands, must have a CRC code
appended to it.”
Version 1.3

September 17, 2002

Clarifications only made to the specification:
1) Page 8. Corrected the footnote at the bottom of Table 5 to reference section 4.4.6
rather than section 4.4.12. Section 4.4.6 is the correct section that footnote should reference.
2) Page 9. Added “The “!” character can only be used in a command as the terminator
character.”
3) Page 9. Corrected typographical error; changed “of” to “or.”
4) Page 11, table 9. Added “n is a single digit integer with a valid range of 0 to 9.”
5) Page 12 and Page 14. Added “(or followed by <CRC><CR><LF> if a CRC was
requested).”

2/20/2023 Version 1.4

D-6

6) Page 13. Changed: “A service request is issued by the sensor, after an M or V
command, when it has finished its measurement.” To: “A service request is issued by the
sensor, after an M, MC, or V command, when it has finished its measurement.”
7) Page 15, table 11, Added “the minimum number of digits for a data value (excluding
the decimal point) is 1.”
8) Page 16. Added “If a CRC was requested then a CRC must be appended to the
address. For example: 0AP@<CR><LF>.”
9) Page 20. Added “All shifts shift in a zero.”
10) Page 22. Corrected an error in an example that shows a sensor response with a CRC
value (changed 1.1234 to 1.234). With the additional ‘1' in the data, the CRC value shown in the
example was incorrect.
11) Page 25. Corrected typographical error; changed “sensor” to “data recorder.”
12) Page B-2. Corrected typographical error; changed “emty” to “empty.”
13) Page C-3. Added “the minimum number of digits for a data value (excluding the
decimal point) is 1.”
Version 1.3

April 7, 2000

1) Added a Cyclic Redundancy Check (CRC) to data returned from SDI-12 Sensors, by
the use of existing commands with a C appended, namely: aMC!, aMC1! ... aMC9!, aCC1! ...
aCC9!, and aRC0! ... aRC9!.
2) Changed the Data Line “OFF” impedance to be less restrictive (160K to 360K ohms,
rather than 200K ohms with a plus or minus 10% tolerance.
3) Reworded the paragraph about inductive loading.
4) Clarified the definition of low power standby mode.
Version 1.2

October 21, 1996

Clarifications only made to the specification:
1) Page 2. Added the following statement, which was in Version 1.0, but omitted from
Versions 1.1 and 1.2 (4/12/96) by mistake.
"In the following specifications, all values not indicating specific limits, have an
allowable tolerance of ±10% of the value."

2/20/2023 Version 1.4

D-7

2) Page 12. Added text to clarify when ttt seconds begins and added text to advise sensor
designers to return a ttt value that is greater than the time it takes the sensor to take a
measurement.
"The ttt time period begins upon completion of the transmission of the line feed
character."
"A sensor should return a ttt value greater than the time it takes to make a measurement,
to allow for timing tolerances and for the service request. (See section 4.4.6.)"
3) Page 14. Added text to clarify when ttt seconds begins.
"The ttt time period begins immediately after the sensor transmits the <LF> character."
Version 1.2

April 12, 1996

1) Added the concurrent measurement command (aC!) and the additional concurrent
measurement commands (aC1! . . . aC9!) to the basic command set.
2) Clarified the section on data recorder retries to indicate that a data recorder must issue
retries unless it has received a valid response or if it wishes to abort the measurement.
3) Clarified the no data response to the additional measurement commands (aM! . . .
aM9!)
4) Added the address query command (?!) to the basic command set.
5) Added the change address command (aAb!) to the basic command set.
6) Added the continuous measurement command (aR0! . . . aR9!) to the command set.
Version 1.1

July 7, 1994

Rewrite and clarification of the original specification. No technical changes.
Version 1.0

October 1988

Original release.

2/20/2023 Version 1.4

D-8



--- FILE: src/common/crc.rs ---
// src/common/crc.rs

use super::error::Sdi12Error;
use crc::{Crc, Algorithm};

/// Custom CRC algorithm matching SDI-12 specification (CRC-16/ARC).
/// Polynomial: 0x8005 (normal representation of 0xA001 reversed)
/// Initial Value: 0x0000
/// Input Reflected: true
/// Output Reflected: true
/// Final XOR: 0x0000
/// Check Value: 0xBB3D (for "123456789") - standard for CRC-16/ARC
/// Residue: 0x0000
pub const SDI12_CRC: Algorithm<u16> = Algorithm {
    poly: 0x8005,
    init: 0x0000,
    refin: true,
    refout: true,
    xorout: 0x0000,
    check: 0xBB3D,
    width: 16,
    residue: 0x0000,
};

// Create a Crc instance for the SDI-12 algorithm for reuse.
const CRC_COMPUTER: Crc<u16> = Crc::<u16>::new(&SDI12_CRC);

/// Calculates the SDI-12 CRC-16 (CRC-16/ARC) for the given data buffer.
///
/// Uses the `crc` crate configured for the standard CRC-16/ARC algorithm,
/// which matches the SDI-12 specification. The calculation starts from the
/// first byte (typically the address) up to the byte *before* the CRC
/// itself or the trailing `<CR><LF>`.
///
/// # Arguments
///
/// * `data`: A slice of bytes for which to calculate the CRC.
///
/// # Returns
///
/// The calculated 16-bit CRC value.
#[inline]
pub fn calculate_crc16(data: &[u8]) -> u16 {
    CRC_COMPUTER.checksum(data)
}

/// Encodes a 16-bit CRC value into three ASCII characters according to SDI-12 standard.
///
/// Follows section 4.4.12.2 of the SDI-12 specification v1.4.
///
/// # Arguments
///
/// * `crc_value`: The 16-bit CRC to encode.
///
/// # Returns
///
/// An array of three `u8` bytes representing the ASCII-encoded CRC.
pub fn encode_crc_ascii(crc_value: u16) -> [u8; 3] {
    let char1 = 0x40 | ((crc_value >> 12) & 0x3F) as u8;
    let char2 = 0x40 | ((crc_value >> 6) & 0x3F) as u8;
    let char3 = 0x40 | (crc_value & 0x3F) as u8;
    [char1, char2, char3]
}

/// Decodes three SDI-12 ASCII-encoded CRC characters back into a 16-bit value.
///
/// # Arguments
///
/// * `crc_chars`: A slice or array of three `u8` bytes representing the ASCII-encoded CRC.
///
/// # Returns
///
/// The decoded 16-bit CRC value.
///
/// # Panics
///
/// Panics if `crc_chars` does not have a length of exactly 3.
pub fn decode_crc_ascii(crc_chars: &[u8]) -> u16 {
    assert_eq!(crc_chars.len(), 3, "ASCII CRC must be 3 bytes long");
    let byte1 = u16::from(crc_chars[0] & 0x3F);
    let byte2 = u16::from(crc_chars[1] & 0x3F);
    let byte3 = u16::from(crc_chars[2] & 0x3F);
    (byte1 << 12) | (byte2 << 6) | byte3
}

/// Verifies an SDI-12 response string that includes an ASCII CRC.
///
/// Assumes the buffer ends with the 3 CRC bytes and does *not* include `<CR><LF>`.
///
/// # Arguments
///
/// * `response_with_crc`: The response buffer including the 3-byte ASCII CRC.
///
/// # Returns
///
/// * `Ok(())` if the CRC is valid.
/// * `Err(Sdi12Error::InvalidFormat)` if the buffer is too short.
/// * `Err(Sdi12Error::CrcMismatch)` if the CRCs don't match.
pub fn verify_response_crc_ascii<E>(response_with_crc: &[u8]) -> Result<(), Sdi12Error<E>>
where
    E: core::fmt::Debug,
{
    if response_with_crc.len() < 3 {
        return Err(Sdi12Error::InvalidFormat);
    }
    let data_len = response_with_crc.len() - 3;
    let data_part = &response_with_crc[..data_len];
    let received_crc_bytes = &response_with_crc[data_len..];

    let calculated_crc = calculate_crc16(data_part);
    let received_crc = decode_crc_ascii(received_crc_bytes);

    if calculated_crc == received_crc {
        Ok(())
    } else {
        Err(Sdi12Error::CrcMismatch { expected: received_crc, calculated: calculated_crc, })
    }
}

/// Encodes a 16-bit CRC value into two bytes (LSB first) for binary responses.
///
/// # Arguments
///
/// * `crc_value`: The 16-bit CRC to encode.
///
/// # Returns
///
/// An array of two `u8` bytes `[LSB, MSB]`.
pub fn encode_crc_binary(crc_value: u16) -> [u8; 2] {
    crc_value.to_le_bytes()
}

/// Decodes two bytes (LSB first) from a binary response into a 16-bit CRC value.
///
/// # Arguments
///
/// * `crc_bytes`: A slice or array of two `u8` bytes `[LSB, MSB]`.
///
/// # Returns
///
/// The decoded 16-bit CRC value.
///
/// # Panics
///
/// Panics if `crc_bytes` does not have a length of exactly 2.
pub fn decode_crc_binary(crc_bytes: &[u8]) -> u16 {
    assert_eq!(crc_bytes.len(), 2, "Binary CRC must be 2 bytes long");
    u16::from_le_bytes([crc_bytes[0], crc_bytes[1]])
}

/// Verifies an SDI-12 high-volume binary response packet including its binary CRC.
///
/// Assumes the buffer ends with the 2 raw CRC bytes.
///
/// # Arguments
///
/// * `packet_with_crc`: The complete binary packet buffer including the 2-byte CRC.
///
/// # Returns
///
/// * `Ok(())` if the CRC is valid.
/// * `Err(Sdi12Error::InvalidFormat)` if the buffer is too short.
/// * `Err(Sdi12Error::CrcMismatch)` if the CRCs don't match.
pub fn verify_packet_crc_binary<E>(packet_with_crc: &[u8]) -> Result<(), Sdi12Error<E>>
where
    E: core::fmt::Debug,
{
    if packet_with_crc.len() < 2 {
        return Err(Sdi12Error::InvalidFormat);
    }
    let data_len = packet_with_crc.len() - 2;
    let data_part = &packet_with_crc[..data_len];
    let received_crc_bytes = &packet_with_crc[data_len..];

    let calculated_crc = calculate_crc16(data_part);
    let received_crc = decode_crc_binary(received_crc_bytes);

    if calculated_crc == received_crc {
        Ok(())
    } else {
        Err(Sdi12Error::CrcMismatch { expected: received_crc, calculated: calculated_crc, })
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    // Mock error type for verify function generic parameter
    #[derive(Debug, Clone, PartialEq, Eq)]
    struct MockIoError;
    impl core::fmt::Display for MockIoError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result { write!(f, "Mock I/O Error") }
    }

    // --- ASCII CRC Tests Based Directly on Spec v1.4 Section 4.4.12.3 ---

    #[test]
    fn test_spec_example_a() {
        // "0D0!0+3.14OqZ<CR><LF>"
        let data = b"0+3.14";
        let expected_crc_str = b"OqZ";
        let expected_crc_val = decode_crc_ascii(expected_crc_str); // Derive value from spec string

        // 1. Test calculation
        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example A: Calculation mismatch");

        // 2. Test encoding
        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example A: Encoding mismatch");

        // 3. Test verification helper
        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example A: Verification failed");
    }

    #[test]
    fn test_spec_example_b() {
        // "0D0!0+3.14+2.718+1.414Ipz<CR><LF>"
        let data = b"0+3.14+2.718+1.414";
        let expected_crc_str = b"Ipz";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example B: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example B: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example B: Verification failed");
    }

    #[test]
    fn test_spec_example_c_d0() {
        // "0D0!0+1.11+2.22+3.33+4.44+5.55+6.66I]q<CR><LF>"
        let data = b"0+1.11+2.22+3.33+4.44+5.55+6.66";
        let expected_crc_str = b"I]q";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example C D0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example C D0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example C D0: Verification failed");
    }

    #[test]
    fn test_spec_example_c_d1() {
        // "0D1!0+7.77+8.88+9.99IvW<CR><LF>"
        let data = b"0+7.77+8.88+9.99";
        let expected_crc_str = b"IvW";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example C D1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example C D1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example C D1: Verification failed");
    }

    #[test]
    fn test_spec_example_d() {
        // "0D0!0+3.14+2.718IWO<CR><LF>"
        let data = b"0+3.14+2.718";
        let expected_crc_str = b"IWO";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example D: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example D: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example D: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d0() {
        // "0D0!0+3.14OqZ<CR><LF>" - Same as Example A
        let data = b"0+3.14";
        let expected_crc_str = b"OqZ";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D0: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d1() {
        // "0D1!0+2.718Gbc<CR><LF>"
        let data = b"0+2.718";
        let expected_crc_str = b"Gbc";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D1: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d2() {
        // "0D2!0+1.414GtW<CR><LF>"
        let data = b"0+1.414";
        let expected_crc_str = b"GtW";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D2: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D2: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D2: Verification failed");
    }

    #[test]
    fn test_spec_example_f_sensor1() {
        // "1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>"
        let data = b"1+1.23+2.34+345+4.4678";
        let expected_crc_str = b"KoO";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example F S1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example F S1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example F S1: Verification failed");
    }

     #[test]
    fn test_spec_example_f_sensor0() {
        // "0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12Ba]<CR><LF>"
        let data = b"0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12";
        let expected_crc_str = b"Ba]";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example F S0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example F S0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example F S0: Verification failed");
    }


    // --- Binary CRC Tests Based Directly on Spec v1.4 Section 5.2.2 ---

    #[test]
    fn test_spec_binary_example_db0() {
        // Data: 0x31 0x04 0x00 0x03 0xFF 0xFF 0x01 0x00
        // CRC: 0xC2 0xAC -> 0xACC2
        let data = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00];
        let expected_crc_bytes = &[0xC2, 0xAC]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        // 1. Test calculation
        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB0: Calculation mismatch");

        // 2. Test encoding
        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB0: Encoding mismatch");

        // 3. Test verification helper
        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB0: Verification failed");
    }

     #[test]
    fn test_spec_binary_example_db1() {
        // Data: 0x31 0x08 0x00 0x09 0xC3 0xF5 0x48 0x40 0x00 0x00 0x80 0x3F
        // CRC: 0x3B 0x6E -> 0x6E3B
        let data = &[0x31, 0x08, 0x00, 0x09, 0xC3, 0xF5, 0x48, 0x40, 0x00, 0x00, 0x80, 0x3F];
        let expected_crc_bytes = &[0x3B, 0x6E]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB1: Calculation mismatch");

        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB1: Encoding mismatch");

        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB1: Verification failed");
    }

    #[test]
    fn test_spec_binary_example_db2_empty() {
        // Data: 0x31 0x00 0x00 0x00 (Empty packet indicator)
        // CRC: 0x0E 0xFC -> 0xFC0E
        let data = &[0x31, 0x00, 0x00, 0x00];
        let expected_crc_bytes = &[0x0E, 0xFC]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB2: Calculation mismatch");

        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB2: Encoding mismatch");

        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB2: Verification failed");
    }

    // --- Optional: Keep basic roundtrip/error tests if desired ---
    #[test]
    fn test_crc_ascii_encoding_decoding_roundtrip_extra() {
        let test_cases = [0x0000, 0xFFFF, 0x1234, 0xABCD]; // Non-spec examples
        for crc_val in test_cases {
            let encoded = encode_crc_ascii(crc_val);
            let decoded = decode_crc_ascii(&encoded);
            assert_eq!(decoded, crc_val, "ASCII Encode/Decode roundtrip failed for {:#06x}", crc_val);
        }
    }

    #[test]
    fn test_binary_crc_encoding_decoding_roundtrip_extra() {
         let test_cases = [0x0000, 0xFFFF, 0x1234, 0xABCD]; // Non-spec examples
        for crc_val in test_cases {
            let encoded = encode_crc_binary(crc_val);
            let decoded = decode_crc_binary(&encoded);
            assert_eq!(decoded, crc_val, "Binary Encode/Decode roundtrip failed for {:#06x}", crc_val);
        }
    }

    #[test]
    fn test_verify_ascii_crc_invalid_cases() {
        // Wrong CRC characters
        let result1 = verify_response_crc_ascii::<MockIoError>(b"0+3.14OqX"); // Correct is OqZ
        assert!(matches!(result1, Err(Sdi12Error::CrcMismatch { .. })));

        // Corrupted data, correct CRC characters
        let result2 = verify_response_crc_ascii::<MockIoError>(b"0+3.15OqZ"); // Changed 4 to 5
        assert!(matches!(result2, Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer too short for CRC
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b"0+"), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b"Oq"), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b""), Err(Sdi12Error::InvalidFormat)));
    }

     #[test]
    fn test_verify_binary_crc_invalid_cases() {
        // Correct data, wrong CRC bytes
        let data = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00];
        let mut packet_bad_crc = data.to_vec();
        packet_bad_crc.extend_from_slice(&[0xC3, 0xAC]); // Original CRC was C2 AC
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&packet_bad_crc), Err(Sdi12Error::CrcMismatch { .. })));

        // Corrupted data, original CRC bytes
        let data_bad = &[0x31, 0x04, 0x00, 0x03, 0xFE, 0xFF, 0x01, 0x00];
        let mut packet_bad_data = data_bad.to_vec();
        let correct_crc = calculate_crc16(data); // CRC for original data
        packet_bad_data.extend_from_slice(&encode_crc_binary(correct_crc));
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&packet_bad_data), Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer has data but only 1 byte for CRC
        let packet_short_crc = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00, 0xC2];
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(packet_short_crc), Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer genuinely too short
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&[0x31]), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(b""), Err(Sdi12Error::InvalidFormat)));
    }

    // Panic tests for decode functions remain useful
    #[test]
    #[should_panic]
    fn test_decode_ascii_panic_short() { decode_crc_ascii(b"Oq"); }
    #[test]
    #[should_panic]
    fn test_decode_ascii_panic_long() { decode_crc_ascii(b"OqZZ"); }
    #[test]
    #[should_panic]
    fn test_decode_binary_panic_short() { decode_crc_binary(&[0xC2]); }
    #[test]
    #[should_panic]
    fn test_decode_binary_panic_long() { decode_crc_binary(&[0xC2, 0xAC, 0x00]); }
}

--- FILE: src/sensor/parser.rs ---
// src/sensor/parser.rs

use crate::common::{
    address::Sdi12Addr,
    command::{
        Command, /* CommandIndexError (keep if used by helpers), */ // Remove if not directly used here
        ContinuousIndex, DataIndex, IdentifyMeasurementCommand,
        IdentifyMeasurementParameterCommand, IdentifyParameterIndex, MeasurementIndex,
    },
    error::Sdi12Error,
};
// use core::convert::TryFrom; // Not directly used here anymore
use core::str;

#[cfg(feature = "alloc")]
use alloc::string::String;
#[cfg(feature = "alloc")]
use alloc::string::ToString; // Needed for to_string()


/// Parses a raw SDI-12 command byte sequence into a structured Command enum.
///
/// Expects input bytes starting with the address and ending with the '!' terminator.
/// Does not handle the initial break or serial timing/framing.
///
/// # Arguments
///
/// * `bytes`: A byte slice containing the raw command (e.g., `b"1M!"`, `b"0D0!"`, `b"aRC5_123!"`).
///
/// # Returns
///
/// * `Ok(Command)`: If the byte sequence represents a valid SDI-12 command.
/// * `Err(Sdi12Error<()>)`: If parsing fails due to invalid format, address, index, etc.
pub fn parse_command(bytes: &[u8]) -> Result<Command, Sdi12Error<()>> {
    // --- Basic Validation ---
    if bytes.len() < 2 {
        return Err(Sdi12Error::InvalidFormat); // Need at least 'a!' or '?!'
    }
    if bytes[bytes.len() - 1] != b'!' {
        return Err(Sdi12Error::InvalidFormat); // Must end with '!'
    }

    let address_char = bytes[0] as char;
    let address = Sdi12Addr::new(address_char)?; // Returns InvalidAddress error if needed

    // Command body excludes address and '!'
    let body = &bytes[1..bytes.len() - 1];

    // Handle Address Query (?!) separately
    if address.is_query() {
        if body.is_empty() {
            return Ok(Command::AddressQuery);
        } else {
            return Err(Sdi12Error::InvalidFormat); // "?..." is invalid, only "?!"
        }
    }

    // --- Check Body Bytes for Printable ASCII ---
    // SDI-12 Spec Sec 4.2 requires command body chars to be printable ASCII (0x20-0x7E)
    if !body.iter().all(|&b| b >= 0x20 && b <= 0x7E) {
        // If any byte is outside the range, it's an invalid command format per SDI-12.
        return Err(Sdi12Error::InvalidFormat);
    }

    // --- Parse Command Body (now known to be printable ASCII) ---
    // Since we've verified bytes are in the ASCII range 0x20-0x7E,
    // this conversion is safe and will produce a valid ASCII string.
    let body_str = unsafe { str::from_utf8_unchecked(body) };

    match body_str {
        // --- Basic Commands ---
        "" => Ok(Command::AcknowledgeActive { address }),
        "I" => Ok(Command::SendIdentification { address }),
        "V" => Ok(Command::StartVerification { address }),
        "HA" => Ok(Command::StartHighVolumeASCII { address }),
        "HB" => Ok(Command::StartHighVolumeBinary { address }),

        // Change Address: aAb!
        body if body.starts_with('A') && body.len() == 2 => {
            let new_addr_char = body.chars().nth(1).unwrap(); // Safe due to len check
            let new_address = Sdi12Addr::new(new_addr_char)?;
            Ok(Command::ChangeAddress { address, new_address })
        }

        // Measurement: aM[n]! / aMC[n]! / aC[n]! / aCC[n]!
        body if body.starts_with('M') || body.starts_with('C') => {
            parse_measurement_command(address, body_str)
        }

        // Send Data: aD[n]! / aDB[n]! (n = 0-999)
        body if body.starts_with('D') => parse_data_command(address, body_str),

        // Read Continuous: aR[n]! / aRC[n]! (n = 0-9)
        body if body.starts_with('R') => parse_continuous_command(address, body_str),

        // --- Metadata Commands ---
        // Identify Measurement: aIM[n]! / aIV! / aIC[n]! / aIHA! / etc.
        body if body.starts_with('I') => parse_identify_command(address, body_str),

        // Extended Command (Fallback, requires 'alloc')
        #[cfg(feature = "alloc")]
        _ => {
            // Check for valid extended command characters if needed (spec doesn't strictly limit)
            // For now, accept any non-empty body not matched above as extended
            if body_str.is_empty() {
                 Err(Sdi12Error::InvalidFormat) // Should have been caught by "" case
            } else {
                 Ok(Command::ExtendedCommand { address, command_body: body_str.to_string() })
            }
        }
        #[cfg(not(feature = "alloc"))]
        _ => Err(Sdi12Error::InvalidFormat), // Or a specific "ExtendedCommandNotSupported" error?
    }
}

// --- Helper: Parse M/MC/C/CC commands ---
fn parse_measurement_command(
    address: Sdi12Addr,
    body: &str,
) -> Result<Command, Sdi12Error<()>> {
    let (cmd_code, index_str) = match body.len() {
        1 => (body, None), // M, C
        2 => {
             // MC, CC, M1-9, C1-9
            let code_part = &body[..body.len() - 1]; // M, C, MC, CC
            let index_part = &body[body.len() - 1..];
            if index_part.chars().all(|c| c.is_ascii_digit()) {
                (code_part, Some(index_part))
            } else {
                 // Must be MC or CC
                 (body, None)
            }
        }
        3 => {
            // MC1-9, CC1-9
             let code_part = &body[..body.len() - 1]; // MC, CC
             let index_part = &body[body.len() - 1..];
            if index_part.chars().all(|c| c.is_ascii_digit()) {
                (code_part, Some(index_part))
            } else {
                 return Err(Sdi12Error::InvalidFormat); // e.g., MCX
            }
        }
        _ => return Err(Sdi12Error::InvalidFormat),
    };

    let index_val = index_str
        .map(|s| s.parse::<u8>().map_err(|_| Sdi12Error::InvalidFormat)) // Invalid number format
        .transpose()?; // Convert Option<Result<u8, _>> to Result<Option<u8>, _>

    let index = MeasurementIndex::new(index_val)?; // Returns InvalidCommandIndex error

    match cmd_code {
        "M" => Ok(Command::StartMeasurement { address, index }),
        "MC" => Ok(Command::StartMeasurementCRC { address, index }),
        "C" => Ok(Command::StartConcurrentMeasurement { address, index }),
        "CC" => Ok(Command::StartConcurrentMeasurementCRC { address, index }),
        _ => Err(Sdi12Error::InvalidFormat),
    }
}

// --- Helper: Parse D/DB commands ---
fn parse_data_command(address: Sdi12Addr, body: &str) -> Result<Command, Sdi12Error<()>> {
    let (is_binary, index_str) = if body.starts_with("DB") {
        (true, &body[2..])
    } else if body.starts_with('D') {
        (false, &body[1..])
    } else {
        return Err(Sdi12Error::InvalidFormat); // Should not happen if called correctly
    };

    if index_str.is_empty() || !index_str.chars().all(|c| c.is_ascii_digit()) {
        return Err(Sdi12Error::InvalidFormat); // Need index digits
    }

    let index_val = index_str.parse::<u16>().map_err(|_| Sdi12Error::InvalidFormat)?;
    let index = DataIndex::new(index_val)?; // Returns InvalidCommandIndex

    if is_binary {
        Ok(Command::SendBinaryData { address, index })
    } else {
        Ok(Command::SendData { address, index })
    }
}

// --- Helper: Parse R/RC commands ---
fn parse_continuous_command(
    address: Sdi12Addr,
    body: &str,
) -> Result<Command, Sdi12Error<()>> {
    let (is_crc, index_str) = if body.starts_with("RC") {
        (true, &body[2..])
    } else if body.starts_with('R') {
        (false, &body[1..])
    } else {
        return Err(Sdi12Error::InvalidFormat);
    };

    if index_str.len() != 1 || !index_str.chars().all(|c| c.is_ascii_digit()) {
        return Err(Sdi12Error::InvalidFormat); // Needs exactly one index digit
    }

    let index_val = index_str.parse::<u8>().map_err(|_| Sdi12Error::InvalidFormat)?;
    let index = ContinuousIndex::new(index_val)?; // Returns InvalidCommandIndex

    if is_crc {
        Ok(Command::ReadContinuousCRC { address, index })
    } else {
        Ok(Command::ReadContinuous { address, index })
    }
}

// --- Helper: Parse Identify Measurement / Parameter commands ---
// Example formats: aIM!, aIMC1!, aIV!, aIC5!, aICC!, aIHA!, aIHB!
// Parameter: aIM_001!, aIMC1_010!, aIV_123!, aIC5_999!, aICC_001!, aIHA_050!, aIHB_001!
// Parameter Continuous: aIR0_001!, aIRC9_100!
fn parse_identify_command(
    address: Sdi12Addr,
    body: &str,
) -> Result<Command, Sdi12Error<()>> {
    // Separate main command part from optional parameter part (_nnn) using iterator
    let mut parts = body.splitn(2, '_');
    let main_cmd_part = parts.next().unwrap(); // First part always exists
    let param_str_opt = parts.next();         // Second part is optional

    // Process the optional parameter string
    let param_index_opt: Option<Result<IdentifyParameterIndex, Sdi12Error<()>>> =
        param_str_opt.map(|param_str| {
            if param_str.len() == 3 && param_str.chars().all(|c| c.is_ascii_digit()) {
                 param_str.parse::<u16>()
                    .map_err(|_| Sdi12Error::InvalidFormat) // Should not happen with checks
                    .and_then(|value| {
                        IdentifyParameterIndex::new(value) // Returns Result<_, CommandIndexError>
                            .map_err(Sdi12Error::from)     // Explicitly map error to Result<_, Sdi12Error<()>>
                    })
            } else {
                 Err(Sdi12Error::InvalidFormat) // Parameter index format incorrect
            }
        });

    // Extract base command code (e.g., IM, IMC, IV, IC, ICC, IR, IRC, IHA, IHB) and measurement index if present
    let base_code;
    let index_opt_str;

    if main_cmd_part.starts_with("IM")
        || main_cmd_part.starts_with("IC")
        || main_cmd_part.starts_with("IR") // Handle IR/IRC here too
    {
        // Determine expected length of the command code part (e.g., "IMC" is 3)
        let potential_code_len = if main_cmd_part.starts_with("IRC") || main_cmd_part.starts_with("IMC") || main_cmd_part.starts_with("ICC") {
             3 // IRC, IMC, ICC
        } else if main_cmd_part.starts_with("IM") || main_cmd_part.starts_with("IC") || main_cmd_part.starts_with("IR") {
             2 // IM, IC, IR
        } else {
             return Err(Sdi12Error::InvalidFormat); // Should start with I<Cmd>
        };

        // Check if the main part has just the code, or the code + an index digit
        if main_cmd_part.len() == potential_code_len {
            base_code = &main_cmd_part[..potential_code_len];
            index_opt_str = None;
        } else if main_cmd_part.len() == potential_code_len + 1 {
            base_code = &main_cmd_part[..potential_code_len];
            index_opt_str = Some(&main_cmd_part[potential_code_len..]);
             // Validate the index character
            if !index_opt_str.unwrap().chars().all(|c| c.is_ascii_digit()) {
                 return Err(Sdi12Error::InvalidFormat); // Index must be digit
             }
        } else {
             return Err(Sdi12Error::InvalidFormat); // Invalid length (e.g., "IM12")
        }
    } else if main_cmd_part == "IV" || main_cmd_part == "IHA" || main_cmd_part == "IHB" {
        // These commands don't have an index between the code and potential parameter
        base_code = main_cmd_part;
        index_opt_str = None;
    } else {
        return Err(Sdi12Error::InvalidFormat); // Unrecognized Identify command start
    }

    // --- Build Specific Command Enum ---
    match param_index_opt {
        // --- Parameter Commands ---
        Some(Ok(param_index)) => {
             match base_code {
                 "IM" | "IMC" | "IC" | "ICC" => {
                    // Measurement/Concurrent Parameter
                    let m_index_val = index_opt_str
                        .map(|s| s.parse::<u8>().map_err(|_| Sdi12Error::InvalidFormat))
                        .transpose()?;
                    let m_index = MeasurementIndex::new(m_index_val)?; // map CommandIndexError -> Sdi12Error
                    match base_code {
                        "IM" => Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Measurement { address, m_index, param_index })),
                        "IMC" => Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::MeasurementCRC { address, m_index, param_index })),
                        "IC" => Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurement { address, c_index: m_index, param_index })),
                        "ICC" => Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurementCRC { address, c_index: m_index, param_index })),
                        _ => unreachable!(),
                    }
                }
                 "IV" => {
                    if index_opt_str.is_some() { return Err(Sdi12Error::InvalidFormat); } // IV_nnn! doesn't have M index
                    Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Verification { address, param_index }))
                }
                "IR" | "IRC" => {
                    // Continuous Parameter
                    let r_index_val = index_opt_str
                         .ok_or(Sdi12Error::InvalidFormat)? // IR/IRC needs R index
                         .parse::<u8>().map_err(|_| Sdi12Error::InvalidFormat)?;
                    let r_index = ContinuousIndex::new(r_index_val)?; // map CommandIndexError -> Sdi12Error
                    match base_code {
                        "IR" => Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuous { address, r_index, param_index })),
                        "IRC" => Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuousCRC { address, r_index, param_index })),
                         _ => unreachable!(),
                    }
                }
                 "IHA" => {
                    if index_opt_str.is_some() { return Err(Sdi12Error::InvalidFormat); }
                    Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::HighVolumeASCII { address, param_index }))
                }
                 "IHB" => {
                    if index_opt_str.is_some() { return Err(Sdi12Error::InvalidFormat); }
                    Ok(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::HighVolumeBinary { address, param_index }))
                }
                _ => Err(Sdi12Error::InvalidFormat), // Unrecognized base code for parameter command
            }
        }
        Some(Err(e)) => Err(e), // Parameter parsing failed (e.g., invalid number, out of range)

        // --- Measurement Commands (No Parameter Index) ---
        None => {
             match base_code {
                "IM" | "IMC" | "IC" | "ICC" => {
                     // Measurement/Concurrent Identify
                    let index_val = index_opt_str
                        .map(|s| s.parse::<u8>().map_err(|_| Sdi12Error::InvalidFormat))
                        .transpose()?;
                    let index = MeasurementIndex::new(index_val)?; // map CommandIndexError -> Sdi12Error
                     match base_code {
                        "IM" => Ok(Command::IdentifyMeasurement(IdentifyMeasurementCommand::Measurement { address, index })),
                        "IMC" => Ok(Command::IdentifyMeasurement(IdentifyMeasurementCommand::MeasurementCRC { address, index })),
                        "IC" => Ok(Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurement { address, index })),
                        "ICC" => Ok(Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurementCRC { address, index })),
                        _ => unreachable!(),
                    }
                }
                 "IV" => {
                    if index_opt_str.is_some() { return Err(Sdi12Error::InvalidFormat); }
                    Ok(Command::IdentifyMeasurement(IdentifyMeasurementCommand::Verification { address }))
                }
                 "IHA" => {
                    if index_opt_str.is_some() { return Err(Sdi12Error::InvalidFormat); }
                    Ok(Command::IdentifyMeasurement(IdentifyMeasurementCommand::HighVolumeASCII { address }))
                }
                 "IHB" => {
                    if index_opt_str.is_some() { return Err(Sdi12Error::InvalidFormat); }
                    Ok(Command::IdentifyMeasurement(IdentifyMeasurementCommand::HighVolumeBinary { address }))
                }
                // IR/IRC without parameter index is invalid according to Table 20 examples
                 "IR" | "IRC" => Err(Sdi12Error::InvalidFormat),
                 _ => Err(Sdi12Error::InvalidFormat), // Unrecognized base code for measurement command
            }
        }
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*; // Brings in parse_command
    use crate::common::address::Sdi12Addr;
    use crate::common::command::{ // Import specific items needed for tests
        Command, CommandFormatError, CommandIndexError, // <= ADDED CommandIndexError here
        ContinuousIndex, DataIndex, IdentifyMeasurementCommand,
        IdentifyMeasurementParameterCommand, IdentifyParameterIndex, MeasurementIndex,
    };
    use crate::common::error::Sdi12Error; // Need this for matching errors
    fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    #[test]
    fn test_parse_basic_commands() {
        assert_eq!(parse_command(b"0!").unwrap(), Command::AcknowledgeActive { address: addr('0') });
        assert_eq!(parse_command(b"1I!").unwrap(), Command::SendIdentification { address: addr('1') });
        assert_eq!(parse_command(b"?!").unwrap(), Command::AddressQuery);
        assert_eq!(parse_command(b"2A3!").unwrap(), Command::ChangeAddress { address: addr('2'), new_address: addr('3') });
        assert_eq!(parse_command(b"4V!").unwrap(), Command::StartVerification { address: addr('4') });
        assert_eq!(parse_command(b"5HA!").unwrap(), Command::StartHighVolumeASCII { address: addr('5') });
        assert_eq!(parse_command(b"6HB!").unwrap(), Command::StartHighVolumeBinary { address: addr('6') });
    }

    #[test]
    fn test_parse_measurement_commands() {
        // M
        assert_eq!(parse_command(b"0M!").unwrap(), Command::StartMeasurement { address: addr('0'), index: MeasurementIndex::Base });
        assert_eq!(parse_command(b"1M1!").unwrap(), Command::StartMeasurement { address: addr('1'), index: MeasurementIndex::Indexed(1) });
        assert_eq!(parse_command(b"2M9!").unwrap(), Command::StartMeasurement { address: addr('2'), index: MeasurementIndex::Indexed(9) });
        // MC
        assert_eq!(parse_command(b"3MC!").unwrap(), Command::StartMeasurementCRC { address: addr('3'), index: MeasurementIndex::Base });
        assert_eq!(parse_command(b"4MC1!").unwrap(), Command::StartMeasurementCRC { address: addr('4'), index: MeasurementIndex::Indexed(1) });
        assert_eq!(parse_command(b"5MC9!").unwrap(), Command::StartMeasurementCRC { address: addr('5'), index: MeasurementIndex::Indexed(9) });
        // C
        assert_eq!(parse_command(b"6C!").unwrap(), Command::StartConcurrentMeasurement { address: addr('6'), index: MeasurementIndex::Base });
        assert_eq!(parse_command(b"7C1!").unwrap(), Command::StartConcurrentMeasurement { address: addr('7'), index: MeasurementIndex::Indexed(1) });
        assert_eq!(parse_command(b"8C9!").unwrap(), Command::StartConcurrentMeasurement { address: addr('8'), index: MeasurementIndex::Indexed(9) });
        // CC
        assert_eq!(parse_command(b"9CC!").unwrap(), Command::StartConcurrentMeasurementCRC { address: addr('9'), index: MeasurementIndex::Base });
        assert_eq!(parse_command(b"aCC1!").unwrap(), Command::StartConcurrentMeasurementCRC { address: addr('a'), index: MeasurementIndex::Indexed(1) });
        assert_eq!(parse_command(b"bCC9!").unwrap(), Command::StartConcurrentMeasurementCRC { address: addr('b'), index: MeasurementIndex::Indexed(9) });
    }

     #[test]
    fn test_parse_data_commands() {
        // D
        assert_eq!(parse_command(b"0D0!").unwrap(), Command::SendData { address: addr('0'), index: DataIndex::new(0).unwrap() });
        assert_eq!(parse_command(b"1D9!").unwrap(), Command::SendData { address: addr('1'), index: DataIndex::new(9).unwrap() });
        assert_eq!(parse_command(b"2D10!").unwrap(), Command::SendData { address: addr('2'), index: DataIndex::new(10).unwrap() });
        assert_eq!(parse_command(b"3D999!").unwrap(), Command::SendData { address: addr('3'), index: DataIndex::new(999).unwrap() });
        // DB
        assert_eq!(parse_command(b"4DB0!").unwrap(), Command::SendBinaryData { address: addr('4'), index: DataIndex::new(0).unwrap() });
        assert_eq!(parse_command(b"5DB123!").unwrap(), Command::SendBinaryData { address: addr('5'), index: DataIndex::new(123).unwrap() });
        assert_eq!(parse_command(b"6DB999!").unwrap(), Command::SendBinaryData { address: addr('6'), index: DataIndex::new(999).unwrap() });
    }

    #[test]
    fn test_parse_continuous_commands() {
         // R
        assert_eq!(parse_command(b"0R0!").unwrap(), Command::ReadContinuous { address: addr('0'), index: ContinuousIndex::new(0).unwrap() });
        assert_eq!(parse_command(b"1R9!").unwrap(), Command::ReadContinuous { address: addr('1'), index: ContinuousIndex::new(9).unwrap() });
        // RC
        assert_eq!(parse_command(b"2RC0!").unwrap(), Command::ReadContinuousCRC { address: addr('2'), index: ContinuousIndex::new(0).unwrap() });
        assert_eq!(parse_command(b"3RC9!").unwrap(), Command::ReadContinuousCRC { address: addr('3'), index: ContinuousIndex::new(9).unwrap() });
    }

    #[test]
    fn test_parse_identify_measurement_commands() {
        assert_eq!(parse_command(b"0IM!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::Measurement { address: addr('0'), index: MeasurementIndex::Base }));
        assert_eq!(parse_command(b"1IM1!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::Measurement { address: addr('1'), index: MeasurementIndex::Indexed(1) }));
        assert_eq!(parse_command(b"2IMC!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::MeasurementCRC { address: addr('2'), index: MeasurementIndex::Base }));
        assert_eq!(parse_command(b"3IMC9!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::MeasurementCRC { address: addr('3'), index: MeasurementIndex::Indexed(9) }));
        assert_eq!(parse_command(b"4IV!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::Verification { address: addr('4') }));
        assert_eq!(parse_command(b"5IC!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurement { address: addr('5'), index: MeasurementIndex::Base }));
        assert_eq!(parse_command(b"6IC2!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurement { address: addr('6'), index: MeasurementIndex::Indexed(2) }));
        assert_eq!(parse_command(b"7ICC!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurementCRC { address: addr('7'), index: MeasurementIndex::Base }));
        assert_eq!(parse_command(b"8ICC8!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurementCRC { address: addr('8'), index: MeasurementIndex::Indexed(8) }));
        assert_eq!(parse_command(b"9IHA!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::HighVolumeASCII { address: addr('9') }));
        assert_eq!(parse_command(b"aIHB!").unwrap(), Command::IdentifyMeasurement(IdentifyMeasurementCommand::HighVolumeBinary { address: addr('a') }));
    }

     #[test]
    fn test_parse_identify_parameter_commands() {
        assert_eq!(parse_command(b"0IM_001!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Measurement { address: addr('0'), m_index: MeasurementIndex::Base, param_index: IdentifyParameterIndex::new(1).unwrap() }));
        assert_eq!(parse_command(b"1IM1_010!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Measurement { address: addr('1'), m_index: MeasurementIndex::Indexed(1), param_index: IdentifyParameterIndex::new(10).unwrap() }));
        assert_eq!(parse_command(b"2IMC_999!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::MeasurementCRC { address: addr('2'), m_index: MeasurementIndex::Base, param_index: IdentifyParameterIndex::new(999).unwrap() }));
        assert_eq!(parse_command(b"3IMC9_001!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::MeasurementCRC { address: addr('3'), m_index: MeasurementIndex::Indexed(9), param_index: IdentifyParameterIndex::new(1).unwrap() }));
        assert_eq!(parse_command(b"4IV_123!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Verification { address: addr('4'), param_index: IdentifyParameterIndex::new(123).unwrap() }));
        assert_eq!(parse_command(b"5IC_050!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurement { address: addr('5'), c_index: MeasurementIndex::Base, param_index: IdentifyParameterIndex::new(50).unwrap() }));
        assert_eq!(parse_command(b"6IC2_002!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurement { address: addr('6'), c_index: MeasurementIndex::Indexed(2), param_index: IdentifyParameterIndex::new(2).unwrap() }));
        assert_eq!(parse_command(b"7ICC_001!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurementCRC { address: addr('7'), c_index: MeasurementIndex::Base, param_index: IdentifyParameterIndex::new(1).unwrap() }));
        assert_eq!(parse_command(b"8ICC8_100!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurementCRC { address: addr('8'), c_index: MeasurementIndex::Indexed(8), param_index: IdentifyParameterIndex::new(100).unwrap() }));
        assert_eq!(parse_command(b"9IR0_001!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuous { address: addr('9'), r_index: ContinuousIndex::new(0).unwrap(), param_index: IdentifyParameterIndex::new(1).unwrap() }));
        assert_eq!(parse_command(b"aIR9_999!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuous { address: addr('a'), r_index: ContinuousIndex::new(9).unwrap(), param_index: IdentifyParameterIndex::new(999).unwrap() }));
        assert_eq!(parse_command(b"bIRC0_002!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuousCRC { address: addr('b'), r_index: ContinuousIndex::new(0).unwrap(), param_index: IdentifyParameterIndex::new(2).unwrap() }));
        assert_eq!(parse_command(b"cIRC9_010!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuousCRC { address: addr('c'), r_index: ContinuousIndex::new(9).unwrap(), param_index: IdentifyParameterIndex::new(10).unwrap() }));
        assert_eq!(parse_command(b"dIHA_001!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::HighVolumeASCII { address: addr('d'), param_index: IdentifyParameterIndex::new(1).unwrap() }));
        assert_eq!(parse_command(b"eIHB_999!").unwrap(), Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::HighVolumeBinary { address: addr('e'), param_index: IdentifyParameterIndex::new(999).unwrap() }));
    }


    #[test]
    #[cfg(feature = "alloc")]
    fn test_parse_extended_commands() {
        assert_eq!(parse_command(b"0XABC!").unwrap(), Command::ExtendedCommand { address: addr('0'), command_body: "XABC".to_string() });
        assert_eq!(parse_command(b"1SOME_CMD_123!").unwrap(), Command::ExtendedCommand { address: addr('1'), command_body: "SOME_CMD_123".to_string() });
    }

    #[test]
    fn test_parse_invalid_formats() {
        // Basic structure
        assert!(matches!(parse_command(b""), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(parse_command(b"0"), Err(Sdi12Error::InvalidFormat))); // Missing !
        assert!(matches!(parse_command(b"!"), Err(Sdi12Error::InvalidFormat))); // Invalid address
        assert!(matches!(parse_command(b"0M"), Err(Sdi12Error::InvalidFormat))); // Missing !
        assert!(matches!(parse_command(b"?A!"), Err(Sdi12Error::InvalidFormat))); // Query cannot have body

        // Address
        assert!(matches!(parse_command(b"$!"), Err(Sdi12Error::InvalidAddress('$'))));
        assert!(matches!(parse_command(b"_M!"), Err(Sdi12Error::InvalidAddress('_'))));

        // Command Codes
        let result_0q = parse_command(b"0Q!");

        // Use #[cfg] attribute to conditionally COMPILE the correct assertion block
        #[cfg(feature = "alloc")]
        {
            // This block only compiles if 'alloc' feature is enabled
            assert!(matches!(result_0q, Ok(Command::ExtendedCommand { .. })),
                    "Test run WITH alloc: Expected 0Q! to be Ok(ExtendedCommand), but got {:?}", result_0q);
        }

        #[cfg(not(feature = "alloc"))]
        {
            // This block only compiles if 'alloc' feature is NOT enabled
            assert!(matches!(result_0q, Err(Sdi12Error::InvalidFormat)),
                    "Test run WITHOUT alloc: Expected 0Q! to be Err(InvalidFormat), but got {:?}", result_0q);
        }

        // weird stuff happening with alloc here, test moved to conditional compilation above, revisit later:
            // assert!(matches!(parse_command(b"0Q!"), Err(Sdi12Error::InvalidFormat))); // Unknown command Q

        assert!(matches!(parse_command(b"1MA!"), Err(Sdi12Error::InvalidFormat))); // Invalid char after M
        assert!(matches!(parse_command(b"2MCC!"), Err(Sdi12Error::InvalidFormat))); // Double C
        assert!(matches!(parse_command(b"3DA!"), Err(Sdi12Error::InvalidFormat))); // D needs digits
        assert!(matches!(parse_command(b"4D!"), Err(Sdi12Error::InvalidFormat))); // D needs digits
        assert!(matches!(parse_command(b"5R!"), Err(Sdi12Error::InvalidFormat))); // R needs digit
        assert!(matches!(parse_command(b"6RA!"), Err(Sdi12Error::InvalidFormat))); // R needs digit
        assert!(matches!(parse_command(b"7RC!"), Err(Sdi12Error::InvalidFormat))); // RC needs digit

        // Indices
        assert!(matches!(parse_command(b"0M0!"), Err(Sdi12Error::InvalidCommandIndex(CommandIndexError::MeasurementOutOfRange))));
        assert!(matches!(parse_command(b"1M10!"), Err(Sdi12Error::InvalidCommandIndex(CommandIndexError::MeasurementOutOfRange))));
        assert!(matches!(parse_command(b"2D1000!"), Err(Sdi12Error::InvalidCommandIndex(CommandIndexError::DataOutOfRange))));
        assert!(matches!(parse_command(b"3R10!"), Err(Sdi12Error::InvalidFormat))); // R has only 1 digit index
        assert!(matches!(parse_command(b"4RC10!"), Err(Sdi12Error::InvalidFormat))); // RC has only 1 digit index
        assert!(matches!(parse_command(b"5IM0!"), Err(Sdi12Error::InvalidCommandIndex(CommandIndexError::MeasurementOutOfRange))));
        assert!(matches!(parse_command(b"6IM_000!"), Err(Sdi12Error::InvalidCommandIndex(CommandIndexError::IdentifyParamOutOfRange))));
        assert!(matches!(parse_command(b"7IM_1000!"), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(parse_command(b"8IM_12!"), Err(Sdi12Error::InvalidFormat))); // Parameter index must be 3 digits
        assert!(matches!(parse_command(b"9IM_ABC!"), Err(Sdi12Error::InvalidFormat))); // Parameter index must be digits

        // UTF8 error (though spec requires printable ASCII)
        assert!(matches!(parse_command(&[b'0', 0xE2, 0x82, 0xAC, b'!']), Err(Sdi12Error::InvalidFormat))); // Euro sign €

        // Extended command without alloc
        #[cfg(not(feature = "alloc"))]
        assert!(matches!(parse_command(b"0XABC!"), Err(Sdi12Error::InvalidFormat)));
    }

    // Test that CommandIndexError maps correctly (via From trait in error.rs)
    #[test]
    fn test_index_error_mapping() {
         // Simulate a failure during index parsing/validation
         let result = IdentifyParameterIndex::new(1000); // This returns CommandIndexError
         assert!(result.is_err());
         let index_err = result.err().unwrap();

         // Now use this in a context where it would be mapped to Sdi12Error
         let sdi12_err: Sdi12Error<()> = index_err.into();

         assert_eq!(sdi12_err, Sdi12Error::InvalidCommandIndex(CommandIndexError::IdentifyParamOutOfRange));
    }

     // Test that CommandFormatError maps correctly (via From trait in error.rs)
     #[test]
     fn test_format_error_mapping() {
        // Simulate a formatting error (e.g., buffer overflow)
         let format_err = CommandFormatError::BufferOverflow;

         // Map it
         let sdi12_err: Sdi12Error<()> = format_err.into();

         assert_eq!(sdi12_err, Sdi12Error::CommandFormatFailed(CommandFormatError::BufferOverflow));
     }
}

--- FILE: src/common/command.rs ---
// src/common/command.rs

use super::address::Sdi12Addr;
use core::convert::TryFrom;
use core::fmt::{self, Write}; // Need core::fmt::Write
use arrayvec::ArrayString; // Use ArrayString for formatting

// --- Conditionally import String ---
#[cfg(feature = "alloc")]
use alloc::string::String;

// --- Error Type for Index Validation ---

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum CommandIndexError {
    MeasurementOutOfRange,    // For M/MC/C/CC (1-9)
    ContinuousOutOfRange,     // For R/RC (0-9)
    DataOutOfRange,           // For D/DB (0-999)
    IdentifyParamOutOfRange, // For _nnn (1-999)
}

impl fmt::Display for CommandIndexError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CommandIndexError::MeasurementOutOfRange => write!(f, "Measurement index must be 1-9"),
            CommandIndexError::ContinuousOutOfRange => write!(f, "Continuous index must be 0-9"),
            CommandIndexError::DataOutOfRange => write!(f, "Data index must be 0-999"),
            CommandIndexError::IdentifyParamOutOfRange => write!(f, "Identify Parameter index must be 1-999"),
        }
    }
}

// --- Error Type for Formatting ---
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum CommandFormatError {
    /// The provided buffer was too small.
    BufferOverflow,
    /// A formatting error occurred (e.g., writing number failed).
    FmtError,
}
impl From<core::fmt::Error> for CommandFormatError {
    fn from(_: core::fmt::Error) -> Self { CommandFormatError::FmtError }
}

// Add Display impl to satisfy thiserror constraint (Error E0599)
impl fmt::Display for CommandFormatError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CommandFormatError::BufferOverflow => write!(f, "Buffer overflow during formatting"),
            CommandFormatError::FmtError => write!(f, "Internal formatting error"),
        }
    }
}


// --- Validated Index Types ---

/// Represents the index `n` for M[n], MC[n], C[n], CC[n] commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum MeasurementIndex {
    Base,
    Indexed(u8), // 1-9
}

impl MeasurementIndex {
    pub fn new(index_opt: Option<u8>) -> Result<Self, CommandIndexError> {
        match index_opt {
            None => Ok(Self::Base),
            Some(i) if (1..=9).contains(&i) => Ok(Self::Indexed(i)),
            Some(_) => Err(CommandIndexError::MeasurementOutOfRange),
        }
    }
    pub fn as_option(&self) -> Option<u8> {
        match self { Self::Base => None, Self::Indexed(i) => Some(*i) }
    }
}

/// Represents the index `n` for R[n], RC[n] commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ContinuousIndex(u8); // 0-9

impl ContinuousIndex {
    pub fn new(index: u8) -> Result<Self, CommandIndexError> {
        if index <= 9 { Ok(Self(index)) } else { Err(CommandIndexError::ContinuousOutOfRange) }
    }
    pub fn value(&self) -> u8 { self.0 }
}
impl TryFrom<u8> for ContinuousIndex {
    type Error = CommandIndexError;
    fn try_from(value: u8) -> Result<Self, Self::Error> { Self::new(value) }
}

/// Represents the index `n` for D[n], DB[n] commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct DataIndex(u16); // 0-999

impl DataIndex {
    pub fn new(index: u16) -> Result<Self, CommandIndexError> {
        if index <= 999 { Ok(Self(index)) } else { Err(CommandIndexError::DataOutOfRange) }
    }
    pub fn value(&self) -> u16 { self.0 }
}
impl TryFrom<u16> for DataIndex {
    type Error = CommandIndexError;
    fn try_from(value: u16) -> Result<Self, Self::Error> { Self::new(value) }
}

/// Represents the parameter index `nnn` for Identify Measurement Parameter commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct IdentifyParameterIndex(u16); // 1-999

impl IdentifyParameterIndex {
    pub fn new(index: u16) -> Result<Self, CommandIndexError> {
        if (1..=999).contains(&index) { Ok(Self(index)) } else { Err(CommandIndexError::IdentifyParamOutOfRange) }
    }
    pub fn value(&self) -> u16 { self.0 }
}
impl TryFrom<u16> for IdentifyParameterIndex {
    type Error = CommandIndexError;
    fn try_from(value: u16) -> Result<Self, Self::Error> { Self::new(value) }
}


// --- Main Command Enum ---

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Command {
    AcknowledgeActive { address: Sdi12Addr },
    SendIdentification { address: Sdi12Addr },
    AddressQuery,
    ChangeAddress { address: Sdi12Addr, new_address: Sdi12Addr },
    StartMeasurement { address: Sdi12Addr, index: MeasurementIndex },
    StartMeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
    StartConcurrentMeasurement { address: Sdi12Addr, index: MeasurementIndex },
    StartConcurrentMeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
    SendData { address: Sdi12Addr, index: DataIndex },
    SendBinaryData { address: Sdi12Addr, index: DataIndex },
    ReadContinuous { address: Sdi12Addr, index: ContinuousIndex },
    ReadContinuousCRC { address: Sdi12Addr, index: ContinuousIndex },
    StartVerification { address: Sdi12Addr },
    StartHighVolumeASCII { address: Sdi12Addr },
    StartHighVolumeBinary { address: Sdi12Addr },
    IdentifyMeasurement(IdentifyMeasurementCommand),
    IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand),
    #[cfg(feature = "alloc")]
    ExtendedCommand { address: Sdi12Addr, command_body: String },
    // TODO: Consider adding a non-alloc ExtendedCommand variant using a fixed buffer
    // #[cfg(not(feature = "alloc"))]
    // ExtendedCommandFixed { address: Sdi12Addr, command_body: ArrayString<{MAX_EXT_LEN?}> }, // Fixed type here too
}

impl Command {
    /// Maximum length of the *formatted* standard command string (e.g., "aICC9_999!").
    const MAX_FORMATTED_LEN: usize = 10;

    /// Formats the command into the standard byte sequence.
    pub fn format_into(&self) -> Result<ArrayString<{Self::MAX_FORMATTED_LEN}>, CommandFormatError> {
        // ... (rest of format_into implementation as before) ...
        let mut buffer = ArrayString::<{Self::MAX_FORMATTED_LEN}>::new();

        match self {
            Command::AcknowledgeActive { address } => write!(buffer, "{}!", address)?,
            Command::SendIdentification { address } => write!(buffer, "{}I!", address)?,
            Command::AddressQuery => write!(buffer, "?!")?,
            Command::ChangeAddress { address, new_address } => write!(buffer, "{}A{}!", address, new_address)?,

            Command::StartMeasurement { address, index } => {
                write!(buffer, "{}M", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::StartMeasurementCRC { address, index } => {
                write!(buffer, "{}MC", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::StartConcurrentMeasurement { address, index } => {
                 write!(buffer, "{}C", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::StartConcurrentMeasurementCRC { address, index } => {
                 write!(buffer, "{}CC", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::SendData { address, index } => write!(buffer, "{}D{}!", address, index.value())?,
            Command::SendBinaryData { address, index } => write!(buffer, "{}DB{}!", address, index.value())?,
            Command::ReadContinuous { address, index } => write!(buffer, "{}R{}!", address, index.value())?,
            Command::ReadContinuousCRC { address, index } => write!(buffer, "{}RC{}!", address, index.value())?,
            Command::StartVerification { address } => write!(buffer, "{}V!", address)?,
            Command::StartHighVolumeASCII { address } => write!(buffer, "{}HA!", address)?,
            Command::StartHighVolumeBinary { address } => write!(buffer, "{}HB!", address)?,

            Command::IdentifyMeasurement(cmd) => {
                match cmd {
                    IdentifyMeasurementCommand::Measurement { address, index } => { write!(buffer, "{}IM", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::MeasurementCRC { address, index } => { write!(buffer, "{}IMC", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::Verification { address } => write!(buffer, "{}IV", address)?,
                    IdentifyMeasurementCommand::ConcurrentMeasurement { address, index } => { write!(buffer, "{}IC", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::ConcurrentMeasurementCRC { address, index } => { write!(buffer, "{}ICC", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::HighVolumeASCII { address } => write!(buffer, "{}IHA", address)?,
                    IdentifyMeasurementCommand::HighVolumeBinary { address } => write!(buffer, "{}IHB", address)?,
                }
                write!(buffer, "!")?;
            }
            Command::IdentifyMeasurementParameter(cmd) => {
                match cmd {
                     IdentifyMeasurementParameterCommand::Measurement { address, m_index, param_index } => { write!(buffer, "{}IM", address)?; if let MeasurementIndex::Indexed(i) = m_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::MeasurementCRC { address, m_index, param_index } => { write!(buffer, "{}IMC", address)?; if let MeasurementIndex::Indexed(i) = m_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::Verification { address, param_index } => { write!(buffer, "{}IV_{:03}", address, param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ConcurrentMeasurement { address, c_index, param_index } => { write!(buffer, "{}IC", address)?; if let MeasurementIndex::Indexed(i) = c_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ConcurrentMeasurementCRC { address, c_index, param_index } => { write!(buffer, "{}ICC", address)?; if let MeasurementIndex::Indexed(i) = c_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ReadContinuous { address, r_index, param_index } => { write!(buffer, "{}IR{}_{:03}", address, r_index.value(), param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ReadContinuousCRC { address, r_index, param_index } => { write!(buffer, "{}IRC{}_{:03}", address, r_index.value(), param_index.value())?; }
                     IdentifyMeasurementParameterCommand::HighVolumeASCII { address, param_index } => { write!(buffer, "{}IHA_{:03}", address, param_index.value())?; }
                     IdentifyMeasurementParameterCommand::HighVolumeBinary { address, param_index } => { write!(buffer, "{}IHB_{:03}", address, param_index.value())?; }
                }
                 write!(buffer, "!")?;
            }

            #[cfg(feature = "alloc")]
            Command::ExtendedCommand { address, command_body } => {
                // Write the address first
                write!(buffer, "{}", address)?;

                // Check if there's enough space for the command body AND the trailing '!'
                if buffer.remaining_capacity() < command_body.len() + 1 {
                    return Err(CommandFormatError::BufferOverflow);
                }

                // Write the command body
                buffer.try_push_str(command_body)
                      .map_err(|_| CommandFormatError::BufferOverflow)?;

                // Write the terminator
                buffer.try_push('!')
                      .map_err(|_| CommandFormatError::BufferOverflow)?;
             }
        }
        Ok(buffer)
    }

    /// Returns the address the command is directed to.
    // **** THIS METHOD WAS MISSING - RE-ADDING IT ****
    pub fn address(&self) -> Sdi12Addr {
        match self {
            Command::AcknowledgeActive { address } => *address,
            Command::SendIdentification { address } => *address,
            Command::AddressQuery => Sdi12Addr::QUERY_ADDRESS, // Or panic? Query doesn't have a single target. Returning '?' seems least bad.
            Command::ChangeAddress { address, .. } => *address,
            Command::StartMeasurement { address, .. } => *address,
            Command::StartMeasurementCRC { address, .. } => *address,
            Command::StartConcurrentMeasurement { address, .. } => *address,
            Command::StartConcurrentMeasurementCRC { address, .. } => *address,
            Command::SendData { address, .. } => *address,
            Command::SendBinaryData { address, .. } => *address,
            Command::ReadContinuous { address, .. } => *address,
            Command::ReadContinuousCRC { address, .. } => *address,
            Command::StartVerification { address } => *address,
            Command::StartHighVolumeASCII { address } => *address,
            Command::StartHighVolumeBinary { address } => *address,
            Command::IdentifyMeasurement(cmd) => cmd.address(), // Delegate
            Command::IdentifyMeasurementParameter(cmd) => cmd.address(), // Delegate
            #[cfg(feature = "alloc")]
            Command::ExtendedCommand { address, .. } => *address,
        }
    }
}

// --- Metadata Sub-Enums ---

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum IdentifyMeasurementCommand {
     Measurement { address: Sdi12Addr, index: MeasurementIndex },
     MeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
     Verification { address: Sdi12Addr },
     ConcurrentMeasurement { address: Sdi12Addr, index: MeasurementIndex },
     ConcurrentMeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
     HighVolumeASCII { address: Sdi12Addr },
     HighVolumeBinary { address: Sdi12Addr },
}

// Add address() helper for IdentifyMeasurementCommand
impl IdentifyMeasurementCommand {
     pub fn address(&self) -> Sdi12Addr {
         match self {
             Self::Measurement { address, .. } => *address,
             Self::MeasurementCRC { address, .. } => *address,
             Self::Verification { address } => *address,
             Self::ConcurrentMeasurement { address, .. } => *address,
             Self::ConcurrentMeasurementCRC { address, .. } => *address,
             Self::HighVolumeASCII { address } => *address,
             Self::HighVolumeBinary { address } => *address,
         }
     }
}


#[derive(Debug, Clone, PartialEq, Eq)]
pub enum IdentifyMeasurementParameterCommand {
     Measurement { address: Sdi12Addr, m_index: MeasurementIndex, param_index: IdentifyParameterIndex },
     MeasurementCRC { address: Sdi12Addr, m_index: MeasurementIndex, param_index: IdentifyParameterIndex },
     Verification { address: Sdi12Addr, param_index: IdentifyParameterIndex },
     ConcurrentMeasurement { address: Sdi12Addr, c_index: MeasurementIndex, param_index: IdentifyParameterIndex },
     ConcurrentMeasurementCRC { address: Sdi12Addr, c_index: MeasurementIndex, param_index: IdentifyParameterIndex },
     ReadContinuous { address: Sdi12Addr, r_index: ContinuousIndex, param_index: IdentifyParameterIndex },
     ReadContinuousCRC { address: Sdi12Addr, r_index: ContinuousIndex, param_index: IdentifyParameterIndex },
     HighVolumeASCII { address: Sdi12Addr, param_index: IdentifyParameterIndex },
     HighVolumeBinary { address: Sdi12Addr, param_index: IdentifyParameterIndex },
}

// Add address() helper for IdentifyMeasurementParameterCommand
impl IdentifyMeasurementParameterCommand {
     pub fn address(&self) -> Sdi12Addr {
         match self {
             Self::Measurement { address, .. } => *address,
             Self::MeasurementCRC { address, .. } => *address,
             Self::Verification { address, .. } => *address,
             Self::ConcurrentMeasurement { address, .. } => *address,
             Self::ConcurrentMeasurementCRC { address, .. } => *address,
             Self::ReadContinuous { address, .. } => *address,
             Self::ReadContinuousCRC { address, .. } => *address,
             Self::HighVolumeASCII { address, .. } => *address,
             Self::HighVolumeBinary { address, .. } => *address,
         }
     }
}


// --- Unit Tests ---
// ... (tests remain the same) ...
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::address::Sdi12Addr;

    #[cfg(feature = "alloc")]
    use alloc::string::ToString; // Needed for .to_string() on Command

    fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    #[test]
    fn test_measurement_index_validation() {
        assert!(MeasurementIndex::new(None).is_ok());
        assert!(MeasurementIndex::new(Some(1)).is_ok());
        assert!(MeasurementIndex::new(Some(9)).is_ok());
        assert!(matches!(MeasurementIndex::new(Some(0)), Err(CommandIndexError::MeasurementOutOfRange)));
        assert!(matches!(MeasurementIndex::new(Some(10)), Err(CommandIndexError::MeasurementOutOfRange)));
    }

    #[test]
    fn test_continuous_index_validation() {
        assert!(ContinuousIndex::new(0).is_ok());
        assert!(ContinuousIndex::new(9).is_ok());
        assert!(matches!(ContinuousIndex::new(10), Err(CommandIndexError::ContinuousOutOfRange)));
        assert!(ContinuousIndex::try_from(5).is_ok());
        assert!(ContinuousIndex::try_from(15).is_err());
    }

    #[test]
    fn test_data_index_validation() {
        assert!(DataIndex::new(0).is_ok());
        assert!(DataIndex::new(999).is_ok());
        assert!(matches!(DataIndex::new(1000), Err(CommandIndexError::DataOutOfRange)));
        assert!(DataIndex::try_from(123).is_ok());
        assert!(DataIndex::try_from(1000).is_err());
    }

    #[test]
    fn test_identify_param_index_validation() {
        assert!(IdentifyParameterIndex::new(1).is_ok());
        assert!(IdentifyParameterIndex::new(999).is_ok());
        assert!(matches!(IdentifyParameterIndex::new(0), Err(CommandIndexError::IdentifyParamOutOfRange)));
        assert!(matches!(IdentifyParameterIndex::new(1000), Err(CommandIndexError::IdentifyParamOutOfRange)));
        assert!(IdentifyParameterIndex::try_from(456).is_ok());
        assert!(IdentifyParameterIndex::try_from(1000).is_err());
    }

    #[test]
    fn test_command_construction() {
        let cmd = Command::StartConcurrentMeasurementCRC {
            address: addr('2'),
            index: MeasurementIndex::Indexed(3)
        };
        assert!(matches!(cmd, Command::StartConcurrentMeasurementCRC { .. }));
    }

    #[test]
    fn test_command_formatting_standard() {
        // Basic
        assert_eq!(Command::AcknowledgeActive { address: addr('0') }.format_into().unwrap().as_str(), "0!");
        assert_eq!(Command::SendIdentification { address: addr('1') }.format_into().unwrap().as_str(), "1I!");
        assert_eq!(Command::AddressQuery.format_into().unwrap().as_str(), "?!");
        assert_eq!(Command::ChangeAddress { address: addr('2'), new_address: addr('3') }.format_into().unwrap().as_str(), "2A3!");
        // Measurement
        assert_eq!(Command::StartMeasurement { address: addr('4'), index: MeasurementIndex::Base }.format_into().unwrap().as_str(), "4M!");
        assert_eq!(Command::StartMeasurement { address: addr('5'), index: MeasurementIndex::Indexed(1) }.format_into().unwrap().as_str(), "5M1!");
        assert_eq!(Command::StartMeasurementCRC { address: addr('6'), index: MeasurementIndex::Base }.format_into().unwrap().as_str(), "6MC!");
        assert_eq!(Command::StartMeasurementCRC { address: addr('7'), index: MeasurementIndex::Indexed(9) }.format_into().unwrap().as_str(), "7MC9!");
        // Concurrent
        assert_eq!(Command::StartConcurrentMeasurement { address: addr('8'), index: MeasurementIndex::Base }.format_into().unwrap().as_str(), "8C!");
        assert_eq!(Command::StartConcurrentMeasurement { address: addr('9'), index: MeasurementIndex::Indexed(2) }.format_into().unwrap().as_str(), "9C2!");
        assert_eq!(Command::StartConcurrentMeasurementCRC { address: addr('a'), index: MeasurementIndex::Base }.format_into().unwrap().as_str(), "aCC!");
        assert_eq!(Command::StartConcurrentMeasurementCRC { address: addr('b'), index: MeasurementIndex::Indexed(8) }.format_into().unwrap().as_str(), "bCC8!");
        // Data / Continuous
        assert_eq!(Command::SendData { address: addr('c'), index: DataIndex::new(0).unwrap() }.format_into().unwrap().as_str(), "cD0!");
        assert_eq!(Command::SendData { address: addr('d'), index: DataIndex::new(9).unwrap() }.format_into().unwrap().as_str(), "dD9!");
        assert_eq!(Command::SendData { address: addr('e'), index: DataIndex::new(10).unwrap() }.format_into().unwrap().as_str(), "eD10!");
        assert_eq!(Command::SendData { address: addr('f'), index: DataIndex::new(999).unwrap() }.format_into().unwrap().as_str(), "fD999!");
        assert_eq!(Command::SendBinaryData { address: addr('A'), index: DataIndex::new(123).unwrap() }.format_into().unwrap().as_str(), "ADB123!");
        assert_eq!(Command::ReadContinuous { address: addr('B'), index: ContinuousIndex::new(0).unwrap() }.format_into().unwrap().as_str(), "BR0!");
        assert_eq!(Command::ReadContinuous { address: addr('C'), index: ContinuousIndex::new(9).unwrap() }.format_into().unwrap().as_str(), "CR9!");
        assert_eq!(Command::ReadContinuousCRC { address: addr('D'), index: ContinuousIndex::new(5).unwrap() }.format_into().unwrap().as_str(), "DRC5!");
        // Other Basic
        assert_eq!(Command::StartVerification { address: addr('E') }.format_into().unwrap().as_str(), "EV!");
        // High Volume
        assert_eq!(Command::StartHighVolumeASCII { address: addr('F') }.format_into().unwrap().as_str(), "FHA!");
        assert_eq!(Command::StartHighVolumeBinary { address: addr('G') }.format_into().unwrap().as_str(), "GHB!");
        // Metadata - Identify Measurement
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::Measurement { address: addr('H'), index: MeasurementIndex::Base }).format_into().unwrap().as_str(), "HIM!");
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::MeasurementCRC { address: addr('I'), index: MeasurementIndex::Indexed(3) }).format_into().unwrap().as_str(), "IIMC3!");
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::Verification { address: addr('J') }).format_into().unwrap().as_str(), "JIV!");
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurement { address: addr('K'), index: MeasurementIndex::Indexed(5) }).format_into().unwrap().as_str(), "KIC5!");
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::ConcurrentMeasurementCRC { address: addr('L'), index: MeasurementIndex::Base }).format_into().unwrap().as_str(), "LICC!");
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::HighVolumeASCII { address: addr('M') }).format_into().unwrap().as_str(), "MIHA!");
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::HighVolumeBinary { address: addr('N') }).format_into().unwrap().as_str(), "NIHB!");
        // Metadata - Identify Parameter
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Measurement { address: addr('O'), m_index: MeasurementIndex::Base, param_index: IdentifyParameterIndex::new(1).unwrap() }).format_into().unwrap().as_str(), "OIM_001!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::MeasurementCRC { address: addr('P'), m_index: MeasurementIndex::Indexed(7), param_index: IdentifyParameterIndex::new(12).unwrap() }).format_into().unwrap().as_str(), "PIMC7_012!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Verification { address: addr('Q'), param_index: IdentifyParameterIndex::new(345).unwrap() }).format_into().unwrap().as_str(), "QIV_345!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurement { address: addr('R'), c_index: MeasurementIndex::Indexed(9), param_index: IdentifyParameterIndex::new(999).unwrap() }).format_into().unwrap().as_str(), "RIC9_999!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ConcurrentMeasurementCRC { address: addr('S'), c_index: MeasurementIndex::Base, param_index: IdentifyParameterIndex::new(50).unwrap() }).format_into().unwrap().as_str(), "SICC_050!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuous { address: addr('T'), r_index: ContinuousIndex::new(0).unwrap(), param_index: IdentifyParameterIndex::new(1).unwrap() }).format_into().unwrap().as_str(), "TIR0_001!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::ReadContinuousCRC { address: addr('U'), r_index: ContinuousIndex::new(8).unwrap(), param_index: IdentifyParameterIndex::new(2).unwrap() }).format_into().unwrap().as_str(), "UIRC8_002!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::HighVolumeASCII { address: addr('V'), param_index: IdentifyParameterIndex::new(100).unwrap() }).format_into().unwrap().as_str(), "VIHA_100!");
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::HighVolumeBinary { address: addr('W'), param_index: IdentifyParameterIndex::new(10).unwrap() }).format_into().unwrap().as_str(), "WIHB_010!");
    }

    #[test]
    #[cfg(feature = "alloc")]
    fn test_format_extended_command() {
        let cmd_short = Command::ExtendedCommand { address: addr('X'), command_body: "YZ".to_string() };
        let expected_short = "XYZ!";
        let formatted_short = cmd_short.format_into().unwrap();
        assert_eq!(formatted_short.as_str(), expected_short);

        let cmd_exact = Command::ExtendedCommand { address: addr('A'), command_body: "BCDEFGHI".to_string() };
        let formatted_exact = cmd_exact.format_into().unwrap();
        assert_eq!(formatted_exact.as_str(), "ABCDEFGHI!");

        let cmd_long = Command::ExtendedCommand { address: addr('A'), command_body: "BCDEFGHIJ".to_string() };
        let formatted_long_result = cmd_long.format_into();
        assert!(matches!(formatted_long_result, Err(CommandFormatError::BufferOverflow)));
    }

    #[test]
    fn test_format_error_from_fmt() {
        let fmt_err = core::fmt::Error;
        let cmd_fmt_err: CommandFormatError = fmt_err.into();
        assert_eq!(cmd_fmt_err, CommandFormatError::FmtError);
    }

    // **** ADDED TEST FOR Command::address() ****
    #[test]
    fn test_command_address_method() {
        assert_eq!(Command::AcknowledgeActive{ address: addr('0') }.address(), addr('0'));
        assert_eq!(Command::StartMeasurement{ address: addr('1'), index: MeasurementIndex::Base }.address(), addr('1'));
        assert_eq!(Command::IdentifyMeasurement(IdentifyMeasurementCommand::Verification{ address: addr('A') }).address(), addr('A'));
        assert_eq!(Command::IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand::Verification{ address: addr('B'), param_index: IdentifyParameterIndex::new(1).unwrap() }).address(), addr('B'));
        // Test address query returns the query address char
        assert_eq!(Command::AddressQuery.address(), Sdi12Addr::QUERY_ADDRESS);
    }
}

--- FILE: src/sensor/sync_sensor/mod.rs ---


--- FILE: src/recorder/sync_recorder/transaction.rs ---
// src/recorder/sync_recorder/transaction.rs

use super::SyncRecorder;
use crate::common::{
    command::Command,
    error::Sdi12Error,
    hal_traits::{Sdi12Instant, Sdi12Serial, Sdi12Timer},
    timing, // Needed for retry timing
};
use core::fmt::Debug;
use core::time::Duration; // Needed for retry timing

// Define retry constant
const MAX_TRANSACTION_RETRIES: usize = 3;

impl<IF> SyncRecorder<IF>
where
    IF: Sdi12Serial + Sdi12Timer,
    IF::Error: Debug,
    IF::Instant: Sdi12Instant,
{
    /// Executes a full command-response transaction with retries.
    /// Returns payload start/end indices on success.
    pub(super) fn execute_transaction<'buf>(
        &mut self,
        command: &Command,
        read_buffer: &'buf mut [u8], // Still takes buffer for reading into
    ) -> Result<(usize, usize), Sdi12Error<IF::Error>> { // Return indices

        // 1. Ensure break if needed
        self.check_and_send_break()?;

        // 2. Format command
        let command_buffer = command.format_into()
            .map_err(Sdi12Error::CommandFormatFailed)?;

        let mut last_error: Sdi12Error<IF::Error> = Sdi12Error::Timeout; // Default error if all retries fail

        // 3. Retry Loop
        for attempt in 0..MAX_TRANSACTION_RETRIES {
            // 4. Send Command
            if let Err(e) = self.send_command_bytes(command_buffer.as_bytes()) {
                 // Treat send errors as fatal for now
                 return Err(e);
            }

            // 5. Read Response
            match self.read_response_line(read_buffer) {
                Ok(line_slice) => {
                    // 5a. Process Response Payload
                    // Pass the received slice (which is part of read_buffer)
                    match self.process_response_payload(line_slice, command) {
                        Ok(indices) => { // Successful processing returns indices
                            // Success! Update time and return indices.
                            self.last_activity_time = Some(self.interface.now());
                            return Ok(indices);
                        }
                        // Treat parsing errors as non-retryable for now
                        Err(e @ Sdi12Error::CrcMismatch { .. }) => return Err(e),
                        Err(e @ Sdi12Error::InvalidFormat) => return Err(e),
                        Err(e @ Sdi12Error::UnexpectedResponse) => return Err(e),
                        Err(e @ Sdi12Error::InvalidAddress( _)) => return Err(e),
                        Err(e) => return Err(e), // Propagate other errors
                    }
                }
                // 5b. Handle Read Errors - Timeout/InvalidFormat are retryable
                Err(Sdi12Error::Timeout) => {
                    last_error = Sdi12Error::Timeout;
                    // Continue to retry logic below
                }
                Err(Sdi12Error::InvalidFormat) => { // Treat incomplete read as retryable
                    last_error = Sdi12Error::InvalidFormat;
                     // Continue to retry logic below
                }
                 // Any other error (like Io) is fatal
                Err(e) => return Err(e),
            }

            // 6. Retry Logic (if we didn't return Ok or a fatal Err above)
            if attempt + 1 < MAX_TRANSACTION_RETRIES {
                // Wait slightly more than RETRY_WAIT_MIN (16.67ms)
                self.interface.delay_ms(20);
            } else {
                 // Retries exhausted
                 break;
            }
        } // End retry loop

        // 7. Post-Loop: If we finished the loop, all retries failed
        Err(last_error)
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
     use super::*;
     use crate::common::{
        address::Sdi12Addr,
        command::{Command, MeasurementIndex},
        hal_traits::{Sdi12Serial, Sdi12Timer},
        FrameFormat, Sdi12Error, timing,
        response::PayloadSlice,
    };
    use core::time::Duration;
    use nb::Result as NbResult;
    use nb;

    // --- Mocks ---
    #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
    struct MockInstant(u64);
    impl core::ops::Add<Duration> for MockInstant { /* ... */ type Output = Self; fn add(self, rhs: Duration) -> Self { MockInstant(self.0.saturating_add(rhs.as_micros() as u64)) } }
    impl core::ops::Sub<MockInstant> for MockInstant { /* ... */ type Output = Duration; fn sub(self, rhs: MockInstant) -> Duration { Duration::from_micros(self.0.saturating_sub(rhs.0)) } }
    // MockCommError still needs Clone if Sdi12Error::Io(e) might be used in set_read_error
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct MockCommError;

    // REMOVE derive(Clone) from MockInterface
    struct MockInterface {
        break_sent: bool,
        config: FrameFormat,
        current_time_us: u64,
        read_queue: [Option<u8>; 96],
        read_pos: usize,
        write_log: [Option<u8>; 96],
        write_pos: usize,
        #[cfg(feature = "std")]
        io_call_counts: std::collections::HashMap<&'static str, u32>,
        #[cfg(not(feature = "std"))]
        _marker: core::marker::PhantomData<&'static str>,
        fail_read_after: Option<usize>,
        fail_write_after: Option<usize>,
        // Field type is fine, Sdi12Error itself doesn't need to be Clone
        read_error_type: Option<Sdi12Error<MockCommError>>,
    }
     impl MockInterface { /* ... new(), advance_time(), increment_call_count(), stage_read_data() ... */
         fn new() -> Self {
             MockInterface {
                break_sent: false, config: FrameFormat::Sdi12_7e1,
                current_time_us: 0, read_queue: [None; 96], read_pos: 0,
                write_log: [None; 96], write_pos: 0,
                 #[cfg(feature = "std")]
                 io_call_counts: std::collections::HashMap::new(),
                 #[cfg(not(feature = "std"))]
                 _marker: core::marker::PhantomData,
                 fail_read_after: None, fail_write_after: None, read_error_type: None,
            }
          }
          fn advance_time(&mut self, us: u64) { self.current_time_us = self.current_time_us.saturating_add(us); }
          #[cfg(feature = "std")]
          fn increment_call_count(&mut self, name: &'static str) { *self.io_call_counts.entry(name).or_insert(0) += 1; }
          #[cfg(not(feature = "std"))]
          fn increment_call_count(&mut self, _name: &'static str) {}
          fn stage_read_data(&mut self, data: &[u8]) {
            self.read_pos = 0;
             self.read_queue = [None; 96];
             assert!(data.len() <= self.read_queue.len());
             for (i, byte) in data.iter().enumerate() {
                 self.read_queue[i] = Some(*byte);
             }
           }
          fn set_fail_read_after(&mut self, count: usize) { self.fail_read_after = Some(count); }
          // Accept error by value, store it. MockCommError needs to be Clone if Io variant is used.
          fn set_read_error(&mut self, error: Sdi12Error<MockCommError>) { self.read_error_type = Some(error); }
     }
     impl Sdi12Timer for MockInterface { /* ... */
        type Instant = MockInstant;
        fn delay_us(&mut self, us: u32) { self.advance_time(us as u64); }
        fn delay_ms(&mut self, ms: u32) { self.advance_time((ms as u64) * 1000); }
        fn now(&self) -> Self::Instant { MockInstant(self.current_time_us) }
      }
     impl Sdi12Serial for MockInterface {
         type Error = MockCommError;
        fn read_byte(&mut self) -> NbResult<u8, Self::Error> {
            self.increment_call_count("read_byte");
            #[cfg(feature = "std")]
            let calls = self.io_call_counts.get("read_byte").copied().unwrap_or(0);
            #[cfg(not(feature = "std"))]
            let calls = 0;

            if let Some(fail_count) = self.fail_read_after {
                if calls > fail_count {
                    // REMOVE .cloned() - match on reference, copy error if needed
                    match self.read_error_type.as_ref().unwrap_or(&Sdi12Error::Timeout) {
                        Sdi12Error::Timeout => return Err(nb::Error::WouldBlock),
                        // Copy the MockCommError (it derives Copy)
                        Sdi12Error::Io(e) => return Err(nb::Error::Other(*e)),
                        _ => return Err(nb::Error::WouldBlock),
                    }
                }
            }
             if self.read_pos < self.read_queue.len() { if let Some(byte) = self.read_queue[self.read_pos] { self.read_pos += 1; Ok(byte) } else { Err(nb::Error::WouldBlock) } } else { Err(nb::Error::WouldBlock) }
         }
        fn write_byte(&mut self, byte: u8) -> NbResult<(), Self::Error> { /* ... */
             self.increment_call_count("write_byte");
             if self.write_pos < self.write_log.len() { self.write_log[self.write_pos] = Some(byte); self.write_pos += 1; Ok(()) } else { Err(nb::Error::Other(MockCommError)) }
         }
        fn flush(&mut self) -> NbResult<(), Self::Error> { self.increment_call_count("flush"); Ok(()) }
        fn send_break(&mut self) -> NbResult<(), Self::Error> { self.increment_call_count("send_break"); self.break_sent = true; Ok(()) }
        fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error> { self.increment_call_count("set_config"); self.config = config; Ok(()) }
    }
    fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    #[test]
    fn test_transaction_success_no_retry() { /* ... Test remains the same ... */
         let mut mock_if = MockInterface::new();
         let ack_response = b"0\r\n";
         mock_if.stage_read_data(ack_response);
         let mut recorder = SyncRecorder::new(mock_if);
         let cmd = Command::AcknowledgeActive { address: addr('0') };
         let mut buffer = [0u8; 32];

         let result = recorder.execute_transaction(&cmd, &mut buffer);
         assert!(result.is_ok());
         let (start, end) = result.unwrap();
         assert_eq!(PayloadSlice(&buffer[start..end]).as_bytes(), b"");
         assert!(recorder.interface.break_sent);
         assert_eq!(recorder.interface.write_log[..2], [Some(b'0'), Some(b'!')]);
         assert!(recorder.last_activity_time.is_some());
    }

     #[test]
     #[cfg(feature = "std")]
     //#[ignore] // Keep ignored until timing logic is verified
     fn test_transaction_timeout_with_retries() { /* ... Test remains the same ... */
         let mut mock_if = MockInterface::new();
         mock_if.set_fail_read_after(0);
         // Use Timeout variant which doesn't involve cloning E
         mock_if.set_read_error(Sdi12Error::Timeout);

         let mut recorder = SyncRecorder::new(mock_if);
         let cmd = Command::AcknowledgeActive { address: addr('1') };
         let mut buffer = [0u8; 32];

         let start_time = recorder.interface.now();
         let result = recorder.execute_transaction(&cmd, &mut buffer);
         let end_time = recorder.interface.now();

         assert!(matches!(result, Err(Sdi12Error::Timeout)));

         let cmd_len = cmd.format_into().unwrap().len();
         assert_eq!(recorder.interface.io_call_counts.get("write_byte").unwrap_or(&0), &(cmd_len * MAX_TRANSACTION_RETRIES) as &u32);
         assert!(recorder.interface.io_call_counts.get("read_byte").unwrap_or(&0) > &(MAX_TRANSACTION_RETRIES as u32));

         let expected_min_delay = Duration::from_millis(20) * (MAX_TRANSACTION_RETRIES - 1) as u32;
         assert!(end_time.sub(start_time) >= expected_min_delay);
    }

    #[test]
    fn test_transaction_crc_error_no_retry() {
         let mut mock_if = MockInterface::new();
         let crc_error_response = b"0+12.3XXX\r\n";
         mock_if.stage_read_data(crc_error_response);
         // No longer need to clone mock_if
         let mut recorder = SyncRecorder::new(mock_if);
         let cmd = Command::StartMeasurementCRC { address: addr('0'), index: MeasurementIndex::Base };
         let mut buffer = [0u8; 32];
         let result = recorder.execute_transaction(&cmd, &mut buffer);
         assert!(matches!(result, Err(Sdi12Error::CrcMismatch{..})));

         // Access counts via recorder.interface directly
         #[cfg(feature = "std")]
         {
            assert_eq!(recorder.interface.io_call_counts.get("write_byte").unwrap_or(&0), &(cmd.format_into().unwrap().len()) as &u32);
         }
    }
}

--- FILE: src/common/frame.rs ---
// src/common/frame.rs

/// Represents the serial frame formats used in SDI-12.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum FrameFormat {
    /// Standard SDI-12 format: 1200 baud, 7 data bits, Even parity, 1 stop bit.
    Sdi12_7e1,
    /// Format for High-Volume Binary data: 1200 baud, 8 data bits, No parity, 1 stop bit.
    Binary8N1,
}

