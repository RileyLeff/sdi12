Printing contents of /Users/rileyleff/Documents/dev/try/trysdi12/sdi12 (excluding: target,.git,node_modules)

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/Cargo.lock
=======================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "crc"
version = "3.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69e6e4d7b33a94f0991c26729976b10ebde1d34c3ee82408fb536164fa10d636"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "embedded-hal"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "361a90feb7004eca4019fb28352a9465666b24f840f5c3cddf0ff13920590b89"

[[package]]
name = "embedded-hal-async"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4c685bbef7fe13c3c6dd4da26841ed3980ef33e841cddfa15ce8a8fb3f1884"
dependencies = [
 "embedded-hal",
]

[[package]]
name = "hash32"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47d60b12902ba28e2730cd37e95b8c9223af2808df9e902d4df49588d1470606"
dependencies = [
 "byteorder",
]

[[package]]
name = "heapless"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bfb9eb618601c89945a70e254898da93b13be0388091d42117462b265bb3fad"
dependencies = [
 "hash32",
 "stable_deref_trait",
]

[[package]]
name = "nb"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d5439c4ad607c3c23abf66de8c8bf57ba8adcd1f129e699851a6e43935d339d"

[[package]]
name = "proc-macro2"
version = "1.0.94"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "sdi12"
version = "0.1.0"
dependencies = [
 "arrayvec",
 "crc",
 "embedded-hal",
 "embedded-hal-async",
 "heapless",
 "nb",
 "thiserror",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "syn"
version = "2.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"


=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/Cargo.toml
=======================
[package]
name = "sdi12"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "A Rust library for the SDI-12 communication protocol"
repository = "https://github.com/rileyleff/sdi12-rs"
readme = "README.md"
keywords = ["sdi12", "embedded", "no-std", "sensors", "datalogger"]
categories = ["embedded", "hardware-support", "no-std"]

[dependencies]
crc = { version = "3.2.1", default-features = false }
nb = "1.1.0"

# arrayvec is needed for command formatting, make it non-optional
arrayvec = { version = "0.7.6", default-features = false } # Use 0.7.x, ensure no_std

# Heapless is optional for main library, maybe used for alloc alternatives
heapless = { version = "0.8", optional = true } # Make optional

# For embedded-hal support later
embedded-hal = { version = "1.0.0", optional = true }
embedded-hal-async = { version = "1.0.0", optional = true }
thiserror = { version = "2.0.12", default-features = false }


[dev-dependencies]
# Heapless is needed for tests that check formatting errors
heapless = { version = "0.8" }


[features]
default = [] # no_std by default

# Core features
# Decide if 'alloc' enables 'heapless' use cases within the library, or if they are separate.
# Option 1: alloc enables alloc crate directly
alloc = []
# Option 2: Feature to specifically enable heapless-based alternatives
use_heapless = ["dep:heapless"]
# Option 3: alloc feature also enables heapless (simpler if heapless is the primary no_std collection)
# alloc = ["dep:heapless"]

std = ["alloc", "thiserror/std"] # std usually implies alloc
async = ["dep:embedded-hal-async"] # async requires embedded-hal-async

# Implementation Strategy Features (choose one or more when using the library)
impl-native = ["dep:embedded-hal"] # Native impl requires embedded-hal traits
impl-generic-hal = ["dep:embedded-hal"] # Generic HAL impl also uses embedded-hal
impl-bitbang = ["dep:embedded-hal"] # Bitbang likely needs digital/delay traits from embedded-hal

# Optional: HAL-Specific Native Adapters (Examples)
# impl-adapter-stm32 = ["impl-native", "stm32f4xx-hal"] # Example, needs actual hal dep added too
# impl-adapter-rp2040 = ["impl-native", "rp2040-hal"] # Example

# Note: The async versions of impl-native, impl-generic-hal, impl-bitbang
# would likely also depend on the "async" feature itself.

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/README.md
=======================
# SDI-12 Rust Library (`sdi12-rs`) - Design & Status Report

**Date:** 2025-03-30

## 1. Overview

`sdi12-rs` aims to be a comprehensive, robust, and developer-friendly Rust library for interacting with the SDI-12 (Serial-Digital Interface at 1200 baud) protocol, commonly used for environmental sensors and dataloggers.

The library targets embedded systems (`no_std` by default) but is designed to be usable in `std` environments as well. It provides first-class support for both implementing SDI-12 recorder (datalogger/master) functionality and implementing SDI-12 sensor (slave) firmware. The goal is to abstract the complexities of the SDI-12 protocol (timing, framing, commands, responses, CRC, state management) behind an idiomatic and safe Rust API.

This document outlines the library's goals, design philosophy, architecture, key decisions made during initial development, current status, and future directions.

## 2. Goals & Requirements (Based on Initial Request)

*   **Standard Compliance:** Implement the **SDI-12 Standard Version 1.4** (Feb 20, 2023), including all basic, concurrent, high-volume (ASCII & Binary), and metadata commands/responses.
*   **Target Audience:** Support developers building both **Recorders (Masters)** and **Sensors (Slaves)**.
*   **Environment:** Be `#[no_std]` compatible by default. Provide optional, feature-gated support for `std` and `alloc`.
*   **Concurrency Models:** Offer first-class support for both **synchronous** and **asynchronous** operation patterns.
*   **Hardware Abstraction:** Integrate cleanly with the embedded Rust ecosystem, primarily via `embedded-hal` (v1.0+) traits, but remain hardware-agnostic at its core.
*   **Framework Compatibility:** Be usable with async frameworks like Embassy, but without requiring Embassy as a direct dependency.
*   **Error Handling:** Utilize `thiserror` for robust, specific, and ergonomic error reporting.
*   **Modularity:** Organize code logically into modules for recorder logic, sensor logic, and shared common components.

## 3. Core Design Philosophy

*   **Robustness & Safety:** Leverage Rust's type system to make invalid states unrepresentable where possible (e.g., command indices). Provide strong error handling. Ensure correct protocol implementation according to the standard.
*   **Ergonomics (DX):** Offer intuitive, high-level APIs for both recorder and sensor implementors, abstracting away byte-level protocol details and state machine complexity where appropriate.
*   **Flexibility:** Support the four key use-case quadrants: sync `no_std`, sync `std`, async `no_std`, async `std`. Allow users to choose the implementation strategy that best fits their hardware and constraints (native HAL features, generic HAL, bit-banging).
*   **Portability & Agnosticism:** Decouple the core protocol logic from specific hardware implementations via traits (`Sdi12Serial`, `Sdi12Timer`). The library provides the framework; the user provides the hardware-specific implementation or uses optional adapters.
*   **Maintainability:** Structure the code logically. Use external crates (like `crc`) for well-solved problems where appropriate. Limit the burden of maintaining HAL-specific code *within* the core library by favouring user-provided implementations or optional adapter crates.
*   **Standard Compliance:** Adhere strictly to the timings, formats, and procedures outlined in SDI-12 v1.4.

## 4. Architecture & Modules

The library uses the standard Rust crate structure (`src/lib.rs`) with the following primary modules:

*   **`common/`**: Contains foundational types, traits, and logic shared between recorder and sensor implementations. This is the most developed part so far.
    *   `address.rs`: `Sdi12Addr` struct for validated addresses.
    *   `command.rs`: `Command` enum and validated index types (`MeasurementIndex`, etc.) representing all SDI-12 commands.
    *   `crc.rs`: CRC-16/ARC calculation (using the `crc` crate) and SDI-12 specific ASCII/binary encoding/decoding/verification helpers.
    *   `error.rs`: `Sdi12Error<E>` generic protocol error enum using `thiserror`.
    *   `frame.rs`: `FrameFormat` enum (`Sdi12_7e1`, `Binary8n1`).
    *   `hal_traits.rs`: Defines the core hardware abstraction traits: `Sdi12Timer`, `Sdi12Serial` (sync/nb), `Sdi12SerialAsync` (async), and the `NativeSdi12Uart`/`Async` traits for optimized HAL integration.
    *   `response.rs`: Defines `ResponseParseError`, the `MeasurementTiming` struct, and the `PayloadSlice` wrapper for returning validated raw response payloads. (Note: Parsing detailed response types was deferred).
    *   `timing.rs`: `const Duration` values for all specified protocol timings.
    *   `types.rs`: `Sdi12Value` parsing/representation, `BinaryDataType` enum, `Sdi12ParsingError`.
*   **`recorder/`**: Contains logic for the Recorder (Master/Datalogger) role.
    *   `mod.rs`: Defines `SyncRecorder` and placeholder `AsyncRecorder` structs. Holds implementation logic (currently contains constructor and basic helpers).
*   **`sensor/`**: Contains logic and traits for the Sensor (Slave) role. (Not yet implemented).
    *   Will define the `SensorHandler` trait for user logic.
    *   Will define `SyncSensor` / `AsyncSensor` runner structs.
*   **`implementations/` (Directory)**: (Not yet implemented) Intended to hold optional, feature-gated adapter implementations bridging `embedded-hal` (and potentially other ecosystems like `std` serial) to the library's `hal_traits`.
    *   `native.rs`: `NativeAdapter` using the `NativeSdi12Uart` trait.
    *   `generic_hal.rs`: `GenericHalAdapter` using standard `embedded-hal` traits + pin manipulation.
    *   `bitbang.rs`: `BitbangAdapter`.

## 5. Key Design Decisions & Rationale

*   **`no_std` First with `alloc` Feature:** The library compiles as `#[no_std]` by default. An `alloc` feature flag enables dynamic allocation (`Vec`, `String`), primarily used for convenience in parsing variable-length responses (on the recorder side) or handling extended commands. Users of `no_std` + `alloc` must provide a `#[global_allocator]`. This provides flexibility for various targets.
*   **Sync/Async Separation:** Decided to use distinct structs (`SyncRecorder`, `AsyncRecorder` and similarly `SyncSensor`, `AsyncSensor`) rather than `cfg`-gating methods on a single struct. This provides a cleaner separation of concerns, simplifies trait bounds, and makes the user's choice explicit based on their runtime environment.
*   **Hardware Abstraction Strategy:**
    *   Core logic relies on library-defined traits (`Sdi12Serial`, `Sdi12Timer`).
    *   Users choose their implementation strategy:
        1.  **Native:** Implement the `NativeSdi12Uart` trait for their HAL's UART type if it supports native break/config changes. Use `NativeAdapter`. (Fastest, least abstraction cost).
        2.  **Generic HAL:** Use a library-provided `GenericHalAdapter` (feature-gated) which uses standard `embedded-hal` traits (`Read`, `Write`, `OutputPin`, etc.) and implements break/config via generic pin manipulation. (Good compatibility, relies on pin control traits being available).
        3.  **Bitbang:** Use a library-provided `BitbangAdapter` (feature-gated) relying only on GPIO/Delay traits. (Most compatible, highest CPU cost).
    *   This tiered approach minimizes the need for the library to maintain specific adapters for every HAL, placing the responsibility on the user or optional adapter crates, while providing standard fallbacks.
    *   The tricky parts (`send_break`, `set_config`) are explicitly required by the traits, forcing implementors to address them.
*   **Response Parsing ("Middle Ground"):**
    *   **Initial Decision:** Have the library fully parse responses into structured enums/structs (e.g., `Response::Identification`, `Response::Data`).
    *   **Revised Decision:** Simplify the core library's responsibility. The recorder's transaction methods will handle framing (address, CRC, CRLF) and return the validated inner **payload as a `PayloadSlice(&[u8])`**. The `ResponseParseError` enum covers errors related to this framing/CRC layer.
    *   **Rationale:** Significantly reduces core library complexity, improves `no_alloc` compatibility by default, handles non-standard sensor formats gracefully (user parses the payload), and enables sensor-specific parsing crates.
    *   **Future:** Optional parsing helpers (gated by `alloc`/`heapless` features) can be added later to parse `PayloadSlice` into structured types for user convenience. The `MeasurementTiming` struct *is* parsed by the library as it's a common, simple, fixed format not considered general "payload".
*   **Error Handling:** Using `thiserror` for the generic `Sdi12Error<E>` provides structured protocol/IO errors. `ResponseParseError` handles framing/CRC errors specifically. Command construction uses `Result` via validated index types.
*   **CRC Handling:** Leverages the external, well-tested `crc` crate configured for CRC-16/ARC, ensuring correctness and reducing implementation burden. SDI-12 specific ASCII/binary encoding/decoding helpers are provided.
*   **Sensor Handler API:** Planning a trait-based approach (`SensorHandler`) where users implement methods corresponding to specific SDI-12 actions (e.g., `start_measurement`, `get_identification`). The library's `Sensor` runner handles command parsing, dispatch, state management (e.g., for M->D sequences), and response formatting. Considering a macro helper (`handler_macro!`) as a future DX improvement for defining handlers.
*   **Command Representation:** Uses a main `Command` enum with sub-enums for Metadata commands. Incorporates validated index types (`MeasurementIndex`, etc.) to make invalid command indices unrepresentable after construction.

## 6. Current Implementation Status (2025-03-30)

*   **Crate Structure:** Basic structure (`src/{common, recorder, sensor}`) established.
*   **`common` Module:**
    *   `address.rs`: Implemented and tested.
    *   `command.rs`: Implemented (including validated index types) and tested.
    *   `crc.rs`: Implemented (using `crc` crate) and tested against all spec examples.
    *   `error.rs`: `Sdi12Error` defined using `thiserror`.
    *   `frame.rs`: `FrameFormat` enum defined.
    *   `hal_traits.rs`: `Sdi12Timer`, `Sdi12Serial`, `Sdi12SerialAsync`, `NativeSdi12Uart`, `NativeSdi12UartAsync` traits defined.
    *   `response.rs`: Refactored to "middle ground" approach. Defines `ResponseParseError`, `MeasurementTiming`, `PayloadSlice`. Removed complex `Response` enum and parsing logic from core. Tested basic struct definitions.
    *   `timing.rs`: Implemented and reviewed.
    *   `types.rs`: `Sdi12Value` (with basic parsing), `BinaryDataType`, `Sdi12ParsingError` implemented and tested.
*   **`recorder` Module:**
    *   `mod.rs`: `SyncRecorder` struct defined with `new` constructor. Basic `execute_blocking_io` helper implemented (without timeout). Placeholder `acknowledge` method added. Placeholder for `AsyncRecorder`. Basic tests for structure and helper pass.
*   **Features:** `alloc`, `async`, `impl-native` features defined in `Cargo.toml`. Conditional compilation attributes (`#[cfg(...)]`) used. Builds and tests pass for both default (`no_std`, no features) and `--features alloc`.
*   **Dependencies:** `thiserror`, `crc`, `nb`, `embedded-hal` (optional), `embedded-hal-async` (optional) added.

## 7. Remaining Core Implementation ("Minimum Viable Product")

*   **`recorder::SyncRecorder` Helpers:**
    *   Implement command formatting (e.g., `fn format_command(cmd: &Command) -> Result<ArrayVec<u8, N>, _>`). Needs a fixed-size buffer (e.g., from `arrayvec` or `heapless`) or stack allocation.
    *   Implement `check_and_send_break` (requires adding timing state).
    *   Implement `send_command_bytes`.
    *   Implement `read_response_line` (crucially needs timeout logic integrated with `execute_blocking_io` or similar).
    *   Implement `process_response_payload` (address checking, CRC verification using `crc.rs`).
    *   Implement `execute_transaction` using the above helpers, including retry logic (Sec 7.2).
*   **`recorder::SyncRecorder` Public Methods:** Implement the main action methods (`identify`, `change_address`, `start_measurement`, `send_data`, etc.) using `execute_transaction`. Define appropriate return types (e.g., `Result<MeasurementTiming, _>`, `Result<PayloadSlice, _>`, `Result<Sdi12Addr, _>`).
*   **`sensor::SensorHandler` Trait:** Finalize the trait definition based on the chosen philosophy (action-methods, specific return types like `MeasurementStartResult`).
*   **`sensor::SyncSensor`:** Implement the sensor runner struct and its `listen_and_respond` logic (parsing commands, calling handler methods, formatting responses based on handler results, managing protocol state).
*   **Adapters (Minimal):** Implement at least the `NativeAdapter` (`implementations/native.rs`) to allow usage with HALs where the user implements `NativeSdi12Uart`. Consider a basic `GenericHalAdapter` foundation.
*   **Basic Examples:** Create simple examples demonstrating recorder and sensor usage (e.g., a loopback test).

## 8. Future Directions & Improvements

*   **Async Implementation:** Fully implement `AsyncRecorder`, `AsyncSensor`, and async adapters (`Sdi12SerialAsync`, etc.).
*   **`heapless` Support:** Add a `heapless` feature flag. Provide alternative `no_alloc` structs using `heapless::String`/`Vec`. Provide `heapless`-based parsing helpers.
*   **Parsing Helpers:** Implement the optional `alloc`/`heapless` helper functions for parsing common payload types (`IdentificationInfo`, `DataInfo`, `MetadataInfo`, etc.) from `PayloadSlice`.
*   **Sensor Handler Macro:** Implement the `handler_macro!` to simplify defining `SensorHandler` implementations.
*   **More Adapters:** Provide more feature-gated adapter implementations for popular `embedded-hal` families (STM32, RP2040, ESP-HAL, etc.), potentially including native break/config optimizations where possible. Implement `std` adapters (using `serialport`, `tokio-serial`).
*   **Documentation:** Add comprehensive documentation (`#![forbid(missing_docs)]`), including usage examples for different platforms and configurations.
*   **Examples:** Create more extensive examples for real-world scenarios (Embassy, RTIC, `std`).
*   **Timeout Configuration:** Allow users to configure timeout durations.
*   **Performance Optimization:** Profile and optimize critical code paths.
*   **Testing:** Add integration tests, tests on real hardware. Test race conditions in async code.

## 9. Conclusion

The `sdi12-rs` library has a well-defined set of goals and a flexible, hardware-agnostic architecture based on traits and feature-gated implementations. The `common` module, providing foundational types and utilities, is largely complete and tested. Key design decisions regarding sync/async support, hardware abstraction, and response parsing have been made to balance usability, flexibility, and maintainability. The immediate next steps involve implementing the core transaction logic within the `SyncRecorder` and subsequently the `Sensor` runner, building upon the established common infrastructure. Future work will focus on async support, optional parsing helpers, and broader adapter/example coverage.

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/my_code_dump.txt
=======================
=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/Cargo.lock
=======================
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "crc"
version = "3.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69e6e4d7b33a94f0991c26729976b10ebde1d34c3ee82408fb536164fa10d636"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "embedded-hal"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "361a90feb7004eca4019fb28352a9465666b24f840f5c3cddf0ff13920590b89"

[[package]]
name = "embedded-hal-async"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4c685bbef7fe13c3c6dd4da26841ed3980ef33e841cddfa15ce8a8fb3f1884"
dependencies = [
 "embedded-hal",
]

[[package]]
name = "nb"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d5439c4ad607c3c23abf66de8c8bf57ba8adcd1f129e699851a6e43935d339d"

[[package]]
name = "proc-macro2"
version = "1.0.94"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "sdi12"
version = "0.1.0"
dependencies = [
 "arrayvec",
 "crc",
 "embedded-hal",
 "embedded-hal-async",
 "nb",
 "thiserror",
]

[[package]]
name = "syn"
version = "2.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"


=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/Cargo.toml
=======================
[package]
name = "sdi12"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "A Rust library for the SDI-12 communication protocol"
repository = "https://github.com/rileyleff/sdi12-rs"
readme = "README.md"
keywords = ["sdi12", "embedded", "no-std", "sensors", "datalogger"]
categories = ["embedded", "hardware-support", "no-std"]

[dependencies]
crc = { version = "3.2.1", default-features = false }
nb = "1.1.0"
# thiserror is now a mandatory dependency
# default-features = false ensures its 'std' feature is off by default
thiserror = { version = ">1.0", default-features = false }

# Add heapless later if needed for no-std collections
# heapless = { version = "0.8", optional = true }

# For embedded-hal support later
embedded-hal = { version = "1.0.0", optional = true }
embedded-hal-async = { version = "1.0.0", optional = true }
arrayvec = "0.7.6"

[features]
default = [] # no_std by default

# Core features
alloc = []
std = ["alloc", "thiserror/std"]
async = ["dep:embedded-hal-async"] # async requires embedded-hal-async

# Implementation Strategy Features (choose one or more when using the library)
impl-native = ["dep:embedded-hal"] # Native impl requires embedded-hal traits
impl-generic-hal = ["dep:embedded-hal"] # Generic HAL impl also uses embedded-hal
impl-bitbang = ["dep:embedded-hal"] # Bitbang likely needs digital/delay traits from embedded-hal

# Optional: HAL-Specific Native Adapters (Examples)
# impl-adapter-stm32 = ["impl-native", "stm32f4xx-hal"] # Example, needs actual hal dep added too
# impl-adapter-rp2040 = ["impl-native", "rp2040-hal"] # Example

# Note: The async versions of impl-native, impl-generic-hal, impl-bitbang
# would likely also depend on the "async" feature itself.

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/README.md
=======================
# SDI-12 Rust Library (`sdi12-rs`) - Design & Status Report

**Date:** 2025-03-30

## 1. Overview

`sdi12-rs` aims to be a comprehensive, robust, and developer-friendly Rust library for interacting with the SDI-12 (Serial-Digital Interface at 1200 baud) protocol, commonly used for environmental sensors and dataloggers.

The library targets embedded systems (`no_std` by default) but is designed to be usable in `std` environments as well. It provides first-class support for both implementing SDI-12 recorder (datalogger/master) functionality and implementing SDI-12 sensor (slave) firmware. The goal is to abstract the complexities of the SDI-12 protocol (timing, framing, commands, responses, CRC, state management) behind an idiomatic and safe Rust API.

This document outlines the library's goals, design philosophy, architecture, key decisions made during initial development, current status, and future directions.

## 2. Goals & Requirements (Based on Initial Request)

*   **Standard Compliance:** Implement the **SDI-12 Standard Version 1.4** (Feb 20, 2023), including all basic, concurrent, high-volume (ASCII & Binary), and metadata commands/responses.
*   **Target Audience:** Support developers building both **Recorders (Masters)** and **Sensors (Slaves)**.
*   **Environment:** Be `#[no_std]` compatible by default. Provide optional, feature-gated support for `std` and `alloc`.
*   **Concurrency Models:** Offer first-class support for both **synchronous** and **asynchronous** operation patterns.
*   **Hardware Abstraction:** Integrate cleanly with the embedded Rust ecosystem, primarily via `embedded-hal` (v1.0+) traits, but remain hardware-agnostic at its core.
*   **Framework Compatibility:** Be usable with async frameworks like Embassy, but without requiring Embassy as a direct dependency.
*   **Error Handling:** Utilize `thiserror` for robust, specific, and ergonomic error reporting.
*   **Modularity:** Organize code logically into modules for recorder logic, sensor logic, and shared common components.

## 3. Core Design Philosophy

*   **Robustness & Safety:** Leverage Rust's type system to make invalid states unrepresentable where possible (e.g., command indices). Provide strong error handling. Ensure correct protocol implementation according to the standard.
*   **Ergonomics (DX):** Offer intuitive, high-level APIs for both recorder and sensor implementors, abstracting away byte-level protocol details and state machine complexity where appropriate.
*   **Flexibility:** Support the four key use-case quadrants: sync `no_std`, sync `std`, async `no_std`, async `std`. Allow users to choose the implementation strategy that best fits their hardware and constraints (native HAL features, generic HAL, bit-banging).
*   **Portability & Agnosticism:** Decouple the core protocol logic from specific hardware implementations via traits (`Sdi12Serial`, `Sdi12Timer`). The library provides the framework; the user provides the hardware-specific implementation or uses optional adapters.
*   **Maintainability:** Structure the code logically. Use external crates (like `crc`) for well-solved problems where appropriate. Limit the burden of maintaining HAL-specific code *within* the core library by favouring user-provided implementations or optional adapter crates.
*   **Standard Compliance:** Adhere strictly to the timings, formats, and procedures outlined in SDI-12 v1.4.

## 4. Architecture & Modules

The library uses the standard Rust crate structure (`src/lib.rs`) with the following primary modules:

*   **`common/`**: Contains foundational types, traits, and logic shared between recorder and sensor implementations. This is the most developed part so far.
    *   `address.rs`: `Sdi12Addr` struct for validated addresses.
    *   `command.rs`: `Command` enum and validated index types (`MeasurementIndex`, etc.) representing all SDI-12 commands.
    *   `crc.rs`: CRC-16/ARC calculation (using the `crc` crate) and SDI-12 specific ASCII/binary encoding/decoding/verification helpers.
    *   `error.rs`: `Sdi12Error<E>` generic protocol error enum using `thiserror`.
    *   `frame.rs`: `FrameFormat` enum (`Sdi12_7e1`, `Binary8n1`).
    *   `hal_traits.rs`: Defines the core hardware abstraction traits: `Sdi12Timer`, `Sdi12Serial` (sync/nb), `Sdi12SerialAsync` (async), and the `NativeSdi12Uart`/`Async` traits for optimized HAL integration.
    *   `response.rs`: Defines `ResponseParseError`, the `MeasurementTiming` struct, and the `PayloadSlice` wrapper for returning validated raw response payloads. (Note: Parsing detailed response types was deferred).
    *   `timing.rs`: `const Duration` values for all specified protocol timings.
    *   `types.rs`: `Sdi12Value` parsing/representation, `BinaryDataType` enum, `Sdi12ParsingError`.
*   **`recorder/`**: Contains logic for the Recorder (Master/Datalogger) role.
    *   `mod.rs`: Defines `SyncRecorder` and placeholder `AsyncRecorder` structs. Holds implementation logic (currently contains constructor and basic helpers).
*   **`sensor/`**: Contains logic and traits for the Sensor (Slave) role. (Not yet implemented).
    *   Will define the `SensorHandler` trait for user logic.
    *   Will define `SyncSensor` / `AsyncSensor` runner structs.
*   **`implementations/` (Directory)**: (Not yet implemented) Intended to hold optional, feature-gated adapter implementations bridging `embedded-hal` (and potentially other ecosystems like `std` serial) to the library's `hal_traits`.
    *   `native.rs`: `NativeAdapter` using the `NativeSdi12Uart` trait.
    *   `generic_hal.rs`: `GenericHalAdapter` using standard `embedded-hal` traits + pin manipulation.
    *   `bitbang.rs`: `BitbangAdapter`.

## 5. Key Design Decisions & Rationale

*   **`no_std` First with `alloc` Feature:** The library compiles as `#[no_std]` by default. An `alloc` feature flag enables dynamic allocation (`Vec`, `String`), primarily used for convenience in parsing variable-length responses (on the recorder side) or handling extended commands. Users of `no_std` + `alloc` must provide a `#[global_allocator]`. This provides flexibility for various targets.
*   **Sync/Async Separation:** Decided to use distinct structs (`SyncRecorder`, `AsyncRecorder` and similarly `SyncSensor`, `AsyncSensor`) rather than `cfg`-gating methods on a single struct. This provides a cleaner separation of concerns, simplifies trait bounds, and makes the user's choice explicit based on their runtime environment.
*   **Hardware Abstraction Strategy:**
    *   Core logic relies on library-defined traits (`Sdi12Serial`, `Sdi12Timer`).
    *   Users choose their implementation strategy:
        1.  **Native:** Implement the `NativeSdi12Uart` trait for their HAL's UART type if it supports native break/config changes. Use `NativeAdapter`. (Fastest, least abstraction cost).
        2.  **Generic HAL:** Use a library-provided `GenericHalAdapter` (feature-gated) which uses standard `embedded-hal` traits (`Read`, `Write`, `OutputPin`, etc.) and implements break/config via generic pin manipulation. (Good compatibility, relies on pin control traits being available).
        3.  **Bitbang:** Use a library-provided `BitbangAdapter` (feature-gated) relying only on GPIO/Delay traits. (Most compatible, highest CPU cost).
    *   This tiered approach minimizes the need for the library to maintain specific adapters for every HAL, placing the responsibility on the user or optional adapter crates, while providing standard fallbacks.
    *   The tricky parts (`send_break`, `set_config`) are explicitly required by the traits, forcing implementors to address them.
*   **Response Parsing ("Middle Ground"):**
    *   **Initial Decision:** Have the library fully parse responses into structured enums/structs (e.g., `Response::Identification`, `Response::Data`).
    *   **Revised Decision:** Simplify the core library's responsibility. The recorder's transaction methods will handle framing (address, CRC, CRLF) and return the validated inner **payload as a `PayloadSlice(&[u8])`**. The `ResponseParseError` enum covers errors related to this framing/CRC layer.
    *   **Rationale:** Significantly reduces core library complexity, improves `no_alloc` compatibility by default, handles non-standard sensor formats gracefully (user parses the payload), and enables sensor-specific parsing crates.
    *   **Future:** Optional parsing helpers (gated by `alloc`/`heapless` features) can be added later to parse `PayloadSlice` into structured types for user convenience. The `MeasurementTiming` struct *is* parsed by the library as it's a common, simple, fixed format not considered general "payload".
*   **Error Handling:** Using `thiserror` for the generic `Sdi12Error<E>` provides structured protocol/IO errors. `ResponseParseError` handles framing/CRC errors specifically. Command construction uses `Result` via validated index types.
*   **CRC Handling:** Leverages the external, well-tested `crc` crate configured for CRC-16/ARC, ensuring correctness and reducing implementation burden. SDI-12 specific ASCII/binary encoding/decoding helpers are provided.
*   **Sensor Handler API:** Planning a trait-based approach (`SensorHandler`) where users implement methods corresponding to specific SDI-12 actions (e.g., `start_measurement`, `get_identification`). The library's `Sensor` runner handles command parsing, dispatch, state management (e.g., for M->D sequences), and response formatting. Considering a macro helper (`handler_macro!`) as a future DX improvement for defining handlers.
*   **Command Representation:** Uses a main `Command` enum with sub-enums for Metadata commands. Incorporates validated index types (`MeasurementIndex`, etc.) to make invalid command indices unrepresentable after construction.

## 6. Current Implementation Status (2025-03-30)

*   **Crate Structure:** Basic structure (`src/{common, recorder, sensor}`) established.
*   **`common` Module:**
    *   `address.rs`: Implemented and tested.
    *   `command.rs`: Implemented (including validated index types) and tested.
    *   `crc.rs`: Implemented (using `crc` crate) and tested against all spec examples.
    *   `error.rs`: `Sdi12Error` defined using `thiserror`.
    *   `frame.rs`: `FrameFormat` enum defined.
    *   `hal_traits.rs`: `Sdi12Timer`, `Sdi12Serial`, `Sdi12SerialAsync`, `NativeSdi12Uart`, `NativeSdi12UartAsync` traits defined.
    *   `response.rs`: Refactored to "middle ground" approach. Defines `ResponseParseError`, `MeasurementTiming`, `PayloadSlice`. Removed complex `Response` enum and parsing logic from core. Tested basic struct definitions.
    *   `timing.rs`: Implemented and reviewed.
    *   `types.rs`: `Sdi12Value` (with basic parsing), `BinaryDataType`, `Sdi12ParsingError` implemented and tested.
*   **`recorder` Module:**
    *   `mod.rs`: `SyncRecorder` struct defined with `new` constructor. Basic `execute_blocking_io` helper implemented (without timeout). Placeholder `acknowledge` method added. Placeholder for `AsyncRecorder`. Basic tests for structure and helper pass.
*   **Features:** `alloc`, `async`, `impl-native` features defined in `Cargo.toml`. Conditional compilation attributes (`#[cfg(...)]`) used. Builds and tests pass for both default (`no_std`, no features) and `--features alloc`.
*   **Dependencies:** `thiserror`, `crc`, `nb`, `embedded-hal` (optional), `embedded-hal-async` (optional) added.

## 7. Remaining Core Implementation ("Minimum Viable Product")

*   **`recorder::SyncRecorder` Helpers:**
    *   Implement command formatting (e.g., `fn format_command(cmd: &Command) -> Result<ArrayVec<u8, N>, _>`). Needs a fixed-size buffer (e.g., from `arrayvec` or `heapless`) or stack allocation.
    *   Implement `check_and_send_break` (requires adding timing state).
    *   Implement `send_command_bytes`.
    *   Implement `read_response_line` (crucially needs timeout logic integrated with `execute_blocking_io` or similar).
    *   Implement `process_response_payload` (address checking, CRC verification using `crc.rs`).
    *   Implement `execute_transaction` using the above helpers, including retry logic (Sec 7.2).
*   **`recorder::SyncRecorder` Public Methods:** Implement the main action methods (`identify`, `change_address`, `start_measurement`, `send_data`, etc.) using `execute_transaction`. Define appropriate return types (e.g., `Result<MeasurementTiming, _>`, `Result<PayloadSlice, _>`, `Result<Sdi12Addr, _>`).
*   **`sensor::SensorHandler` Trait:** Finalize the trait definition based on the chosen philosophy (action-methods, specific return types like `MeasurementStartResult`).
*   **`sensor::SyncSensor`:** Implement the sensor runner struct and its `listen_and_respond` logic (parsing commands, calling handler methods, formatting responses based on handler results, managing protocol state).
*   **Adapters (Minimal):** Implement at least the `NativeAdapter` (`implementations/native.rs`) to allow usage with HALs where the user implements `NativeSdi12Uart`. Consider a basic `GenericHalAdapter` foundation.
*   **Basic Examples:** Create simple examples demonstrating recorder and sensor usage (e.g., a loopback test).

## 8. Future Directions & Improvements

*   **Async Implementation:** Fully implement `AsyncRecorder`, `AsyncSensor`, and async adapters (`Sdi12SerialAsync`, etc.).
*   **`heapless` Support:** Add a `heapless` feature flag. Provide alternative `no_alloc` structs using `heapless::String`/`Vec`. Provide `heapless`-based parsing helpers.
*   **Parsing Helpers:** Implement the optional `alloc`/`heapless` helper functions for parsing common payload types (`IdentificationInfo`, `DataInfo`, `MetadataInfo`, etc.) from `PayloadSlice`.
*   **Sensor Handler Macro:** Implement the `handler_macro!` to simplify defining `SensorHandler` implementations.
*   **More Adapters:** Provide more feature-gated adapter implementations for popular `embedded-hal` families (STM32, RP2040, ESP-HAL, etc.), potentially including native break/config optimizations where possible. Implement `std` adapters (using `serialport`, `tokio-serial`).
*   **Documentation:** Add comprehensive documentation (`#![forbid(missing_docs)]`), including usage examples for different platforms and configurations.
*   **Examples:** Create more extensive examples for real-world scenarios (Embassy, RTIC, `std`).
*   **Timeout Configuration:** Allow users to configure timeout durations.
*   **Performance Optimization:** Profile and optimize critical code paths.
*   **Testing:** Add integration tests, tests on real hardware. Test race conditions in async code.

## 9. Conclusion

The `sdi12-rs` library has a well-defined set of goals and a flexible, hardware-agnostic architecture based on traits and feature-gated implementations. The `common` module, providing foundational types and utilities, is largely complete and tested. Key design decisions regarding sync/async support, hardware abstraction, and response parsing have been made to balance usability, flexibility, and maintainability. The immediate next steps involve implementing the core transaction logic within the `SyncRecorder` and subsequently the `Sensor` runner, building upon the established common infrastructure. Future work will focus on async support, optional parsing helpers, and broader adapter/example coverage.

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/sdi12.txt
=======================
SDI-12
A Serial-Digital Interface Standard
for
Microprocessor-Based Sensors
Version 1.4

February 20, 2023

Prepared By
SDI-12 Support Group
(Technical Committee)
165 East 500 South
River Heights, Utah
435-752-4200
435-752-1691 (FAX)
www.sdi-12.org

SDI-12 is not currently registered by any professional society, standards organization, or Government agency. Document
copies, current document status, and other information can be obtained by contacting the SDI-12 Support Group at 165 East
500 South, River Heights, Utah 84321, 435-752-4200, FAX 435-752-1691.

TABLE OF CONTENTS

1.0 INTRODUCTION....................................................................................................................1
2.0 ADVANTAGES OF SDI-12 ....................................................................................................1
3.0 SDI-12 ELECTRICAL INTERFACE....................................................................................2
3.1 Serial Data Line .............................................................................................................3
3.1.1 Voltage Transitions .........................................................................................3
3.1.2 Impedance .......................................................................................................3
3.2 Ground Line ...................................................................................................................4
3.2.1 Transient Protection ........................................................................................4
3.3 12-Volt Line ...................................................................................................................4
3.4 Connectors .....................................................................................................................5
4.0 SDI-12 COMMUNICATIONS PROTOCOL........................................................................5
4.1 Baud Rate and Byte Frame Format ................................................................................6
4.2 Allowable Characters .....................................................................................................6
4.3 Device Addresses ...........................................................................................................6
4.4 SDI-12 Commands and Responses ................................................................................7
4.4.1 Acknowledge Active Command (a!) ..............................................................9
4.4.1.1 Examples of the Acknowledge Active Command (a!) ..................9
4.4.2 Send Identification Command (aI!) ................................................................9
4.4.2.1 Example of the Send Identification Command ............................10
4.4.3 Address Query Command (?!) ......................................................................10
4.4.4 Change Address Command (aAb!) ...............................................................11
4.4.5 Start Measurement Command (aM!) ............................................................11
4.4.5.1 Aborting a Measurement ..............................................................12
4.4.6 Service Request .............................................................................................13

2/20/2023 Version 1.4

ii

4.4.7 Start Concurrent Measurement Command....................................................13
4.4.7.1 Aborting a Concurrent Measurement ...........................................14
4.4.8 Send Data Command (aD0! ... aD9!) ............................................................14
4.4.8.1 Continuous Measurements (aR0! ... aR9!) .................................. 16
4.4.8.2 Example of the aR0! Command .................................................. 16
4.4.8.3 Return of Multiple Measurements (Parameters) by a Sensor (D1!
… D9!) .....................................................................................................16
4.4.8.4 Examples of the Start Measurement Command (aM!) and the
Send Data Commands ..............................................................................17
4.4.8.5 Example of the Concurrent Measurement Command (aC!) and the
Send Data Command (aD0!) ................................................................... 18
4.4.9 Additional Measurement Commands (aM1! . . . aM9!) ...............................18
4.4.9.1 Examples of the Additional M Commands (aMn!) ......................19
4.4.10 Additional Concurrent Measurement Commands (aC1! … aC9!) .............19
4.4.11 Start Verification (aV!) ...............................................................................19
4.4.11.1 Examples of the Start Verification Command (aV!) ..................20
4.4.12 Requesting a Cyclic Redundancy Check ....................................................20
4.4.12.1 CRC-16 Computation.................................................................20
4.4.12.2 Encoding the CRC as ASCII Characters ....................................21
4.4.12.3 Examples of the CRC-16 Start Measurement Command (aMC!)
and the Send Data Command .................................................................. 21
4.4.13 Extended Commands ..................................................................................22
4.4.13.1 Extended Commands Returning Multiple Lines of Text .............23

4.4.14 Transparent Mode .......................................................................................24

2/20/2023 Version 1.4

iii

5.0 HIGH-VOLUME COMMANDS ......................................................................................... 24
5.1 Start High-Volume ASCII Measurement.....................................................................24
5.1.1 Example of High-Volume ASCII Measurement.......................................................25
5.2 Start High-Volume Binary Measurement ....................................................................26
5.2.1 High-Volume Binary Data Types .....................................................27
5.2.2 Example of High-Volume Binary Command .................................. 28
5.3 Concurrency of High-Volume Commands ................................................................. 29
5.4 Compliance with High-Volume Commands ............................................................... 29
6.0 METADATA COMMANDS .................................................................................................29
6.1 Identify Measurement Commands ...............................................................................29
6.1.1 Examples of the Identify Measurement Commands .........................30
6.2 Identify Measurement Parameter Commands ..............................................................30
6.2.1 Field One ...........................................................................................31
6.2.2 Field Two ..........................................................................................31
6.2.3 Optional Fields ..................................................................................31
6.2.4 Examples of the Identify Measurement Parameter Commands ........33
6.3 Compliance with Metadata Commands .......................................................................33
7.0 SDI-12 Timing ........................................................................................................................34
7.1 Rules for the Break ......................................................................................................35
7.2 Retries ..........................................................................................................................36

2/20/2023 Version 1.4

iv

APPENDICES ..............................................................................................................................37
Appendix A:
Appendix B:
Appendix C:
Appendix D:

2/20/2023 Version 1.4

Suggested SDI-12 Circuits .................................................................... A-1
Suggested SDI-12 Flow Control for SDI-12 Data Recorders ................B-1
& SDI-12 Sensors...................................................................................B-2
SDI-12 Glossary .....................................................................................C-1
Revisions ............................................................................................... D-1

v

LIST OF TABLES

Table 1. Logic and Voltage Levels for Serial Data .......................................................................3
Table 2. SDI-12 Byte Frame Format .............................................................................................6
Table 3. Printable Characters .........................................................................................................6
Table 4. Sensor Address Codes .....................................................................................................7
Table 5. The SDI-12 Basic Command/Response Set ....................................................................8
Table 6. The Acknowledge Active Command (a!) ........................................................................9
Table 7. The Send Identification Command (aI!) ........................................................................10
Table 8. The Change Address Command (aAb!) ........................................................................11
Table 9. The Start Measurement Command (aM!) ......................................................................11
Table 10. The Start Concurrent Measurement Command (aC!) ....................................................14
Table 11. The Send Data Command (aD0!, aD1 . . . aD9!) ...........................................................15
Table 12. High-Volume ASCII Measurement ...............................................................................24
Table 13. High-Volume Binary Measurement...............................................................................25
Table 14. Data Packet ....................................................................................................................26
Table 15. Empty Data Packet.........................................................................................................26
Table 16. Data Types .....................................................................................................................27
Table 17. Data Values in High-Volume Binary Command Example ............................................28
Table 18. Data Packet Examples ...................................................................................................28
Table 19. The Identify Measurement Commands................................................................ 29 & 30
Table 20. The Identify Measurement Parameter Commands .............................................. 32 & 33

2/20/2023 Version 1.4

vi

LIST OF FIGURES

Figure 1. The SDI-12 Bus ................................................................................................................. 3
Figure 2. Equivalent Circuit.............................................................................................................. 4
Figure 3. SDI-12 Timing................................................................................................................. 34

2/20/2023 Version 1.4

vii

SDI-12
A SERIAL-DIGITAL INTERFACE STANDARD
FOR MICROPROCESSOR-BASED SENSORS
SDI-12 Version 1.4

1.0 INTRODUCTION
This document describes Version 1.4 of the SDI-12 standard. Version 1.4 is an upgrade
from Version 1.3, dated January 28, 2016. The purpose of this document is to describe SDI-12 in
detail and to provide examples of all SDI-12 commands and responses. (See appendix D for a list
of upgrades made since Version 1.0.)
SDI-12 is a standard for interfacing data recorders with microprocessor-based sensors.
SDI-12 stands for serial/digital interface at 1200 baud. This document describes the electrical
interface, the communications protocol, and the timing requirements for SDI-12 data recorders
and SDI-12 sensors.
SDI-12 is intended for applications with the following requirements:
• Battery powered operation with minimal current drain
• Low system cost
• Use of a single data recorder with multiple sensors on one cable (see section 3.0
for details)
2.0 ADVANTAGES OF SDI-12
A serial-digital interface is a logical choice for interfacing microprocessor-based sensors
with a data recorder. This has advantages for sensors and data recorders.
• Unique and complex self-calibration algorithms can be done in
microprocessor-based sensors.
• Sensors can be interchanged without reprogramming the data recorder with
calibration or other information.
• Power is supplied to sensors through the interface.
• Hybrid circuit and surface mount technologies make it practical to include the
power supply regulator, a microprocessor, and other needed circuitry in small
sensor packages.
2/20/2023 Version 1.4

1

• Sensors can use low cost EEPROMs (electrically erasable programmable read
only memory) for calibration coefficients and other information instead of internal
trimming operations.
• The use of a standard serial interface eliminates significant complexity in the
design of data recorders.
• Data recorders can be designed and produced independently of future sensor
development.
• SDI-12 data recorders interface with a variety of sensors.
• SDI-12 sensors interface with a variety of data recorders.
• Personnel trained in SDI-12 will have skills to work with a variety of SDI-12
data recorders and SDI-12 sensors.
• SDI-12 sensors with the most recent version of SDI-12 will work with data
recorders using earlier versions of SDI-12 and vice versa.

3.0 SDI-12 ELECTRICAL INTERFACE
The SDI-12 electrical interface uses the SDI-12 bus to transmit serial data between
SDI-12 data recorders and sensors. The SDI-12 bus is the cable that connects multiple SDI-12
devices. This is a cable with three conductors:
1) a serial data line
2) a ground line
3) a 12-volt line
In the following specifications, all values not indicating specific limits, have an allowable
tolerance of ±10% of the value.
Figure 1 shows the SDI-12 bus connecting one data recorder with two sensors. The
SDI-12 bus is capable of having at least 10 sensors connected to it, each with 200 feet of cable.
With fewer sensors, longer cable lengths are possible.

2/20/2023 Version 1.4

2

3.1 Serial Data Line
The data line is a bidirectional, three-state, data transfer line. Table 1 shows the logic and
voltage levels for the transmission of serial data for the SDI-12 standard. The data line uses
negative logic.
Condition

Binary state

Voltage range

marking

1

-0.5 to 1.0 volts

spacing

0

3.5 to 5.5 volts

transition

undefined

1.0 to 3.5 volts

Table 1. Logic and voltage levels for serial data
3.1.1 Voltage Transitions
During normal operation, the data line voltage slew rate must not be greater than 1.5
volts per microsecond.
3.1.2 Impedance
When an SDI-12 device has its transmitter on, its direct current (DC) source resistance
must be greater than 1000 ohms and less than 2000 ohms. Due to this impedance, the maximum
cable length depends on the capacitance of all cables connected to the data line. When any
SDI-12 device's transmitter is off, including during a low-power standby mode, the DC
resistance to ground must be within 160K to 360K ohms. If an SDI-12 sensor does not use the
12-volt line for power, its data line resistance to ground while powered down must be within
160K to 360K ohms. Figure 2 shows an equivalent circuit.
2/20/2023 Version 1.4

3

3.2 Ground Line
The ground line must be connected to the circuit ground and the earth ground at the data
recorder. The sensor circuit ground also must be connected to the ground line, but not normally
to its own earth ground. If it is necessary to connect the sensor circuitry to earth ground, a heavy
(12 AWG or larger) ground wire should be connected between the sensor earth ground and the
data recorder earth ground for lightning protection.
The ground conductor should be large enough to keep the voltage drop between the data
recorder and all sensors less than 0.5 volts during the maximum combined sensor current drain.
3.2.1 Transient Protection
Transient protection is recommended on the SDI-12 bus. See appendix A for a suggested
SDI-12 transient protection method.
3.3 12 Volt-Line
The data recorder (or the external power supply) provides between 9.6 volts and 16 volts
to the 12-volt line, with respect to ground, as measured under a maximum sensor load of 0.5
amperes. SDI-12 does not require the data recorder to be the source of power to the 12-volt line.

2/20/2023 Version 1.4

4

For sensors connected to the 12-volt line that exhibit an inductive load, a series diode is
recommended. SDI-12 does not require voltage limiting for transient protection in the sensor.
Transient protection is, however, recommended. See appendix A for suggested circuits for
transient protection.
3.4 Connectors
A connector type for SDI-12 is not specified.
4.0 SDI-12 COMMUNICATIONS PROTOCOL
SDI-12 data recorders and sensors communicate by an exchange of ASCII characters on
the data line. The data recorder sends a break to wake up the sensors on the data line. A break is
continuous spacing on the data line for at least 12 milliseconds. The data recorder then sends a
command. The sensor, in turn, returns the appropriate response. Each command is for a specific
sensor. The first character of each command is a unique sensor address that specifies with which
sensor the recorder wants to communicate. Other sensors on the SDI-12 bus ignore the command
and return to low-power standby mode. When a data recorder tells a sensor to start its
measurement procedure, the recorder does not communicate with any other sensor until the data
collection from the first sensor is complete. (During a concurrent measurement command,
however, a data recorder can communicate with other sensors while one or more sensors are
taking measurements. See section 4.4.7.)
A typical recorder/sensor measurement sequence proceeds as follows:
Step 1. The data recorder wakes all sensors on the SDI-12 bus with a break.
Step 2. The recorder transmits a command to a specific, addressed sensor, instructing it
to make a measurement.
Step 3. The addressed sensor responds within 15.0 milliseconds returning the maximum
time until the measurement data will be ready and the number of data values it will
return.
Step 4. If the measurement is immediately available, the recorder transmits a command
to the sensor instructing it to return the measurement(s). If the measurement is not ready,
the data recorder waits for the sensor to send a request to the recorder, which indicates
that the data are ready. The recorder then transmits a command to get the data.
Step 5. The sensor responds, returning one or more measurements.

2/20/2023 Version 1.4

5

4.1 Baud Rate and Byte Frame Format
The baud rate for SDI-12 is 1200. Table 2 shows the byte frame format for SDI-12.
1 start bit
7 data bits, least significant bit transmitted first
1 parity bit, even parity
1 stop bit

Table 2. SDI-12 byte frame format

4.2 Allowable Characters
All characters transmitted on the SDI-12 bus must be printable ASCII characters. Table 3
shows the printable characters.
space, 32 decimal
through
~, 126 decimal

Table 3. Printable characters

There are three exceptions:
1) all responses from an SDI-12 sensor end with a carriage return (0D hex, 13 decimal)
and a line feed (0A hex, 10 decimal) character, shown as <CR><LF> in this document;
2) in some cases the second and third character of a CRC code may not be printable
ASCII characters;
3) the contents of data packets returned by the high-volume binary command.
4.3 Device Addresses
The first character of every command must be a sensor address. Likewise, the first
character of a response is also the address character. This lets an SDI-12 recorder verify that the
response has come from the correct sensor. (An address is a single character used to indicate
which sensor is to respond to the command.) Table 4 shows the address codes.

2/20/2023 Version 1.4

6

ASCII address
(a single character)

Decimal

Hex

Description

"0" (zero)

48

30

Default address, all sensors are initially set to
"0" (zero) by the manufacturer for use in single
sensor systems

"1" to "9"

49 to 57

31 to 39

Addresses for additional sensors on the SDI-12
bus

Table 4. Sensor address codes

ASCII '0' through ASCII '9' are the standard addresses which all sensors and data
recorders must support. Should there be a need for more than 10 sensors, use an address in the
range ASCII 'A' through ASCII 'Z' (decimal 65 through 90) and ASCII 'a' through ASCII 'z'
(decimal 97 through 122).

4.4 SDI-12 Commands and Responses
Table 5 lists each basic SDI-12 command, its format, and the format of each response to a
command. All SDI-12 Version 1.4 sensors and data recorders must support all commands in this
table. None of the basic commands should affect the sensor’s calibration. In addition, sensors
may support extended commands as described in section 4.4.13. The terms in this table
(a,ll,cccccccc,mmmmmm,vvv,xxx,<values>, etc.) are described in sections 4.4.1 to 4.4.12.

2/20/2023 Version 1.4

7

Name

Command

Response

Break

Continuous
spacing for at least
12 milliseconds
a!
aI!
aAb!

None

Acknowledge Active
Send Identification
Change Address
Address Query
Start Measurement*
Start Measurement and Request
CRC*
Send Data

Additional Measurements*

?!
aM!
aMC!

a<CR><LF>
allccccccccmmmmmmvvvxxx...xx<CR><LF>
b<CR><LF> (support for this command is required only if
the sensor supports software changeable addresses)
a<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aD0!
.
.
.
aD9!
aM1!
.
.
.
aM9!
aMC1! ... aMC9!

a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

Additional Measurements and
Request CRC*
Start Verification*
aV!
Start Concurrent Measurement
aC!
Start Concurrent Measurement and aCC!
Request CRC
Additional Concurrent
aC1!
Measurements
.
.
.
aC9!
Additional Concurrent
aCC1! ... aCC9!
Measurements and Request CRC
Continuous Measurements
aR0! ... aR9!
Continuous Measurements and
aRC0! ... aRC9!
Request CRC
*

or
or
or
or
or

a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>

atttn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
a<values><CR><LF> (formatted like the D commands)
a<values><CRC><CR><LF> (formatted like the D
commands)

This command may result in a service request. See section 4.4.6.

Table 5. The SDI-12 basic command/response set
See Tables 12 and 13 for the high-volume commands (pages 24-25), Table 19 for the identify measurement
commands (page 29), and Table 20 for the identify measurement parameter commands (page 32).

2/20/2023 Version 1.4

8

The first character of all commands and responses is always a device address. The last
character of a command is the "!" character. The “!” can only be in a command as the command
terminator. The last two bytes of a response are a carriage return and line feed (<CR><LF>).
The maximum number of characters that can be returned in the <values> part of the
response to a D command is either 35 or 75. If the D command is issued to retrieve data in
response to a concurrent measurement command, or in response to a high-volume ASCII
measurement command, the maximum is 75. The maximum is also 75 in response to a
continuous measurement command. Otherwise, the maximum is 35.

4.4.1 Acknowledge Active Command (a!)
This command is used to ensure that a sensor is responding to a data recorder or another
SDI-12 device. It asks a sensor to acknowledge its presence on the SDI-12 bus. Table 6 shows
the acknowledge active command.
Command

Response

a!

a<CR><LF>

a - the sensor address

a - the sensor address

! - terminates the command

<CR><LF> - terminates the response

Table 6. The acknowledge active command (a!)

4.4.1.1 Examples of the Acknowledge Active Command (a!)
0!0<CR><LF>
1!1<CR><LF>

4.4.2 Send Identification Command (aI!)
This command is used to query sensors for their SDI-12 compatibility level, model
number, and firmware version number. Table 7 shows the send identification command.

2/20/2023 Version 1.4

9

Command

Response

aI!

allccccccccmmmmmmvvvxxx . . . xxx<CR><LF>

a - the sensor address

a - the sensor address

I – the send identification
command

ll - the SDI-12 version number, indicating SDI-12 version
compatibility; for example, version 1.4 is encoded as 14

! - terminates the command

cccccccc - an 8 character vendor identification, usually a company
name or its abbreviation
mmmmmm - 6 characters specifying the sensor model number
vvv - 3 characters specifying the sensor version
xxx . . . xx - an optional field, up to 13 characters, used for a serial
number or other specific sensor information that is not relevant for
operation of the data recorder
<CR><LF> - terminates the response

Table 7. The send identification command (aI!)
4.4.2.1 Example of the Send Identification Command (AI!)

4.4.3 Address Query Command (?!)
When a question mark (?) is used as the address character with the acknowledge active
command (a!), the sensor will respond as if it is being addressed on the SDI-12 bus. For
example, if a sensor detects ?!, it will respond with a<CR><LF>, no matter what its address may
be. This will allow a user to determine the address of a sensor. The user should understand that if
more than one sensor is connected to the bus, they will all respond, causing a bus contention. A
sensor is required to support the wild card address character (?) with the acknowledge active
command (?!). The sensor may also support the wild card address with all other commands; this
is not, however, a requirement.

2/20/2023 Version 1.4

10

4.4.4 Change Address Command (aAb!)
This command changes the address of a sensor. If the sensor supports software
changeable addresses, it must support the change address command. Table 8 shows this
command.
After this command has been issued and responded to, the sensor is not required to
respond to another command for one second. This gives the sensor time to write the new address
to non-volatile memory.
Command

Response

aAb!

b<CR><LF>

a - the sensor address

b - the address of the sensor (will equal the new address or
the original address if the sensor is unable to change the
address)

A - the change address command
b - the address to change to
! - terminates the command

<CR><LF> - terminates the response

Table 8. The change address command (aAb!)
4.4.5 Start Measurement Command (aM!)
This command tells the sensor to take a measurement. The sensor does not, however,
return the measurement to the data recorder after this command. It returns the time until one or
more measurements will be ready and the number of measurements that it will make. The send
data (D0!) command must be issued to get the measurement(s). Table 9 shows the start
measurement command.

Command

Response

aM!

atttn<CR><LF>

a - the sensor address

a - the sensor address

M - the start measurement

ttt - the specified time, in seconds, until the sensor will have the
measurement(s) ready

! - terminates the command

n - the number of measurement values the sensor will make and return
in one or more subsequent D commands; n is a single digit integer with
a valid range of 1 to 9

Table 9. The start measurement command (aM!)

2/20/2023 Version 1.4

11

If the sensor returns 000 (ttt), the measurement is immediately available for transfer to
the data recorder. The data recorder should issue the D0 command to get the data.
If ttt is not equal to zero (000), the data recorder must wait for the specified time to
elapse. The ttt time period begins upon completion of the transmission of the line feed character.
Then it wakes the sensor with a break and issues the D0 command. If, however, the sensor has
the measurement ready before ttt seconds elapse, it will send a service request to the recorder.
This tells the recorder to stop marking time and issue the D0 command.
When a data recorder issues an M command, it must complete the command/response
sequence with the sensor before it sends any command to any other sensor. For example,
suppose that following the issuance of the M command, the sensor responds
0M!00101<CR><LF>
This response shows that one data value will be ready in 10 seconds. The data recorder
must wait for either of two events to occur before issuing a D0 command:
1) receipt of a service request (a<CR><LF>) from the sensor
2) the specified time to elapse (10 seconds)
The recorder then issues the D0 command to get the data. After the M command and
before the sensor issues the service request, the data recorder will not communicate with any
other sensor. The sensor must not drive the data line until it sends a service request. The
recorder must not drive the data line while waiting for the service request.
A sensor should return a ttt value greater than the time it takes to make a measurement, to
allow for timing tolerances and for the service request. (See section 4.4.6.) The data recorder
may wait for the entire ttt time. Therefore, the tolerance above the measurement, added to ttt,
should be minimal.
After a sensor finishes its measurement procedure, the sensor must retain the measured
data in memory until it receives another M or V command, or another command that returns data
via the D0 command.
See the send data command, aD0!, aD1! . . . aD9!, for examples of this command.
Because the start measurement command is closely related to the send data command, examples
for both commands are shown on page 17.
4.4.5.1 Aborting a Measurement
If a sensor detects a break after it receives an M command, but before it issues a service
request, it must abort its measurement procedure. The sensor address, followed by <CR><LF>,
(or followed by <CRC><CR><LF> if a CRC was requested) should be returned in response to

2/20/2023 Version 1.4

12

subsequent D commands. This requirement provides a way for a data recorder to abort a
measurement so it can communicate with another sensor, or this sensor, on the SDI-12 bus.

4.4.6 Service Request (a<CR><LF>)
A service request is a response from a sensor. It is not a command. It is sent, after an M
command, to tell the data recorder that the sensor has finished its measurement(s) and the data
are ready. A service request is issued by the sensor after an M, MC, or V command, when it has
finished its measurement. The entire service request must be returned before ttt seconds (see
Start Measurement Command, page 11) have elapsed. The time (ttt) is the maximum time that a
sensor will take before it has data available.
If a data recorder does not detect a service request, the data recorder must wait for the
specified time (ttt), given in response to the M or V command, and then issue the D0 command
to get the data. The minimum time before a data recorder can issue the D0 command to get the
data, in this case, is ttt seconds.
A sensor is required to issue a service request if it indicates that it will take one second or
longer before data are ready, in response to an M or V command. If a sensor says it will take zero
seconds before the data are ready, then a sensor must not issue a service request.
4.4.7 Start Concurrent Measurement Command (aC!)
This command, introduced in Version 1.2 of the SDI-12 Specification, tells the sensor to
take a concurrent measurement. A concurrent measurement is one which occurs while other
SDI-12 sensors on the bus are also taking measurements. The sensor does not, however, return
the measurement to the data recorder after this command. It returns the time until all
measurements will be ready and the number of measurement that it will make. The send data
(D0!) command must be issued to collect the measurements(s). Table 10 shows the start
concurrent measurement command.
If the sensor returns 000 (ttt), the measurement is immediately available for transfer to
the data recorder. The data recorder should issue the D0 command to get the data.
If ttt is not equal to zero (000), the data recorder must wait for the specified time to elapse
before attempting to retrieve the data. The ttt time period begins upon completion of the
transmission of the line feed character. During this time the data recorder can collect data from
sensors at other addresses. Communicating with other sensors will not abort a concurrent
measurement. After the specified time has elapsed, the data recorder wakes the sensor with a
break and issues the D0 command. The sensor will not issue a service request when it has
completed the measurement. The sensor must not drive the data line from the time it
completes its atttnn<CR><LF> response until it starts responding to the D0 command.

2/20/2023 Version 1.4

13

Command

Response

aC!

atttnn<CR><LF>

a - the sensor address

a - the sensor address

C - the start concurrent
measurement command

ttt - the specified time, in seconds, until the sensor will have the
measurement(s) ready

! - terminates the command

nn - the number of measurement values the sensor will make and
return in response to one or more subsequent D commands

Table 10. The start concurrent measurement command (aC!)
The data recorder should document the number of data values it can store in response to a
C command.
After a sensor finishes its measurement procedure, the sensor must retain the measured
data in memory until it receives another C, M, or V command, or another command that returns
data via the D0 command.
See the send data command, aD0!, aD1! . . . aD9!, section 4.4.8, for the data response
requirements. Because the start concurrent measurement command is closely related to the send
data command, examples for both commands are in sections 4.4.8.3 and 4.4.8.4.
For a sensor or data logger to claim support of Version 1.2 or higher of the SDI-12
Specification, it must support this command. Claiming zero data values in response to this
command (i.e. a response of a00000<CR><LF>) is not a valid support of this command. The
command must initiate a true measurement cycle. Sensors or data recorders that conform to a
previous version of SDI-12 will most likely not support this command, and will therefore not
respond to this command.
4.4.7.1 Aborting a Concurrent Measurement
If a sensor receives a valid command addressed to it while it is in the process of a
concurrent measurement, it should abort the measurement procedure. The sensor address
followed by <CR><LF> (or <CRC><CR><LF> if a CRC was requested) should be returned in
response to subsequent D commands. This requirement provides a way for a data recorder to
abort a measurement.
4.4.8 Send Data Command (aD0!, aD1! . . . aD9!)
This command is used to get groups of data from the sensor. D0! is issued after an M, MC, C,
CC, V, or HA command. The sensor responds by sending the data. If the expected number of
measurements is not returned in response to a D0! command, the data recorder issuesD1!, D2!,
etc. until all measurement values are received. (The expected number of measurements is given
in the response to an M, C, or V command.) Table 11 shows the send data command.
2/20/2023 Version 1.4

14

Command

Response

aD0! (aD1! . . . aD9!)

a<values><CR><LF>
or
a<values><CRC><CR><LF>

a - the sensor address

a - the sensor address

D0 - the send data command, D1 . .
. D9 additional send data
commands

values (see below)

! - terminates the command

<CR><LF> - terminates the response
<values> - pd.d
p - the polarity sign (+ or -)
d - numeric digits before the decimal place
. - the decimal point (optional)
d - numeric digits after the decimal point
the maximum number of digits for a data
value is 7, even without a decimal point
the minimum number of digits for a data
value (excluding the decimal point) is 1
the maximum number of characters in a
data value is 9 (the (polarity sign + 7
digits + the decimal point))
<CRC> - 3 character CRC code, appended if data was
requested with the aMC!, aMC1! ... aMC9!, aCC!, or
aCC1! ... aCC9! commands (see section 4.4.12)

Table 11. The send data command (aD0!, aD1! . . . aD9!)
If the response to a D command is valid, but no data are returned, the sensor has aborted
the measurement. To obtain data the recorder must issue another M, C, or V command.
Notes: in response to certain commands, the data returned after a D command may have a
Cyclic Redundancy Check (CRC) appended to it. See section 4.4.12. The hig1h volume ASCII
command, HA, extends the range of the send data commands. See section 5.1.

2/20/2023 Version 1.4

15

The maximum number of characters that can be returned in the <values> part of the
response to a D command is either 35 or 75. If the D command is issued to retrieve data in
response to a concurrent command, or a high-volume ASCII command, the maximum is 75.
Otherwise, the maximum is 35.
4.4.8.1 Continuous Measurements (aR0! ... aR9!)
Sensors that are able to continuously monitor the phenomena to be measured, such as a
shaft encoder, do not require a start measurement command (M!, M1! . . . M9!). They can be
read directly with the R commands (R0! ... R9!). For example:
if (the sensor is operating in a continuous measurement mode) then
aR0! will get and return the current reading of the sensor

The response to R commands (R0! ... R9!) are formatted like the D commands (D0! ...
D9!). The main difference is that the R commands do not need to be preceded with an M
command, which tells the sensor to take a measurement. The maximum number of characters
that can be returned in the <values> part of the response to an R command is 75.
Each R command is an independent measurement. For example, R5 need not be preceded
by R0 ... R4.
If a sensor is unable to take a continuous measurement, then it must return its address
followed by a carriage return/line feed (a<CR><LF>) in response to an R command. If a CRC
was requested, then the <CR><LF> must be preceded by the CRC. For example:
0AP@<CR><LF>.
4.4.8.2 Example of the aR0! Command
One measurement is immediately available after the R0! command:
0R0!0+3.14<CR><LF>

4.4.8.3 Return of Multiple Measurements (Parameters) by a Sensor (D1! . . . D9!)
The commands D1 . . . D9 are used with sensors that return multiple measurements. The
purpose of the D commands is for the sensor to return as many measurements as possible in
response to each command. The limiting constraint is that the total number of characters that can
be returned in the <values> field (see section 4.4.8). If the total number of characters exceeds the
maximum length of the <values> field, the sensor fragments the response, sending the first group
of measurements in response to D0, the next group in response to D1, and so on. A group can
have one or more measurements; data collection always begins with the D0 command. See
section 4.4.8.4 for examples.
The sensor must never split individual data values, sending part of a value in response to
one D command, sending the rest of the characters, for that value, in response to the next D
command.
2/20/2023 Version 1.4

16

If possible, a sensor should return all measurements in response to the D0 command. This
is not, however, a requirement.
4.4.8.4 Examples of the Start Measurement Command (aM!) and the Send Data
Commands
a. One measurement is immediately available after the M command:
0M!00001<CR><LF>
0D0!0+3.14<CR><LF>

b. Three measurements will be ready 5 seconds after the M command, and the sensor issues a
service request. All 3 measurements are returned in response to the D0 command:
0M!00053<CR><LF>
0<CR><LF>
0D0!0+3.14+2.718+1.414<CR><LF>

c. Nine measurements will be ready 35 seconds after the M command, and the sensor issues a
service request. Because the number of characters in all 9 measurements exceeds the limit in the
<values> field, a D1 command must be issued to get the second group of measurements:
0M!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66<CR><LF>
0D1!0+7.77+8.88+9.99<CR><LF>

d. Two measurements will be available in 1 second, and the sensor does not issue a service
request. After 1 second, the data recorder sends a break to wake the sensor and issues the D0
command:
0M!00012<CR><LF>
0D0!0+3.14+2.718<CR><LF>
Note: this example shows the proper operation of the data recorder, but the sensor is out of
compliance because it did not issue a service request.

2/20/2023 Version 1.4

17

e. Three measurements will be ready 5 seconds after the M command, and the sensor issues a
service request. Upon receipt of the service request, the data recorder issues D0 to get the data.
However, only 1 measurement is returned. The data recorder then issues the D1 command to get
the next group of data. In response, the second measurement is returned. Then the recorder issues
D2 to get the next, and last, group of data. In the example, each group contains only one
measurement.
0M!00053<CR><LF>
0<CR><LF>
0D0!0+3.14<CR><LF>
0D1!0+2.718<CR><LF>
0D2!0+1.414<CR><LF>
Note: This is in compliance with the standard. As many measurements as possible, however,
should be returned in response to each D command.
4.4.8.5 Example of the Concurrent Measurement Command (aC!) and the Send Data
Command (aD0!)
Two sensors, one returning 12 readings after 45 seconds and the other returning 4
readings after 15 seconds. The measurements are taken concurrently. Fifteen seconds after
starting a measurement from sensor 1, the data recorder issues a break followed by the D0
command to sensor address 1. Forty-five seconds (or longer) after starting a measurement from
the sensor at address 0, the data recorder sends a break and a D0 command to sensor 0. Note that
since a concurrent measurement was requested of sensor 0, it is allowed to return up to 75
characters in its <values> field of the response. An M command only allows 35 characters in its
<values> field to ensure compatibility with data recorders prior to version 1.2.
0C!004512<CR><LF>
1C!101504<CR><LF>
1D0!1+1.23+2.34+345+4.4678<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12<CR><LF>

4.4.9 Additional Measurement Commands (aM1! . . . aM9!)
Additional M commands provide a means to request different types of measurements
from a sensor or to instruct a sensor to do a calibration or a control function. For example, a
sensor could measure pressure and temperature: M tells it to measure pressure and M1 tells it to
measure the temperature.
Additional M commands have the same format as the aM! command. Data collection
always begins with the D0 command. If the sensor does not return the expected number of
measurements in response to the D0 command, the recorder should issue aD1, aD2, etc. until the
sensor returns all measurements.
To comply with Version 1.2 or higher of SDI-12, sensors must respond to the additional
measurement commands (aM1! . . . aM9!) and data recorders must be able to log data from the

2/20/2023 Version 1.4

18

additional measurement commands. If a sensor has no data defined for an additional
measurement command, it should return a0000<CR><LF>, saying that it has zero data values
ready. Not responding to the command is not acceptable.
4.4.9.1 Examples of the Additional M Commands (aMn!)
a. A sensor supports the aM1! command:
0M1!00011<CR><LF>
0<CR><LF>
0D0!0+3.14<CR><LF>
b. A sensor takes 9 measurements in response to the M2 command:
0M2!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66<CR><LF>
0D1!0+7.77+8.88+9.99<CR><LF>
4.4.10 Additional Concurrent Measurement Commands (aC1! . . . aC9!)
Additional C commands provide a means to request different types of measurements
from a sensor or to instruct a sensor to do a calibration or a control function. To comply with
Version 1.2 or higher of SDI-12, sensors must respond to the additional concurrent measurement
commands and data recorders must be able to log data from the additional concurrent
measurement commands. If a sensor has no parameters defined for an additional concurrent
measurement command, then it should return a00000<CR><LF>, saying that it has zero data
values ready. Not responding to the command is not acceptable.
Additional C commands have the same format and constraints as the aC! command. Data
collection always begins with the D0 command. If the sensor does not return the expected
number of measurements in response to the D0 command, the recorder should issue aD1, aD2,
etc., until the sensor returns all measurements.
4.4.11 Start Verification (aV!)
This command tells the sensor to return a verification in response to a subsequent D
command. A verification sequence may include ROM signatures, CRC's, RAM test results, or
the results of other diagnostics in the sensor. A standard response to the V command is not
specified.
The format of this command is the same as the M commands. The format of the response
is the same as the D commands.

2/20/2023 Version 1.4

19

4.4.11.1 Example of the Start Verification Command (aV!)
0V!00011<CR><LF>
0<CR><LF>
0D0!0+1<CR><LF>

4.4.12 Requesting a Cyclic Redundancy Check (CRC)
To enhance the error detection capability in SDI-12 data collection systems, a variation of
the Start Measurement Commands (M!, M1! ... M9!), Start Concurrent Measurement Commands
(C!, C1! ... C9!), and Continuous Measurement Commands (aR0! ... aR9!) request that the data
be returned with a 16 bit Cyclic Redundancy Check (CRC) appended to it. These commands
use the existing command letters with a C appended, namely: aMC!, aMC1! ... aMC9!, aCC!,
aCC1! ... aCC9!, and aRC0! ... aRC9!. When these commands are used, the data returned in
response to the D commands, or R commands, must have a CRC code appended to it.
The number of measurements returned in response to a CRC command should be the
same as the measurement that was made in response to a non-CRC command. In other words, the
CRC command causes the same measurements to be taken as the non-CRC command.
To be version 1.3 (or higher) compliant, the sensor must support CRCs.
4.4.12.1 CRC-16 Computation
The computation of the CRC is performed on the data response before parity is added.
All operations are assumed to be on 16 bit unsigned integers. The least significant bit is on the
right. Numbers preceded by 0x are in hexadecimal. All shifts shift in a zero. The algorithm is:
Initialize the CRC to zero. For each character beginning with the address, up to but not including, the carriage return
(<CR>).
{
Set the CRC equal to the exclusive OR of the character and itself
for count = 1 to 8
{
if the least significant bit of the CRC is one
{
right shift the CRC one bit
set CRC equal to the exclusive OR of 0xA001 and itself
}
else
{
right shift the CRC one bit
}
}
}

2/20/2023 Version 1.4

20

4.4.12.2 Encoding the CRC as ASCII Characters
The 16 bit CRC is encoded as three ASCII characters using the following algorithm:
1st character = 0x40 OR (CRC shifted right 12 bits)
2nd character = 0x40 OR ((CRC shifted right 6 bits) AND 0x3F)
3rd character = 0x40 OR (CRC AND 0x3F)

The three ASCII characters are placed after the data before the <CR><LF>. Parity is
applied to all three characters when they are transmitted. The AND and OR operators are bitwise
operators, not logical operators.
4.4.12.3 Examples of the CRC-16 Start Measurement Command (aMC!) and the Send Data
Command (aD0!)
a. One measurement is immediately available after the MC command:
0MC!00001<CR><LF>
0D0!0+3.14OqZ<CR><LF>
b. Three measurements will be ready 5 seconds after the MC command, and the sensor issues a
service request. All 3 measurements are returned in response to the D0 command:
0MC!00053<CR><LF>
0<CR><LF>
0D0!0+3.14+2.718+1.414Ipz<CR><LF>
c. Nine measurements will be ready 35 seconds after the MC command, and the sensor issues a
service request. Because the number of characters in all 9 measurements exceeds the limit for the
<values> field, a D1 command must be issued to get the second group of measurements:
0MC!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66I]q<CR><LF>
0D1!0+7.77+8.88+9.99IvW<CR><LF>
d. Two measurements will be available in one second, and the sensor does not issue a service
request. After one second, the data recorder sends a break to wake the sensor and issues the D0
command:
0MC!00012<CR><LF>
0D0!0+3.14+2.718IWO<CR><LF>
Note: this example shows the proper operation of the data recorder, but the sensor is out of
compliance because it did not issue a service request.
e. Three measurements will be ready five seconds after the MC command, and the sensor issues

2/20/2023 Version 1.4

21

a service request. Upon receipt of the service request, the data recorder issues D0 to get the data.
Only one measurement, however, is returned. The data recorder then issues the D1 command to
get the next group of data. In response, the second measurement is returned. Then the recorder
issues D2 to get the next, and last, group of data. In this example, each group contains only one
measurement.
0MC!00053<CR><LF>
0<CR><LF>
0D0!0+3.14OqZ<CR><LF>
0D1!0+2.718Gbc<CR><LF>
0D2!0+1.414GtW<CR><LF>
Note: this is in compliance with the standard. As many measurements as possible, however,
should be returned in response to each D command.
f. Two sensors, one returning 12 readings after 45 seconds and the other returning 4 readings
after 15 seconds. The measurements are taken concurrently. Fifteen seconds after starting a
measurement from sensor 1, the data recorder issues a break followed by the D0 command to
sensor address one. Forty-five seconds (or longer) after starting a measurement from the sensor
at address 0, the data recorder sends a break and a D0 command to sensor 0. Since a concurrent
measurement was requested of sensor 0, it is allowed to return up to 75 characters in the
<values> field of its response:
0CC!004512<CR><LF>
1CC!101504<CR><LF>
1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12
Ba]<CR><LF>
4.4.13 Extended Commands
Sensors are required only to respond to the basic SDI-12 command set. Sensors,
however, usually require calibration or other setup commands. Extended commands provide the
means for such functions. An extended command is a command for a specific make of sensor to
tell that sensor to do a specific task. Extended commands are defined and documented by the
manufacturer of each sensor.
Extended commands have the following attributes:
• an extended command must be prefixed with an address
• an extended command must be terminated with an exclamation point
• the response must be prefixed with an address
• the response must be terminated with <CR><LF>
• the transparent mode must support basic SDI-12 commands and extended
commands

2/20/2023 Version 1.4

22

Extended commands should be prefixed with an upper case X, for example, aXNNN!,
where X says that an extended command follows and NNN is the extended command. NNN is
not limited to three characters. Prefixing extended commands with an upper case X is a
recommendation only and is not a requirement. Future versions of SDI-12, however, may
require this.
4.4.13.1 Extended Commands Returning Multiple Lines of Text
Many SDI-12 sensors have sufficient memory to store and return multiple lines of text to
a data recorder, such as returning detailed documentation about the sensor. To support this, an
extended command may return multiple lines of text, with each line of text terminated with a
carriage return/line feed pair (<CR><LF>).
The transmission of each text line must conform with the same timing requirements for
all SDI-12 sensor responses.
When multiple lines of text are going to be returned, the sensor must indicate that two or
more lines of text will be returned in response to the extended command by placing the ASCII
character “start of text” (STX, decimal value 2) after the address character, in the first line of text
returned to the data recorder.
The sensor must indicate the last line of text with the ASCII character “end of text,”
(ETX, decimal value 3) after the <CR><LF> pair in the final line of text.
The maximum number of ASCII characters allowed in each line of text, exclusive of the
SDI-12 address, <STX>, <CR>, <LF>. and <ETX> characters, is 75.
ASCII CRC error detection characters are not appended to the lines of text.
The time between the transmission of each line of text must be less than or equal to 150
milliseconds. If the start bit of the first character in the next expected line of text is not received
in 150 milliseconds, then the data recorder should conclude that no more lines of text are
forthcoming.
Here is an example:
0XHELP!0<STX>This is the first line of text.<CR><LF>
This is the second line of text.<CR><LF>
This is the third and final line of text.<CR><LF> <ETX>

Sensor and data logger support for returning and receiving multiple lines of text is not an
SDI-12 requirement.

2/20/2023 Version 1.4

23

4.4.14 Transparent Mode
SDI-12 data recorders must have a mode in which extended commands can be sent to
sensors. This is called the transparent mode. The transparent mode has the following
characteristics.
• The data recorder buffers a command string received from a computer, terminal, or
modem, until the command string is terminated.
• The data recorder wakes the sensor with a break, then it sends the buffered command
to the sensor, using the SDI-12 protocol.
• The data recorder receives the response from the sensor and transmits the response to
the computer, the terminal, or the modem.

5.0 HIGH-VOLUME COMMANDS
The high-volume commands, introduced in version 1.4 of the SDI-12 Specification,
expand the concurrent measurement commands to allow up to 999 parameters to be returned
from a sensor.
5.1 Start High-Volume ASCII Measurement
Table 12 shows the high-volume ASCII measurement command.
Command Name

Command

Response

High-Volume ASCII

aHA!

atttnnn<CR><LF>

Table 12. High-Volume ASCII measurement
The commands to get high-volume data after the aHA! command are: aD0! … aD999!
If after obtaining the data values from aD9! there are still more data values to obtain,
continue to send data requests with aD10!...aD99! as needed. If after obtaining the data values
from aD99! there are still more data values to obtain, continue to the send data requests with
aD100!...aD999! as needed. Leading zeros are not placed after the “D”
The responses to the send data commands follow the same rules as with the Concurrent
Measurement send data commands. The maximum number of characters that can be returned in
the <values> part of the response is 75 and a three character <CRC> is appended to the data
before the <CR><LF>. The CRC must be present.

2/20/2023 Version 1.4

24

5.1.1 Example of High-Volume ASCII Measurement
In this example there are two sensors, one returning 12 data values after 45 seconds and
the other returning 4 data values after 15 seconds. The first measurement uses the high-volume
ASCII command; the second one uses the concurrent command with a CRC. Fifteen seconds
after requesting data from sensor one, the data recorder issues a break followed by the D0
command to sensor address 1. Forty-five seconds (or longer) after starting the measurement from
the sensor at address 0, the data recorder sends a break and a D0 command to sensor 0. Since a
high-volume ASCII measurement was requested of sensor 0, it is allowed to return up to 75
characters in the <values> field of its response, and it does not abort when sensor 1 is addressed:
0HA!0045012<CR><LF>
1CC!101504<CR><LF
1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12Ba]<CR><LF>

5.2 Start High-Volume Binary Measurement
The high-volume binary measurement allows for collection of large volumes of data from
a sensor more efficiently than the ASCII transfer methods.
Command Name

Command

Response

High-Volume Binary

aHB!

atttnnn<CR><LF>

Table 13. High-Volume binary measurement
The commands to get high-volume binary data after the aHB! command are: aDB0! …
aDB999!
If after obtaining the data values from aDB9! there are still more data values to obtain,
continue the send data requests with aDB10!...aDB99! as needed. If after obtaining the data
values from aDB99! there are still more data values to obtain, continue the send data requests
with aDB100!...aDB999! as needed.
Responses to the aDB0! … aDB999! commands are an exception to section 4.1 Table 2
because the byte frame format is 8 data bits, no parity bit. The SDI-12 address is
transmitted as the ASCII character, but no parity bit. The remaining fields are encoded as
binary numbers. The least significant byte is transferred first for multi-byte binary
numbers.

2/20/2023 Version 1.4

25

SDI-12
Address

ASCII

Packet Size

Data Type

16 bit unsigned integer, indicates
the size, in bytes, of the binary
data payload

8 bit unsigned
integer, indicates
the data type in
the binary data
payload

Binary Data
Payload

must be <= 1,000
bytes

CRC
16 bit CRC value, using
the same algorithm as the
other measurement
commands that request a
CRC, but encoded in
binary (not converted to
3 byte ASCII)

Table 14. Data packet
If the value of n in aDBn! is invalid due to being higher than necessary to return data values, then
the data package must be:
SDI-12
Address

Packet Size

Data Type

Binary Data
Payload

CRC

address

0

0

nil

16 bit CRC

Table 15. Empty data packet
All data values in a particular response must be of the same type, but data types can differ
between aDBn! commands.
Nil, as shown in Table 15, means that the binary data payload is empty: there are zero data
bytes in it. An empty data packet, therefore, has six bytes only:
1 byte:
2 bytes:
1 byte:
2 bytes:

the address;
the packet size (zero);
the data type (zero);
the CRC value.

2/20/2023 Version 1.4

26

5.2.1 High-Volume Binary Data Types
Table 16 shows the high-volume binary data types.
Data
Type

Range

Size

0

Indicates an invalid request

No data returned

1

-128 to 127

Signed 8-bit integer

2

0 to 255

Unsigned 8-bit integer

3

-32,768 to 32,767

Signed 16-bit integer

4

0 to 65,535

Unsigned 16-bit integer

5

-2,147,483,648 to 2,147,483,647

Signed 32-bit integer

6

0 to 4,294,967,295

Unsigned 32-bit integer

7

-9,223,372,036,854,775,808 to
9,223,372,036,854,775,807

Signed 64-bit integer

8

0 to 18,446,744,073,709,551,615

Unsigned 64-bit integer

9

±1.18×10−38 to ±3.4×1038

IEEE 32-bit floating point single
precision/binary32

10

±2.23×10−308 to ±1.80×10308

IEEE-64 bit floating point double
precision/binary64

Table 16. Data types

2/20/2023 Version 1.4

27

5.2.2 Example of High-Volume Binary Command
In this example a data recorder transmits a high-volume binary command and the sensor
responds, indicating that four data values will be available after five seconds:
1HB!1005004<CR><LF>
Table 17 shows the data values, returned in binary data packets, that are used in this
example. Two of the four data values are returned in a data packet as signed 16-bit integers; the
other two data values are returned in a data packet as 32-bit single precision floating point
numbers.
Data Type

Size

Data Value

Data Value in Hexadecimal

3

Signed 16-bit integer

-1

0xFFFF

3

Signed 16-bit integer

1

0x0001

9

IEEE-32 bit floating point

3.14

0x4048F5C3

9

IEEE-32 bit floating point

1.0

0x3F800000

Table 17. Data values in the high-volume binary command example
Table 18 shows each data packet returned in response to the commands 1DB0!,1DB1!,
and 1DB2! as a string of bytes, shown in hexadecimal.
The commands, 1DB0!, 1DB1!, and 1DB2 are transmitted to the sensor as 7 bit ASCII
characters with even parity. The SDI-12 address, 0x31 in this example, is returned as an 8 bit
ASCII character, without a parity bit.
Table 18 also shows that it was unnecessary to transmit the command 1DB2!, because all
four data values were already received. Therefore, the sensor returned an empty data packet.
Command

Data Packet

1DB0!

0x31 0x04 0x00 0x03 0xFF 0xFF 0x01 0x00 0xC2 0xAC

1DB1!

0x31 0x08 0x00 0x09 0xC3 0xF5 0x48 0x40 0x00 0x00 0x80 0x3F 0x3B 0x6E

1DB2!

0x31 0x00 0x00 0x00 0x0E 0xFC
Table 18. Data packet examples

2/20/2023 Version 1.4

28

5.3 Concurrency of High-Volume Commands
The high-volume commands are concurrent commands, as described in section 4.4.7,
with section 4.4.7.1 explaining how to abort a concurrent measurement command.
5.4 Compliance with High-Volume Commands
To claim compliance with version 1.4, SDI-12 data recorders must support the
high-volume commands.
No requirement is imposed on SDI-12 sensors to support the high-volume commands.
The functionality of an SDI-12 sensor dictates the need to support the high-volume commands,
because there is no advantage in collecting a low number of parameters from a sensor with a
high-volume command.
Version 1.4 sensors that do not support the high-volume ASCII command, or the
high-volume binary command, should respond with a000000<CR><LF> saying that it has zero
data values ready.
6.0 METADATA COMMANDS
The metadata commands, introduced in version 1.4 of the SDI-12 Specification, provide
a means to get the response to a command without actually initiating a measurement.
6.1 Identify Measurement Commands
The identify measurement commands are formed by placing the capital letter I into the
measurement commands immediately after the address. The response is identical to having
issued the command without the capital letter I following the address. The format is
atttn<CR><LF>, atttnn<CR><LF>, or atttnnn<CR><LF> depending on the measurement
command.
The continuous measurement commands (aR0! … aR9! And aRC0! … aRC9!) provide their data
instantly and therefore do not have an identify measurement command.
Command

Response

aIM!

atttn<CR><LF>

aIMC!

atttn<CR><LF>

aIM1!
.
.
.
aIM9!

atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aIMC1!

atttn<CR><LF>

2/20/2023 Version 1.4

29

Command

Response

.
.
.
aIMC9!

atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aIV!

atttn<CR><LF>

aIC!

atttnn<CR><LF>

aICC!

atttnn<CR><LF>

aIC1!
.
.
.
aIC9!

atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>

aICC1!
.
.
.
aICC9!

atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>

aIHA!

atttnnn<CR><LF>

aIHB!

atttnnn<CR><LF>

Table 19. The identify measurement commands
6.1.1 Examples of the Identify Measurement Commands
a. One data value will be immediately available after the M command:
8IM!80001<CR><LF>
b. Nine data values will be available 10 seconds after the M command:
8IM!80109<CR><LF>
c. Ninety-nine data values will be available 10 seconds after the C5 command:
8IC5!801099<CR><LF>
6.2 Identify Measurement Parameter Commands
The identify measurement parameter commands provide details about the parameters
returned by a particular command. The form of the command is an expansion of the Identify

2/20/2023 Version 1.4

30

Measurement Commands. An underscore character ("_") plus a three-digit decimal number is
placed immediately before the exclamation point ("!"). The decimal number is the data value of
interest.
The response is a comma separated value (CSV) string with several fields that provide
information about the data value of interest. Two fields are required. Additional fields can be
added by the sensor manufacturer. Fields are expected to contain printable ASCII characters
other than the comma character (“,”) or the semicolon character (“;”) since they are used to
delimit fields.
6.2.1 Field One
The first field contains a concise identification of the parameter, which is the data value
of interest. The recommendation is to use a Standard Hydrometeorological Exchange Format
(SHEF) code.
SHEF codes are published by the National Oceanic and Atmospheric Administration
(NOAA), National Weather Service in the “Standard Hydrometeorological Exchange Format
(SHEF) Code Manual.” This document is available on the Internet at:
http://www.nws.noaa.gov/oh/hrl/shef/indexshef.htm
The SHEF codes are listed in “Appendix G, Physical Element Definitions,” in the NOAA
document.
If an appropriate SHEF code does not exist for the parameter, or if the sensor
manufacturer chooses not to use a SHEF code for the parameter, then field one may contain a
concise identification of the parameter as determined by the sensor manufacturer. The
recommendation, however, is to use a SHEF code when an appropriate SHEF code does exist.
6.2.2 Field Two
Field two contains the units for the parameter. If the parameter is unit-less, the field must
still be present. A single space character is recommended for an empty field to make it easier to
read.
6.2.3 Optional Fields
The sensor manufacturer may provide additional information relevant to the parameter by
adding additional fields. This may be a more descriptive name than found in field one. For
example, it may contain calibration data or dates. If the parameter represents a probe that has a
unique serial number, there may be a field that contains that serial number. The only limit on the
number of additional fields is that the maximum length of the response, through the terminating
semicolon, is 75 characters.
The last field is terminated by a semicolon “;” and then followed by either the
<CR><LF> sequence or a three character CRC followed by the <CR><LF> sequence if the
measurement command was one that returns a CRC.
2/20/2023 Version 1.4

31

If the parameter number, nnn, is invalid for the measurement, then the response shall be:
a<CR><LF> or a<CRC><CR><LF> if a CRC was expected.
To poll the Continuous Measurement commands (aR0! … aR9! and aRC0! … aRC9!) to
identify their measurement parameters, increment sequentially through the parameters until the
response indicates the parameter number, nnn, is invalid for the measurement.
Command

Response

aIM_001!
.
.
.
aIM_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIMC_001!
.
.
.
aIMC_009!

a,field1,field2;<CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIM1_001! … aIM1_009!
.
.
.
aIM9_001! … aIM9_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIMC1_001! … aIMC1_009!
.
.
.
aIMC9_001! … aIMC9_009!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIV_001! … aIV_009!

a,field1,field2;<CR><LF>

aIC_001! … aIC_099!

a,field1,field2;<CR><LF>

aICC_001! … aICC_099!

a,field1,field2; <CRC><CR><LF>

aIC1_001 … aIC1_009!
.
.
.
aIC9_001 … aIC9_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aICC1_001! … aICC1_099!
.
.

a,field1,field2;< CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

2/20/2023 Version 1.4

32

Command

Response

.
aICC9_001! … aICC9_099!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIR0_001! … aIR0_099!
.
.
.
aIR9_001! … aIR9_099!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIRC0_001! … aIRC0_099!
.
.
.
aIRC9_001! … aIRC9_099!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIHA_001! … aIHA_999!

a,field1,field2; <CRC><CR><LF>

aIHB_001! … aIHB_999!

a,field1,field2; <CRC><CR><LF>

Table 20. The identify measurement parameter commands
6.2.4 Examples of the Identify Measurement Parameter Commands
a. Generic example:
0IM!0001!<CR><LF>
0IM_001!0,field1,field2,field3;<CR><LF>
b. Metadata for an M command, showing that the M command takes a precipitation
measurement, using optional field 3 to describe the data value:
0IM!00001<CR><LF>
0IM_001!0,PR,mm,precipitation rate per day;<CR><LF>
c. Metadata CC command, showing that the CC command takes an average air temperature
measurement, using additional/optional fields to provide additional metadata, with a CRC
appended to the response:
0ICC!000502<CR><LF>
0ICC_001!0,CU,degrees C,average air temperature,calibration data,40,1235;@|e<CR><LF>
6.3 Compliance with Metadata Commands
To claim compliance with version 1.4, an SDI-12 sensor must support the metadata
commands. Because there is no requirement for an SDI-12 data recorder to manage or store the
metadata, the transparent mode (section 4.4.13.1) on the data recorder is sufficient support for
these commands. Explicit data recorder support for these commands is not otherwise required.
2/20/2023 Version 1.4

33

7.0 SDI-12 TIMING
Figure 3 shows a timing diagram for an SDI-12 command and its response. The tolerance for all
SDI-12 timing is ± 0.40 milliseconds. The only exception to this is the time between the stop bit
of one character and the start bit of the next character. The maximum time for this is 1.66
milliseconds, with no tolerance.

• A data recorder transmits a break by setting the data line to spacing for at least 12
milliseconds.
• The sensor will not recognize a break condition for a continuous spacing time of less
than 6.5 milliseconds and will always recognize a break when the line is continuously
spacing for more than 12 milliseconds.
• Upon receiving a break, a sensor must detect 8.33 milliseconds of marking on the data
line before it looks for an address.

2/20/2023 Version 1.4

34

• A sensor must wake up from a low-power standby mode and be capable of detecting a
start bit from a valid command within 100 milliseconds after detecting a break.
• After a data recorder transmits the last character of a command, it must relinquish
control of the data line within 7.5 milliseconds following the end of the stop bit.
(Tolerance: +0.40 milliseconds.)
• After receiving the break and the command, the addressed sensor sets the data line to
marking for 8.33 milliseconds and then send the response. (Tolerance: -0.40
milliseconds.) The start bit of the first response byte must start within 15 milliseconds
after the stop bit of the last byte of the command. (Tolerance: +0.40 milliseconds.
• After a sensor transmits the last character of a response, it must relinquish control of
the data line within 7.5 milliseconds. (Tolerance: +0.40 milliseconds.)
• No more than 1.66 milliseconds of marking are allowed between the end of the stop bit
and the start bit (e.g., between characters) on any characters in the command or the
response. (No tolerance.) This permits a response to an M command to be sent within a
380 millisecond window.
• Sensors must return to a low-power standby mode after receiving an invalid address or
after detecting a marking state on the data line for 100 milliseconds. (Tolerance: +0.40
milliseconds.)
• When a recorder addresses a different sensor, or if the data line has been in the
marking state for more than 87 milliseconds, the next command must be preceded by a
break.
Note: The low power standby mode, in addition to being a power consumption state, is a
protocol state and a break is required to leave that state.
7.1 Rules for the Break
The data recorder sends a break when it is necessary to wake a sensor from low-power
standby mode. An SDI-12 sensor is required to return to low-power standby mode after
receiving an invalid address or after detecting a marking state on the data line for 100
milliseconds. For this reason, a break must precede a command whenever a new sensor is
addressed and after 87 milliseconds of marking on the data line.
When a data recorder receives a service request, it does not have to send a break if it
issues the D0 command within 87 milliseconds after the service request. If, however, more than
87 milliseconds elapse, the D0 command must be preceded with a break.

2/20/2023 Version 1.4

35

7.2 Retries
A data recorder must support retries. Sensors have up to 100 milliseconds to wake up
after detecting a break and will not respond to any commands until they have awakened. Also,
sensors will go to sleep after detecting 100 milliseconds of idle time (marking) on the SDI-12
bus.
When issuing retries, if no response is received from a sensor, the recorder must wait for
at least 16.67 milliseconds after the last stop bit of the command, but no longer than 87
milliseconds, and then issue a retry (without a break). (This period of 87 milliseconds includes
the 16.67 milliseconds spent waiting for a response from the sensor.) If a correct response is not
received after re-transmitting the command at least two more times, with at least one of those
retries more than 100 milliseconds after the end of the break, the entire sequence (including
the break and the retries) should be repeated at least two more times. The flow chart in appendix
B of this document illustrates this retry logic. At least one of the retries must be issued after 100
milliseconds after the falling edge of the break to ensure that the sensor has been given the full
100 milliseconds to wake up after the break. A retry is needed if one of the following three
conditions exist:
1) no response from the sensor;
2) 8.33 milliseconds of marking on the data line, after receiving the start bit of the
response;
3) an invalid response.
Invalid responses include responses in an incorrect format, parity errors, framing errors,
CRC errors, or bus contentions. The data recorder must wait for the response to complete before
sending a retry. If one of the above conditions exists, the data recorder will issue retries. Under
extraordinary conditions, not as normal operating procedure, the data recorder has the option of
not issuing retries.

2/20/2023 Version 1.4

36

APPENDICES

2/20/2023 Version 1.4

37

Appendix A
Suggested SDI-12 Circuits

s
e
ns
orordat
ar
e
c
or
de
r
i
nt
e
r
f
ac
ec
i
r
c
ui
t
wi
t
h
t
r
ans
i
e
ntpr
ot
e
c
t
i
on

2/20/2023

Version 1.4

Appendix B
Suggested SDI-12 Flow Control
for
SDI-12 Data Recorders and Sensors

2/20/2023 Version 1.4

B-1

start

SDI-12 Sensor
Flow Chart

!

!

2/20/2023 Version 1.4

Page B-2

Appendix C
SDI-12 Glossary

2/20/2023 Version 1.4

B-3

Appendix C: SDI-12 Glossary

Address. A single character used to identify each sensor on the SDI-12 bus. The first character
of every command and the first character of every response is an address. The normal address
characters are "0" to "9."
Basic command set. The following SDI-12 commands: a!, aAb!, ?!, aI!, aM!, aM1! . . . aM9!,
aC!, aC1! . . . aC9!, aD0! . . . aD9!, aR0! . . . aR9!, aV!, aMC!, aMC1! . . . aMC9!, aCC!, aCC1!
.. . .aCC9!, aRC0! . . . aRC9!
Break. Continuous spacing, by the data recorder, on the data line for at least 12 milliseconds.
This is a special condition used to wake sensors from a low power standby mode.
Buffer. Memory in the sensor that holds the sensor's most recent measurement. A sensor is
required to keep this information until it receives a new M or V command. When a sensor has a
measurement in its buffer, repeated D commands cause it to return the same data each time the D
command is issued. If, however, a break occurs while a sensor is making a measurement in
response to an M or V command, the sensor must abort its measurement and empty its data
buffer. In this case, no data is returned in response to a D command.
Byte frame format. The manner in which a character is encoded for serial transmission. SDI-12
uses 1 start bit, 7 data bits, even parity, and 1 stop bit.
CRC. Cyclical redundancy check, a form of error checking. The sensor appends a number,
which is encoded as ASCII characters, that is related mathematically to the characters to be
transmitted to the data recorder. Upon receiving the data, the data recorder recomputed the CRC
value to verify that the data was received without error.
Data bits. The bits in a character that carry information, as opposed to the start bit, the parity bit,
and the stop bit. SDI-12 uses 7 data bits.
Extended command. A command not in the basic SDI-12 command set. Extended commands
are defined by the manufacturer of the sensor. Extended commands calibrate sensors, run
diagnostic tests in sensors, and perform other tasks specific to a sensor.
Even parity. Setting the parity bit to 0 or 1, as needed, to ensure that the total number of binary
ones in the data bits and the parity bit are an even number. SDI-12 uses even, as opposed to odd,
parity.
Marking. A binary state of 1 on the SDI-12 data line, with a voltage range of -0.5 to 1.0 volts.
Parity bit. A bit after the data bits in a character, used for error detection. SDI-12 uses even
parity.

2/20/2022 Version 1.4

C-1

Printable characters. ASCII characters in the range 20 hex (a space) through 7E hex (~).
SDI-12 command. A string with 2 or more printable characters that will be sent to an SDI-12
sensor. The first character of an SDI-12 command is an address and the last character is an
exclamation point (!).
SDI-12 bus. A cable with three conductors: (1) serial data, (2) ground, and (3) 12 volts--used to
connect an SDI-12 data recorder with one to ten SDI-12 sensors.
SDI-12 data recorder. A data acquisition device that can be interfaced with one or more SDI-12
sensors. The recorder polls the sensor using the SDI-12 electrical interface and the SDI-12
communications protocol.
SDI-12 response. A string with 3 or more characters, returned to an SDI-12 data recorder by an
SDI-12 sensor. The first character of an SDI-12 response is an address and the last two
characters are a carriage return/line feed (<CR><LF>). Other than the carriage return/line feed,
all characters must be printable ASCII characters.
SDI-12 sensor. A measurement device that can be polled by an SDI-12 data recorder, using the
SDI-12 electrical interface and the SDI-12 communications protocol.
Service request. An address followed by carriage return/line feed (a<CR><LF). This is issued
by a sensor, after an M or V command, to tell the data recorder that the requested measurements
are ready.
Spacing. A binary state of 0 on the SDI-12 data line, with a voltage range of 3.5 to 5.5 volts.
Start bit. A bit indicating the start of a new character in an SDI-12 command or response.
Stop bit. A bit indicating the end of a character in an SDI-12 command or response. SDI-12
specifies one stop bit.
Transparent mode. A mode in an SDI-12 data recorder in which extended commands (or basic
commands), received from a computer, a terminal, or a modem can be sent to a sensor. In
transparent mode the data recorder buffers characters until terminated, wakes the sensor with a
break, and sends the command string to the sensor. An example of transparent mode is a data
recorder interfaced to a PC via a serial port. The user enters SDI-12 commands on the keyboard,
and the command is transmitted to the data recorder. The recorder reads the command, transmits
it to the sensor, and returns the response to the PC. The PC then displays the response.

2/20/2022 Version 1.4

C-2

<values> A string of one or more data values (e.g. measurements) returned from a sensor in
response to a D or an R command; each data value is in this format:
pd.d
where:
p - the polarity sign (+ or -) (required)
d - numeric digits before the decimal point
. - the decimal point (optional)
d - numeric digits after the decimal point
the maximum number of digits for a data value is 7, even without a decimal point
the minimum number of digits for a data value (excluding the decimal point) is 1
the maximum number of characters in a data value is 9 (polarity sign + 7 digits +
the decimal point)

2/20/2022 Version 1.4

C-3

Appendix D
Revisions

Appendix D: Revisions
Version 1.4 February 20, 2023
Added section 4.4.13.1, Extended Commands Returning Multiple Lines of Text.
Changed all instances of “high volume” to “high-volume.”
SDI-12 remains at Version 1.4 because the specification was not changed.
Version 1.4 January 30, 2021
Added two clarifications without changing the specification.
Paragraph 7.2, Retries, was modified by deleting two sentences and removing the word
master from this document. The use of the word master, and the two deleted sentences are
unneeded in describing retries. The word master was removed to join others in the digital design,
software, and information technology industries, eliminating the words master, slave, or both.
Modified the sensor flow chart in Appendix B-2, by making it clear what a sensor is
expected to do when it receives another command while in the processing of a concurrent
measurement. This was done by adding the decision, D command and processing done, when
executing the logic to manage a C command. Also added a title to the sensor flow chart.
Version 1.4 January 10, 2018
No changes or clarifications made to the specification. Added a sentence to Table 5, The
SDI-12 basic command/response set, on page 8: “See Tables 12 and 13 for the high-volume
commands (pages 24-25), Table 19 for the identify measurement commands (page 29), and
Table 20 for the identify measurement parameter commands (page 32),” so that references to all
SDI-12 commands are included on page 8.
Version 1.4 December 1, 2017
No changes or clarifications made to the specification. Made internal formatting changes
only, adding bookmarks for Portable Document File (PDF) readers to quickly see and go to
specific sections.
Version 1.4 May 1, 2017
Clarifications only made to the specification:
1) Page 10, Table 7, the send identification command, had numerous typographic errors
and omissions, introduced when this document was upgraded from version 1.3 to version 1.4.
Restored the content in the table to its original condition, correcting the errors.

2/20/2023 Version 1.4

D-1

2) Page 32, Section 6.2.4, examples of the identify measurement parameter commands:
example (a) and example (c) were missing the letter “I” in the command. Added the letter “I”.
3) Pages 31 and 32, Table 20, the identify measurement parameter commands, column
two was missing <CRC> for the measurement commands that return a CRC. It said:
a,field1,field2;<CR><LF>
rather than:
a,field1,field2;<CRC><CR><LF>
Added <CRC> for all of the measurement commands that return a CRC.
4) Page 28, Section 5.4, Compliance with High-Volume Command, omitted stating what
the required response is, to the aHA! and aHB! commands, for sensors that do not support the
high-volume commands. Added the following paragraph to correct this omission, as the same
requirement is imposed on the other measurement commands.
“Version 1.4 sensors that do not support the high-volume ASCII command, or the
high-volume binary command, should respond with a000000<CR><LF> saying that it has zero
data values ready.”
5) Appendix A-1, Suggested SDI-12 Circuits, had the same label for both circuits.
Restored the label for the bottom circuit to:
“sensor or data recorder interface circuit with transient protection”
Version 1.4 August 15, 2016
Corrected an error: Page 27, Table 17, Rows 1 and 2, Column 2, incorrectly said
“Signed-32 bit integer,” rather than “Signed-16 bit integer.”
Version 1.4 July 14, 2016
Added Sections:
5.0 High-volume Commands
6.0 Metadata Commands
This adds the High-volume ASCII Command, the High-volume Binary Command,
extends the use of the D commands to get up to 999 data values, adds binary data packets in
response to the High-volume Binary Command, adds the Identify Measurement Commands, and
the Identify Measurement Parameter Commands.

2/20/2023 Version 1.4

D-2

Renumbered section 5.0 SDI-Timing to 7.0 SDI-12 Timing.
Updated the table of contents to include the additions.
Other modifications, as needed, to include text about the High-volume Commands and
the Metadata Commands, throughout the document.
Numerous clarifications in response to a full review by the SDI-12 Support Group’s
Technical Committee: some rewording, moved (without changing) some sentences and
paragraphs, corrected some typo-graphical errors, and corrected some minor formatting issues.
Version 1.3 January 28, 2016
Clarifications only made to the specification:
1) Page 26, Section 5.2. Added “CRC error” to the first sentence of the last paragraph as
one of five invalid response conditions, from a sensor, that require a data recorder retry.
2) Page 26, Section 5.2. Deleted the word three in the sentence, “If one of the above three
conditions exists the data recorder will issue retries.”
3) Appendix B-2, SDI-12 Sensor Flow Chart. Added “set data line to marking for 8.33
ms” to the box between “valid command?” and “more processing?” This clarifies the
supporting text on page 24, Section 5.0, which says, “After receiving the break and the
command, the addressed sensor sets the data line to marking for 8.33 milliseconds and then
sends the response.”
4) Appendices B-1 and B-2, SDI-12 Data Recorder Flow Chart/SDI-12 Sensor Flow
Chart. Changed all instances of “msec” to the correct abbreviation of “ms.”
Version 1.3 January 26, 2013
Clarifications only made to the specification:
1) Page 1, Section 1.0. Added “see section 3.0 for details” to the third bullet.
2) Page 1, Section 1.0. Deleted the fourth bullet, “Up to 200 feet of cable between a
sensor and data recorder.”
3) Page 11, Table 9. Made a correction. Changed “a valid range of 0 to 9" to “a valid
range of 1 to 9" in row 3, column 2.
4) Page 14, Table 10. Deleted this text, “(a data recorder must be able to read and store at
least 20 parameters from a sensor, nn = 20)”

2/20/2023 Version 1.4

D-3

5) Page 14, Section 4.4.7. Deleted this text, “The maximum number of data values a
sensor can return for nn is 20. A data recorder is also required to store 20 values. Future versions
of SDI-12 may increase this to a maximum of up to 99 values.”
6) Page 14, Section 4.4.7. Added this text, “The data recorder should document the
number of data values it can store in response to a C command.”
7) Page 14, Section 4.4.7. Changed the last paragraph from:
See the send data command, aD0!, aD1! . . . Ad9! for examples of this command. Because the
start concurrent measurement command is closely related to the send data command, examples
for both commands are in sections 4.4.8.3 and 4.4.8.4.
To:
“See the send data command, aD0!, aD1! . . . aD9!, section 4.4.8, for the data response
requirements. Because the start concurrent measurement command is closely related to the send
data command, examples for both commands are in sections 4.4.8.3 and 4.4.8.4.”
8) Page 14, Section 4.4.8. Change the paragraph heading from “aD0! ... aD9!” to “aD0!,
...aD1 ... aD9!.”
Version 1.3

January 3, 2012

Clarifications only made to the specification:
1) Page 5, Section 4.0. Reference to page 14 changed to reference to section 4.4.7.
2) Page 12, Section 4.4.5.1. Deleted the sentence, “It must also empty its buffer so that no
data are returned in response to a D command.” This sentence was deleted because the sentence
after it specifically states what information is to be returned to the sensor in response to
subsequent D commands.
3) Page 14, Section 4.4.7.1. Deleted the sentence, “It must also empty is buffer so that no
data are returned in response to a D command.” This sentence was deleted because the sentence
after it specifically states what information is to be returned to the sensor in response to
subsequent D commands.
4) Page 16, Section 4.4.8.3. Reference to section 4.4 changed to section 4.4.8.
5) Page 16, Section 4.4.8.3. Circular reference to section 4.4.8.3 changed to section
4.4.8.4.
6) Page 23, Section 4.4.13. Corrected typographical error. Deleted the letter s from

2/20/2023 Version 1.4

D-4

“extendeds.”
7) Formatted all paragraph headings in bold.
8) Changed Appendix B, Suggested SDI-12 Flow Control for SDI-12 Data Recorded so
that the logic for the concurrent command matches the text in the body of the document:
a) top left rectangle: deleted the text “in its buffer”
b) top left oval: changed “making” to “marking.”
c) bottom left rectangle: deleted the phrase “empty buffer so”
d) bottom right rectangle: changed the text so that it matches the text in the bottom left
rectangle
e) the “yes” branch of the “C command” decision now goes to the oval “look for address,
break, or 100 msec timeout while processing the command,” rather than the oval “look
for break while processing the command”
f) the “no” branch of “valid command” in the C command processing section now goes to
the oval “look for address, break, or 100 msec timeout while processing the command,”
rather than the oval “look for break while processing the command” oval
g) switched the positions of the two columns of logic for the C command logic to
minimize the crossing of lines
Version 1.3

January 12, 2009

Clarifications only made to the specification:
1) Page 2, Section 3.0. Appended a phrase and a sentence: “, each with 200 feet of cable.
With fewer sensors, longer cable lengths are possible.”
2) Page 4, Section 3.12. Added a sentence: “Due to this impedance, the maximum cable
length depends on the capacitance of all cables connected to the SDI-12 data line.”
3) Page 12, Section 4.4.5. Added a sentence: “The data recorder may wait for the entire
ttt time. Therefore, the tolerance above the measurement time, added to ttt, should be minimal
Version 1.3

July 18, 2005

Clarifications only made to the specification:
1) Page 7, Section 4.4. Added a sentence: “None of the basic commands should affect the
sensor’s calibration.”
2) Page 12, Section 4.4.5.1. Added “or this sensor,” to the sentence at the bottom of the
page.
3) Page 16. Corrected a typographical error.

2/20/2023 Version 1.4

D-5

Version 1.3

July 25, 2004

Clarifications only made to the specification:
1) Page 8, Table 5. Changed “same as the D commands” to “formatted like the D
commands.”
2) Page 16. Changed “The R commands (R0! ... R9!) work exactly like the D commands
(D0! ... D9!).” to “The response to R commands (R0! ... R9!) are formatted like the D commands
(D0! ... D9!).”
3) Page 16. Changed “The only difference is that the R commands do not need to be
preceded with an M command ...” to “The main difference is that the R commands do not need
to be precede with an M command ...”
4) Page 16. Added a new paragraph:
Each R command is an independent measurement. For example, R5 need not be preceded
by R0 ... R4.
5) Page 16. Changed “If a CRC was requested then a CRC must be appended to the
address.” to “If a CRC was requested then the <CR><LF> must be preceded by the CRC.”
6) Page 20. Changed “When these commands are used, the data returned in response to
the D commands must have a CRC code appended to it.” to “When these commands are used,
the data returned in response to the D commands, or R commands, must have a CRC code
appended to it.”
Version 1.3

September 17, 2002

Clarifications only made to the specification:
1) Page 8. Corrected the footnote at the bottom of Table 5 to reference section 4.4.6
rather than section 4.4.12. Section 4.4.6 is the correct section that footnote should reference.
2) Page 9. Added “The “!” character can only be used in a command as the terminator
character.”
3) Page 9. Corrected typographical error; changed “of” to “or.”
4) Page 11, table 9. Added “n is a single digit integer with a valid range of 0 to 9.”
5) Page 12 and Page 14. Added “(or followed by <CRC><CR><LF> if a CRC was
requested).”

2/20/2023 Version 1.4

D-6

6) Page 13. Changed: “A service request is issued by the sensor, after an M or V
command, when it has finished its measurement.” To: “A service request is issued by the
sensor, after an M, MC, or V command, when it has finished its measurement.”
7) Page 15, table 11, Added “the minimum number of digits for a data value (excluding
the decimal point) is 1.”
8) Page 16. Added “If a CRC was requested then a CRC must be appended to the
address. For example: 0AP@<CR><LF>.”
9) Page 20. Added “All shifts shift in a zero.”
10) Page 22. Corrected an error in an example that shows a sensor response with a CRC
value (changed 1.1234 to 1.234). With the additional ‘1' in the data, the CRC value shown in the
example was incorrect.
11) Page 25. Corrected typographical error; changed “sensor” to “data recorder.”
12) Page B-2. Corrected typographical error; changed “emty” to “empty.”
13) Page C-3. Added “the minimum number of digits for a data value (excluding the
decimal point) is 1.”
Version 1.3

April 7, 2000

1) Added a Cyclic Redundancy Check (CRC) to data returned from SDI-12 Sensors, by
the use of existing commands with a C appended, namely: aMC!, aMC1! ... aMC9!, aCC1! ...
aCC9!, and aRC0! ... aRC9!.
2) Changed the Data Line “OFF” impedance to be less restrictive (160K to 360K ohms,
rather than 200K ohms with a plus or minus 10% tolerance.
3) Reworded the paragraph about inductive loading.
4) Clarified the definition of low power standby mode.
Version 1.2

October 21, 1996

Clarifications only made to the specification:
1) Page 2. Added the following statement, which was in Version 1.0, but omitted from
Versions 1.1 and 1.2 (4/12/96) by mistake.
"In the following specifications, all values not indicating specific limits, have an
allowable tolerance of ±10% of the value."

2/20/2023 Version 1.4

D-7

2) Page 12. Added text to clarify when ttt seconds begins and added text to advise sensor
designers to return a ttt value that is greater than the time it takes the sensor to take a
measurement.
"The ttt time period begins upon completion of the transmission of the line feed
character."
"A sensor should return a ttt value greater than the time it takes to make a measurement,
to allow for timing tolerances and for the service request. (See section 4.4.6.)"
3) Page 14. Added text to clarify when ttt seconds begins.
"The ttt time period begins immediately after the sensor transmits the <LF> character."
Version 1.2

April 12, 1996

1) Added the concurrent measurement command (aC!) and the additional concurrent
measurement commands (aC1! . . . aC9!) to the basic command set.
2) Clarified the section on data recorder retries to indicate that a data recorder must issue
retries unless it has received a valid response or if it wishes to abort the measurement.
3) Clarified the no data response to the additional measurement commands (aM! . . .
aM9!)
4) Added the address query command (?!) to the basic command set.
5) Added the change address command (aAb!) to the basic command set.
6) Added the continuous measurement command (aR0! . . . aR9!) to the command set.
Version 1.1

July 7, 1994

Rewrite and clarification of the original specification. No technical changes.
Version 1.0

October 1988

Original release.

2/20/2023 Version 1.4

D-8



=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/address.rs
=======================
// src/common/address.rs

use super::error::Sdi12Error;
use core::convert::TryFrom;
use core::fmt;

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
pub struct Sdi12Addr(char);

impl Sdi12Addr {
    pub const DEFAULT_ADDRESS: Sdi12Addr = Sdi12Addr('0');
    pub const QUERY_ADDRESS: Sdi12Addr = Sdi12Addr('?');

    /// Creates a new `Sdi12Addr` if the given character is a valid address.
    /// Returns `Result<Self, Sdi12Error<()>>` because validation itself
    /// cannot cause an I/O error.
    pub fn new(address_char: char) -> Result<Self, Sdi12Error<()>> {
        if Self::is_valid_address_char(address_char) || address_char == '?' {
            Ok(Sdi12Addr(address_char))
        } else {
            // Directly create the specific error variant with E = ()
            Err(Sdi12Error::InvalidAddress(address_char))
        }
    }

    // Unsafe constructor remains the same
    pub const unsafe fn new_unchecked(address_char: char) -> Self {
        Sdi12Addr(address_char)
    }

    #[inline]
    pub const fn as_char(&self) -> char {
        self.0
    }

    #[inline]
    pub const fn is_query(&self) -> bool {
        self.0 == '?'
    }

    #[inline]
    pub const fn is_standard(&self) -> bool {
        // This one was okay because '0'..='9' is a single range pattern
        matches!(self.0, '0'..='9')
    }

    #[inline]
    pub const fn is_extended(&self) -> bool {
        // CORRECTED: Use '|' directly as a pattern separator
        matches!(self.0, 'a'..='z' | 'A'..='Z')
    }

    #[inline]
    pub const fn is_valid_address_char(c: char) -> bool {
        // CORRECTED: Use '|' directly as a pattern separator
        matches!(c, '0'..='9' | 'a'..='z' | 'A'..='Z')
    }
}

impl Default for Sdi12Addr {
    fn default() -> Self {
        Self::DEFAULT_ADDRESS
    }
}

// CORRECTED: Implement TryFrom<char> without the generic E
impl TryFrom<char> for Sdi12Addr {
    // The error type here is specific: Sdi12Error with no I/O error possibility
    type Error = Sdi12Error<()>;

    /// Attempts to convert a character into an `Sdi12Addr`.
    fn try_from(value: char) -> Result<Self, Self::Error> {
        // Reuse the validation logic from Self::new()
        // Since Self::new() now returns Result<_, Sdi12Error<()>>, this works directly.
        Self::new(value)
        // Or, implement directly:
        // if Sdi12Addr::is_valid_address_char(value) || value == '?' {
        //     Ok(Sdi12Addr(value))
        // } else {
        //     Err(Sdi12Error::InvalidAddress(value))
        // }
    }
}


impl From<Sdi12Addr> for char {
    fn from(value: Sdi12Addr) -> Self {
        value.0
    }
}

impl fmt::Display for Sdi12Addr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    // Mock error type is no longer strictly needed inside the tests for `new` or `try_from`
    // because they now return `Sdi12Error<()>` which doesn't involve a generic `E`.
    // We might still need it later for testing functions that *do* take an E.
    #[derive(Debug, Clone, PartialEq, Eq)]
    struct MockIoError;
    impl fmt::Display for MockIoError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "Mock I/O Error") }
    }

    #[test]
    fn test_valid_addresses() {
        assert!(Sdi12Addr::new('0').is_ok());
        assert!(Sdi12Addr::new('5').is_ok());
        assert!(Sdi12Addr::new('9').is_ok());
        assert!(Sdi12Addr::new('a').is_ok());
        assert!(Sdi12Addr::new('z').is_ok());
        assert!(Sdi12Addr::new('A').is_ok());
        assert!(Sdi12Addr::new('Z').is_ok());
        assert!(Sdi12Addr::new('?').is_ok());
    }

    #[test]
    fn test_invalid_addresses() {
        assert!(matches!(Sdi12Addr::new(' '), Err(Sdi12Error::InvalidAddress(' '))));
        assert!(matches!(Sdi12Addr::new('$'), Err(Sdi12Error::InvalidAddress('$'))));
        assert!(matches!(Sdi12Addr::new('\n'), Err(Sdi12Error::InvalidAddress('\n'))));
        assert!(matches!(Sdi12Addr::new('é'), Err(Sdi12Error::InvalidAddress('é'))));
    }

    // test_default_address, test_query_address, test_address_types remain the same

    #[test]
    fn test_try_from_char() {
        assert_eq!(Sdi12Addr::try_from('1').unwrap(), Sdi12Addr('1'));
        assert_eq!(Sdi12Addr::try_from('b').unwrap(), Sdi12Addr('b'));
        assert_eq!(Sdi12Addr::try_from('C').unwrap(), Sdi12Addr('C'));
        assert_eq!(Sdi12Addr::try_from('?').unwrap(), Sdi12Addr('?'));
        assert!(matches!(Sdi12Addr::try_from('*'), Err(Sdi12Error::InvalidAddress('*'))));
    }

    // test_into_char, test_display, test_as_char, test_is_valid_address_char, test_new_unchecked remain the same
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/command.rs
=======================
// src/common/command.rs

use super::address::Sdi12Addr;
use core::convert::TryFrom;
use core::fmt::{self, Write}; // Need core::fmt::Write
use arrayvec::ArrayString; // Use ArrayString for formatting

// --- Conditionally import String ---
#[cfg(feature = "alloc")]
use alloc::string::String;

// --- Error Type for Index Validation ---

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum CommandIndexError {
    MeasurementOutOfRange,    // For M/MC/C/CC (1-9)
    ContinuousOutOfRange,     // For R/RC (0-9)
    DataOutOfRange,           // For D/DB (0-999)
    IdentifyParamOutOfRange, // For _nnn (1-999)
}

impl fmt::Display for CommandIndexError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CommandIndexError::MeasurementOutOfRange => write!(f, "Measurement index must be 1-9"),
            CommandIndexError::ContinuousOutOfRange => write!(f, "Continuous index must be 0-9"),
            CommandIndexError::DataOutOfRange => write!(f, "Data index must be 0-999"),
            CommandIndexError::IdentifyParamOutOfRange => write!(f, "Identify Parameter index must be 1-999"),
        }
    }
}

// --- Error Type for Formatting ---
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum CommandFormatError {
    /// The provided buffer was too small.
    BufferOverflow,
    /// A formatting error occurred (e.g., writing number failed).
    FmtError,
}
impl From<core::fmt::Error> for CommandFormatError {
    fn from(_: core::fmt::Error) -> Self { CommandFormatError::FmtError }
}


// --- Validated Index Types ---

/// Represents the index `n` for M[n], MC[n], C[n], CC[n] commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum MeasurementIndex {
    Base,
    Indexed(u8), // 1-9
}

impl MeasurementIndex {
    pub fn new(index_opt: Option<u8>) -> Result<Self, CommandIndexError> {
        match index_opt {
            None => Ok(Self::Base),
            Some(i) if (1..=9).contains(&i) => Ok(Self::Indexed(i)),
            Some(_) => Err(CommandIndexError::MeasurementOutOfRange),
        }
    }
    pub fn as_option(&self) -> Option<u8> {
        match self { Self::Base => None, Self::Indexed(i) => Some(*i) }
    }
}

/// Represents the index `n` for R[n], RC[n] commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ContinuousIndex(u8); // 0-9

impl ContinuousIndex {
    pub fn new(index: u8) -> Result<Self, CommandIndexError> {
        if index <= 9 { Ok(Self(index)) } else { Err(CommandIndexError::ContinuousOutOfRange) }
    }
    pub fn value(&self) -> u8 { self.0 }
}
impl TryFrom<u8> for ContinuousIndex {
    type Error = CommandIndexError;
    fn try_from(value: u8) -> Result<Self, Self::Error> { Self::new(value) }
}

/// Represents the index `n` for D[n], DB[n] commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct DataIndex(u16); // 0-999

impl DataIndex {
    pub fn new(index: u16) -> Result<Self, CommandIndexError> {
        if index <= 999 { Ok(Self(index)) } else { Err(CommandIndexError::DataOutOfRange) }
    }
    pub fn value(&self) -> u16 { self.0 }
}
impl TryFrom<u16> for DataIndex {
    type Error = CommandIndexError;
    fn try_from(value: u16) -> Result<Self, Self::Error> { Self::new(value) }
}

/// Represents the parameter index `nnn` for Identify Measurement Parameter commands.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct IdentifyParameterIndex(u16); // 1-999

impl IdentifyParameterIndex {
    pub fn new(index: u16) -> Result<Self, CommandIndexError> {
        if (1..=999).contains(&index) { Ok(Self(index)) } else { Err(CommandIndexError::IdentifyParamOutOfRange) }
    }
    pub fn value(&self) -> u16 { self.0 }
}
impl TryFrom<u16> for IdentifyParameterIndex {
    type Error = CommandIndexError;
    fn try_from(value: u16) -> Result<Self, Self::Error> { Self::new(value) }
}


// --- Main Command Enum ---

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Command {
    AcknowledgeActive { address: Sdi12Addr },
    SendIdentification { address: Sdi12Addr },
    AddressQuery,
    ChangeAddress { address: Sdi12Addr, new_address: Sdi12Addr },
    StartMeasurement { address: Sdi12Addr, index: MeasurementIndex },
    StartMeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
    StartConcurrentMeasurement { address: Sdi12Addr, index: MeasurementIndex },
    StartConcurrentMeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
    SendData { address: Sdi12Addr, index: DataIndex },
    SendBinaryData { address: Sdi12Addr, index: DataIndex },
    ReadContinuous { address: Sdi12Addr, index: ContinuousIndex },
    ReadContinuousCRC { address: Sdi12Addr, index: ContinuousIndex },
    StartVerification { address: Sdi12Addr },
    StartHighVolumeASCII { address: Sdi12Addr },
    StartHighVolumeBinary { address: Sdi12Addr },
    IdentifyMeasurement(IdentifyMeasurementCommand),
    IdentifyMeasurementParameter(IdentifyMeasurementParameterCommand),
    #[cfg(feature = "alloc")]
    ExtendedCommand { address: Sdi12Addr, command_body: String },
}


impl Command {
    const MAX_FORMATTED_LEN: usize = 10; // aICC9_999!

    /// Formats the command into the standard byte sequence (e.g., "0M!", "1D10!") including the '!'.
    /// Writes into a fixed-size buffer (ArrayString) to avoid allocation.
    pub fn format_into(&self) -> Result<ArrayString<[u8; {Self::MAX_FORMATTED_LEN}]>, CommandFormatError> { // Used {{N}} as suggested by compiler error
        let mut buffer = ArrayString::<[u8; {Self::MAX_FORMATTED_LEN}]>::new(); // Used {{N}}

        match self {
            Command::AcknowledgeActive { address } => write!(buffer, "{}!", address)?,
            Command::SendIdentification { address } => write!(buffer, "{}I!", address)?,
            Command::AddressQuery => write!(buffer, "?!")?,
            Command::ChangeAddress { address, new_address } => write!(buffer, "{}A{}!", address, new_address)?,

            Command::StartMeasurement { address, index } => {
                write!(buffer, "{}M", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::StartMeasurementCRC { address, index } => {
                write!(buffer, "{}MC", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::StartConcurrentMeasurement { address, index } => {
                 write!(buffer, "{}C", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::StartConcurrentMeasurementCRC { address, index } => {
                 write!(buffer, "{}CC", address)?;
                if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; }
                write!(buffer, "!")?;
            }
            Command::SendData { address, index } => write!(buffer, "{}D{}!", address, index.value())?,
            Command::SendBinaryData { address, index } => write!(buffer, "{}DB{}!", address, index.value())?,
            Command::ReadContinuous { address, index } => write!(buffer, "{}R{}!", address, index.value())?,
            Command::ReadContinuousCRC { address, index } => write!(buffer, "{}RC{}!", address, index.value())?,
            Command::StartVerification { address } => write!(buffer, "{}V!", address)?,
            Command::StartHighVolumeASCII { address } => write!(buffer, "{}HA!", address)?,
            Command::StartHighVolumeBinary { address } => write!(buffer, "{}HB!", address)?,

            Command::IdentifyMeasurement(cmd) => {
                match cmd {
                    IdentifyMeasurementCommand::Measurement { address, index } => { write!(buffer, "{}IM", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::MeasurementCRC { address, index } => { write!(buffer, "{}IMC", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::Verification { address } => write!(buffer, "{}IV", address)?,
                    IdentifyMeasurementCommand::ConcurrentMeasurement { address, index } => { write!(buffer, "{}IC", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::ConcurrentMeasurementCRC { address, index } => { write!(buffer, "{}ICC", address)?; if let MeasurementIndex::Indexed(i) = index { write!(buffer, "{}", i)?; } }
                    IdentifyMeasurementCommand::HighVolumeASCII { address } => write!(buffer, "{}IHA", address)?,
                    IdentifyMeasurementCommand::HighVolumeBinary { address } => write!(buffer, "{}IHB", address)?,
                }
                write!(buffer, "!")?;
            }
            Command::IdentifyMeasurementParameter(cmd) => {
                match cmd {
                     IdentifyMeasurementParameterCommand::Measurement { address, m_index, param_index } => { write!(buffer, "{}IM", address)?; if let MeasurementIndex::Indexed(i) = m_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::MeasurementCRC { address, m_index, param_index } => { write!(buffer, "{}IMC", address)?; if let MeasurementIndex::Indexed(i) = m_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::Verification { address, param_index } => { write!(buffer, "{}IV_{:03}", address, param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ConcurrentMeasurement { address, c_index, param_index } => { write!(buffer, "{}IC", address)?; if let MeasurementIndex::Indexed(i) = c_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ConcurrentMeasurementCRC { address, c_index, param_index } => { write!(buffer, "{}ICC", address)?; if let MeasurementIndex::Indexed(i) = c_index { write!(buffer, "{}", i)?; } write!(buffer, "_{:03}", param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ReadContinuous { address, r_index, param_index } => { write!(buffer, "{}IR{}_{:03}", address, r_index.value(), param_index.value())?; }
                     IdentifyMeasurementParameterCommand::ReadContinuousCRC { address, r_index, param_index } => { write!(buffer, "{}IRC{}_{:03}", address, r_index.value(), param_index.value())?; }
                     IdentifyMeasurementParameterCommand::HighVolumeASCII { address, param_index } => { write!(buffer, "{}IHA_{:03}", address, param_index.value())?; }
                     IdentifyMeasurementParameterCommand::HighVolumeBinary { address, param_index } => { write!(buffer, "{}IHB_{:03}", address, param_index.value())?; }
                }
                 write!(buffer, "!")?;
            }

            #[cfg(feature = "alloc")]
            Command::ExtendedCommand { address, command_body } => {
                 write!(buffer, "{}{}", address, command_body)?;
                 if buffer.len() >= buffer.capacity() { return Err(CommandFormatError::BufferOverflow); }
                 buffer.try_push('!').map_err(|_| CommandFormatError::BufferOverflow)?;
             }
        }
        Ok(buffer)
    }
}


// --- Metadata Sub-Enums ---

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum IdentifyMeasurementCommand {
    Measurement { address: Sdi12Addr, index: MeasurementIndex },
    MeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
    Verification { address: Sdi12Addr },
    ConcurrentMeasurement { address: Sdi12Addr, index: MeasurementIndex },
    ConcurrentMeasurementCRC { address: Sdi12Addr, index: MeasurementIndex },
    HighVolumeASCII { address: Sdi12Addr },
    HighVolumeBinary { address: Sdi12Addr },
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum IdentifyMeasurementParameterCommand {
    Measurement { address: Sdi12Addr, m_index: MeasurementIndex, param_index: IdentifyParameterIndex },
    MeasurementCRC { address: Sdi12Addr, m_index: MeasurementIndex, param_index: IdentifyParameterIndex },
    Verification { address: Sdi12Addr, param_index: IdentifyParameterIndex },
    ConcurrentMeasurement { address: Sdi12Addr, c_index: MeasurementIndex, param_index: IdentifyParameterIndex },
    ConcurrentMeasurementCRC { address: Sdi12Addr, c_index: MeasurementIndex, param_index: IdentifyParameterIndex },
    ReadContinuous { address: Sdi12Addr, r_index: ContinuousIndex, param_index: IdentifyParameterIndex },
    ReadContinuousCRC { address: Sdi12Addr, r_index: ContinuousIndex, param_index: IdentifyParameterIndex },
    HighVolumeASCII { address: Sdi12Addr, param_index: IdentifyParameterIndex },
    HighVolumeBinary { address: Sdi12Addr, param_index: IdentifyParameterIndex },
}


// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::address::Sdi12Addr;

    #[cfg(feature = "alloc")]
    use alloc::string::ToString;

    fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    #[test] fn test_measurement_index_validation() { /* unchanged */ }
    #[test] fn test_continuous_index_validation() { /* unchanged */ }
    #[test] fn test_data_index_validation() { /* unchanged */ }
    #[test] fn test_identify_param_index_validation() { /* unchanged */ }
    #[test] fn test_command_construction() { /* unchanged */ }
    #[test] fn test_command_formatting() { /* unchanged */ }
    #[test] #[cfg(feature = "alloc")] fn test_format_extended_command() { /* unchanged */ }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/crc.rs
=======================
// src/common/crc.rs

use super::error::Sdi12Error;
use crc::{Crc, Algorithm};

/// Custom CRC algorithm matching SDI-12 specification (CRC-16/ARC).
/// Polynomial: 0x8005 (normal representation of 0xA001 reversed)
/// Initial Value: 0x0000
/// Input Reflected: true
/// Output Reflected: true
/// Final XOR: 0x0000
/// Check Value: 0xBB3D (for "123456789") - standard for CRC-16/ARC
/// Residue: 0x0000
pub const SDI12_CRC: Algorithm<u16> = Algorithm {
    poly: 0x8005,
    init: 0x0000,
    refin: true,
    refout: true,
    xorout: 0x0000,
    check: 0xBB3D,
    width: 16,
    residue: 0x0000,
};

// Create a Crc instance for the SDI-12 algorithm for reuse.
const CRC_COMPUTER: Crc<u16> = Crc::<u16>::new(&SDI12_CRC);

/// Calculates the SDI-12 CRC-16 (CRC-16/ARC) for the given data buffer.
///
/// Uses the `crc` crate configured for the standard CRC-16/ARC algorithm,
/// which matches the SDI-12 specification. The calculation starts from the
/// first byte (typically the address) up to the byte *before* the CRC
/// itself or the trailing `<CR><LF>`.
///
/// # Arguments
///
/// * `data`: A slice of bytes for which to calculate the CRC.
///
/// # Returns
///
/// The calculated 16-bit CRC value.
#[inline]
pub fn calculate_crc16(data: &[u8]) -> u16 {
    CRC_COMPUTER.checksum(data)
}

/// Encodes a 16-bit CRC value into three ASCII characters according to SDI-12 standard.
///
/// Follows section 4.4.12.2 of the SDI-12 specification v1.4.
///
/// # Arguments
///
/// * `crc_value`: The 16-bit CRC to encode.
///
/// # Returns
///
/// An array of three `u8` bytes representing the ASCII-encoded CRC.
pub fn encode_crc_ascii(crc_value: u16) -> [u8; 3] {
    let char1 = 0x40 | ((crc_value >> 12) & 0x3F) as u8;
    let char2 = 0x40 | ((crc_value >> 6) & 0x3F) as u8;
    let char3 = 0x40 | (crc_value & 0x3F) as u8;
    [char1, char2, char3]
}

/// Decodes three SDI-12 ASCII-encoded CRC characters back into a 16-bit value.
///
/// # Arguments
///
/// * `crc_chars`: A slice or array of three `u8` bytes representing the ASCII-encoded CRC.
///
/// # Returns
///
/// The decoded 16-bit CRC value.
///
/// # Panics
///
/// Panics if `crc_chars` does not have a length of exactly 3.
pub fn decode_crc_ascii(crc_chars: &[u8]) -> u16 {
    assert_eq!(crc_chars.len(), 3, "ASCII CRC must be 3 bytes long");
    let byte1 = u16::from(crc_chars[0] & 0x3F);
    let byte2 = u16::from(crc_chars[1] & 0x3F);
    let byte3 = u16::from(crc_chars[2] & 0x3F);
    (byte1 << 12) | (byte2 << 6) | byte3
}

/// Verifies an SDI-12 response string that includes an ASCII CRC.
///
/// Assumes the buffer ends with the 3 CRC bytes and does *not* include `<CR><LF>`.
///
/// # Arguments
///
/// * `response_with_crc`: The response buffer including the 3-byte ASCII CRC.
///
/// # Returns
///
/// * `Ok(())` if the CRC is valid.
/// * `Err(Sdi12Error::InvalidFormat)` if the buffer is too short.
/// * `Err(Sdi12Error::CrcMismatch)` if the CRCs don't match.
pub fn verify_response_crc_ascii<E>(response_with_crc: &[u8]) -> Result<(), Sdi12Error<E>>
where
    E: core::fmt::Debug,
{
    if response_with_crc.len() < 3 {
        return Err(Sdi12Error::InvalidFormat);
    }
    let data_len = response_with_crc.len() - 3;
    let data_part = &response_with_crc[..data_len];
    let received_crc_bytes = &response_with_crc[data_len..];

    let calculated_crc = calculate_crc16(data_part);
    let received_crc = decode_crc_ascii(received_crc_bytes);

    if calculated_crc == received_crc {
        Ok(())
    } else {
        Err(Sdi12Error::CrcMismatch { expected: received_crc, calculated: calculated_crc, })
    }
}

/// Encodes a 16-bit CRC value into two bytes (LSB first) for binary responses.
///
/// # Arguments
///
/// * `crc_value`: The 16-bit CRC to encode.
///
/// # Returns
///
/// An array of two `u8` bytes `[LSB, MSB]`.
pub fn encode_crc_binary(crc_value: u16) -> [u8; 2] {
    crc_value.to_le_bytes()
}

/// Decodes two bytes (LSB first) from a binary response into a 16-bit CRC value.
///
/// # Arguments
///
/// * `crc_bytes`: A slice or array of two `u8` bytes `[LSB, MSB]`.
///
/// # Returns
///
/// The decoded 16-bit CRC value.
///
/// # Panics
///
/// Panics if `crc_bytes` does not have a length of exactly 2.
pub fn decode_crc_binary(crc_bytes: &[u8]) -> u16 {
    assert_eq!(crc_bytes.len(), 2, "Binary CRC must be 2 bytes long");
    u16::from_le_bytes([crc_bytes[0], crc_bytes[1]])
}

/// Verifies an SDI-12 high-volume binary response packet including its binary CRC.
///
/// Assumes the buffer ends with the 2 raw CRC bytes.
///
/// # Arguments
///
/// * `packet_with_crc`: The complete binary packet buffer including the 2-byte CRC.
///
/// # Returns
///
/// * `Ok(())` if the CRC is valid.
/// * `Err(Sdi12Error::InvalidFormat)` if the buffer is too short.
/// * `Err(Sdi12Error::CrcMismatch)` if the CRCs don't match.
pub fn verify_packet_crc_binary<E>(packet_with_crc: &[u8]) -> Result<(), Sdi12Error<E>>
where
    E: core::fmt::Debug,
{
    if packet_with_crc.len() < 2 {
        return Err(Sdi12Error::InvalidFormat);
    }
    let data_len = packet_with_crc.len() - 2;
    let data_part = &packet_with_crc[..data_len];
    let received_crc_bytes = &packet_with_crc[data_len..];

    let calculated_crc = calculate_crc16(data_part);
    let received_crc = decode_crc_binary(received_crc_bytes);

    if calculated_crc == received_crc {
        Ok(())
    } else {
        Err(Sdi12Error::CrcMismatch { expected: received_crc, calculated: calculated_crc, })
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    // Mock error type for verify function generic parameter
    #[derive(Debug, Clone, PartialEq, Eq)]
    struct MockIoError;
    impl core::fmt::Display for MockIoError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result { write!(f, "Mock I/O Error") }
    }

    // --- ASCII CRC Tests Based Directly on Spec v1.4 Section 4.4.12.3 ---

    #[test]
    fn test_spec_example_a() {
        // "0D0!0+3.14OqZ<CR><LF>"
        let data = b"0+3.14";
        let expected_crc_str = b"OqZ";
        let expected_crc_val = decode_crc_ascii(expected_crc_str); // Derive value from spec string

        // 1. Test calculation
        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example A: Calculation mismatch");

        // 2. Test encoding
        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example A: Encoding mismatch");

        // 3. Test verification helper
        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example A: Verification failed");
    }

    #[test]
    fn test_spec_example_b() {
        // "0D0!0+3.14+2.718+1.414Ipz<CR><LF>"
        let data = b"0+3.14+2.718+1.414";
        let expected_crc_str = b"Ipz";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example B: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example B: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example B: Verification failed");
    }

    #[test]
    fn test_spec_example_c_d0() {
        // "0D0!0+1.11+2.22+3.33+4.44+5.55+6.66I]q<CR><LF>"
        let data = b"0+1.11+2.22+3.33+4.44+5.55+6.66";
        let expected_crc_str = b"I]q";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example C D0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example C D0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example C D0: Verification failed");
    }

    #[test]
    fn test_spec_example_c_d1() {
        // "0D1!0+7.77+8.88+9.99IvW<CR><LF>"
        let data = b"0+7.77+8.88+9.99";
        let expected_crc_str = b"IvW";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example C D1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example C D1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example C D1: Verification failed");
    }

    #[test]
    fn test_spec_example_d() {
        // "0D0!0+3.14+2.718IWO<CR><LF>"
        let data = b"0+3.14+2.718";
        let expected_crc_str = b"IWO";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example D: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example D: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example D: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d0() {
        // "0D0!0+3.14OqZ<CR><LF>" - Same as Example A
        let data = b"0+3.14";
        let expected_crc_str = b"OqZ";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D0: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d1() {
        // "0D1!0+2.718Gbc<CR><LF>"
        let data = b"0+2.718";
        let expected_crc_str = b"Gbc";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D1: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d2() {
        // "0D2!0+1.414GtW<CR><LF>"
        let data = b"0+1.414";
        let expected_crc_str = b"GtW";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D2: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D2: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D2: Verification failed");
    }

    #[test]
    fn test_spec_example_f_sensor1() {
        // "1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>"
        let data = b"1+1.23+2.34+345+4.4678";
        let expected_crc_str = b"KoO";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example F S1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example F S1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example F S1: Verification failed");
    }

     #[test]
    fn test_spec_example_f_sensor0() {
        // "0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12Ba]<CR><LF>"
        let data = b"0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12";
        let expected_crc_str = b"Ba]";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example F S0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example F S0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example F S0: Verification failed");
    }


    // --- Binary CRC Tests Based Directly on Spec v1.4 Section 5.2.2 ---

    #[test]
    fn test_spec_binary_example_db0() {
        // Data: 0x31 0x04 0x00 0x03 0xFF 0xFF 0x01 0x00
        // CRC: 0xC2 0xAC -> 0xACC2
        let data = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00];
        let expected_crc_bytes = &[0xC2, 0xAC]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        // 1. Test calculation
        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB0: Calculation mismatch");

        // 2. Test encoding
        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB0: Encoding mismatch");

        // 3. Test verification helper
        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB0: Verification failed");
    }

     #[test]
    fn test_spec_binary_example_db1() {
        // Data: 0x31 0x08 0x00 0x09 0xC3 0xF5 0x48 0x40 0x00 0x00 0x80 0x3F
        // CRC: 0x3B 0x6E -> 0x6E3B
        let data = &[0x31, 0x08, 0x00, 0x09, 0xC3, 0xF5, 0x48, 0x40, 0x00, 0x00, 0x80, 0x3F];
        let expected_crc_bytes = &[0x3B, 0x6E]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB1: Calculation mismatch");

        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB1: Encoding mismatch");

        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB1: Verification failed");
    }

    #[test]
    fn test_spec_binary_example_db2_empty() {
        // Data: 0x31 0x00 0x00 0x00 (Empty packet indicator)
        // CRC: 0x0E 0xFC -> 0xFC0E
        let data = &[0x31, 0x00, 0x00, 0x00];
        let expected_crc_bytes = &[0x0E, 0xFC]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB2: Calculation mismatch");

        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB2: Encoding mismatch");

        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB2: Verification failed");
    }

    // --- Optional: Keep basic roundtrip/error tests if desired ---
    #[test]
    fn test_crc_ascii_encoding_decoding_roundtrip_extra() {
        let test_cases = [0x0000, 0xFFFF, 0x1234, 0xABCD]; // Non-spec examples
        for crc_val in test_cases {
            let encoded = encode_crc_ascii(crc_val);
            let decoded = decode_crc_ascii(&encoded);
            assert_eq!(decoded, crc_val, "ASCII Encode/Decode roundtrip failed for {:#06x}", crc_val);
        }
    }

    #[test]
    fn test_binary_crc_encoding_decoding_roundtrip_extra() {
         let test_cases = [0x0000, 0xFFFF, 0x1234, 0xABCD]; // Non-spec examples
        for crc_val in test_cases {
            let encoded = encode_crc_binary(crc_val);
            let decoded = decode_crc_binary(&encoded);
            assert_eq!(decoded, crc_val, "Binary Encode/Decode roundtrip failed for {:#06x}", crc_val);
        }
    }

    #[test]
    fn test_verify_ascii_crc_invalid_cases() {
        // Wrong CRC characters
        let result1 = verify_response_crc_ascii::<MockIoError>(b"0+3.14OqX"); // Correct is OqZ
        assert!(matches!(result1, Err(Sdi12Error::CrcMismatch { .. })));

        // Corrupted data, correct CRC characters
        let result2 = verify_response_crc_ascii::<MockIoError>(b"0+3.15OqZ"); // Changed 4 to 5
        assert!(matches!(result2, Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer too short for CRC
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b"0+"), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b"Oq"), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b""), Err(Sdi12Error::InvalidFormat)));
    }

     #[test]
    fn test_verify_binary_crc_invalid_cases() {
        // Correct data, wrong CRC bytes
        let data = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00];
        let mut packet_bad_crc = data.to_vec();
        packet_bad_crc.extend_from_slice(&[0xC3, 0xAC]); // Original CRC was C2 AC
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&packet_bad_crc), Err(Sdi12Error::CrcMismatch { .. })));

        // Corrupted data, original CRC bytes
        let data_bad = &[0x31, 0x04, 0x00, 0x03, 0xFE, 0xFF, 0x01, 0x00];
        let mut packet_bad_data = data_bad.to_vec();
        let correct_crc = calculate_crc16(data); // CRC for original data
        packet_bad_data.extend_from_slice(&encode_crc_binary(correct_crc));
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&packet_bad_data), Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer has data but only 1 byte for CRC
        let packet_short_crc = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00, 0xC2];
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(packet_short_crc), Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer genuinely too short
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&[0x31]), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(b""), Err(Sdi12Error::InvalidFormat)));
    }

    // Panic tests for decode functions remain useful
    #[test]
    #[should_panic]
    fn test_decode_ascii_panic_short() { decode_crc_ascii(b"Oq"); }
    #[test]
    #[should_panic]
    fn test_decode_ascii_panic_long() { decode_crc_ascii(b"OqZZ"); }
    #[test]
    #[should_panic]
    fn test_decode_binary_panic_short() { decode_crc_binary(&[0xC2]); }
    #[test]
    #[should_panic]
    fn test_decode_binary_panic_long() { decode_crc_binary(&[0xC2, 0xAC, 0x00]); }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/error.rs
=======================
// src/common/error.rs

#[cfg(feature = "alloc")]
use alloc::string::String;

// No more cfg_attr needed here, thiserror is always available
#[derive(Debug, PartialEq, Eq, thiserror::Error)]
pub enum Sdi12Error<E = ()>
where
    E: core::fmt::Debug, // Still need Debug for the generic Io error
{
    /// Underlying I/O error from the HAL implementation.
    #[error("I/O error: {0:?}")] // Format string requires Debug on E
    Io(E),

    /// Operation timed out.
    #[error("Operation timed out")]
    Timeout,

    /// Invalid character received where it's not allowed (e.g., non-printable ASCII).
    #[error("Invalid character received: {0:#04x}")]
    InvalidCharacter(u8),

    /// Provided address character is not a valid SDI-12 address.
    #[error("Invalid SDI-12 address character: '{0}'")]
    InvalidAddress(char),

    /// Received response format is invalid or unexpected.
    #[error("Invalid response format")]
    InvalidFormat,

    /// Buffer provided was too small.
    #[error("Buffer overflow: needed {needed}, got {got}")]
    BufferOverflow { needed: usize, got: usize },

    /// UART framing error detected by HAL.
    #[error("UART framing error")]
    Framing,

    /// UART parity error detected by HAL.
    #[error("UART parity error")]
    Parity,

    /// Received CRC does not match calculated CRC.
    #[error("CRC mismatch: expected {expected:#06x}, calculated {calculated:#06x}")]
    CrcMismatch { expected: u16, calculated: u16 },

    /// Got a validly formatted response, but not the one expected in the current state.
    #[error("Unexpected response received")]
    UnexpectedResponse, // Consider adding details later

    /// Bus contention detected (multiple devices responding simultaneously).
    #[error("Bus contention detected")]
    BusContention,

    /// An error specific to the sensor's implementation/handler.
    /// Only available when the "alloc" feature is enabled.
    #[cfg(feature = "alloc")]
    #[error("Sensor specific error: {0}")] // String implements Display
    SensorSpecific(String),

    // Add other variants as needed...
}

// No manual Display impl needed - thiserror handles it.
// No manual std::error::Error impl needed - thiserror handles it when its 'std' feature is enabled.

// Allow mapping from underlying HAL error if From is implemented
impl<E: core::fmt::Debug> From<E> for Sdi12Error<E> {
    fn from(e: E) -> Self {
        Sdi12Error::Io(e)
    }
}

// Note: For the Io(E) variant's #[error("...")] message to work correctly even
// in no_std, the underlying error type `E` must implement `core::fmt::Debug`.
// If the `std` feature is enabled, `E` would ideally also implement `std::error::Error`
// for better error chaining via `thiserror`, but `Debug` is the minimum requirement
// for the format string used here.

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/frame.rs
=======================
// src/common/frame.rs

/// Represents the serial frame formats used in SDI-12.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum FrameFormat {
    /// Standard SDI-12 format: 1200 baud, 7 data bits, Even parity, 1 stop bit.
    Sdi12_7e1,
    /// Format for High-Volume Binary data: 1200 baud, 8 data bits, No parity, 1 stop bit.
    Binary8N1,
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/hal_traits.rs
=======================
// src/common/hal_traits.rs

use super::frame::FrameFormat;
use core::fmt::Debug;

// We need these traits potentially for the NativeSdi12Uart bounds
#[cfg(feature = "impl-native")]
use embedded_hal; // Use version 1.0
#[cfg(all(feature = "async", feature = "impl-native"))]
use embedded_hal_async; // Use version 1.0

/// Abstraction for timer/delay operations required by SDI-12.
///
/// Note: This could potentially be replaced by directly requiring
/// `embedded_hal::delay::DelayNs` if embedded-hal v1 is mandated.
pub trait Sdi12Timer {
    /// Delay for at least the specified number of microseconds.
    fn delay_us(&mut self, us: u32);

    /// Delay for at least the specified number of milliseconds.
    fn delay_ms(&mut self, ms: u32);
}

/// Abstraction for synchronous (non-blocking) SDI-12 serial communication.
pub trait Sdi12Serial {
    /// Associated error type for communication errors.
    /// Must implement Debug for error reporting.
    type Error: Debug;

    /// Attempts to read a single byte from the serial interface.
    ///
    /// Returns `Ok(byte)` if a byte was read, or `Err(nb::Error::WouldBlock)`
    /// if no byte is available yet. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn read_byte(&mut self) -> nb::Result<u8, Self::Error>;

    /// Attempts to write a single byte to the serial interface.
    ///
    /// Returns `Ok(())` if the byte was accepted for transmission, or `Err(nb::Error::WouldBlock)`
    /// if the write buffer is full. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn write_byte(&mut self, byte: u8) -> nb::Result<(), Self::Error>;

    /// Attempts to flush the transmit buffer, ensuring all written bytes have been sent.
    ///
    /// Returns `Ok(())` if the flush completed, or `Err(nb::Error::WouldBlock)` if
    /// transmission is still in progress. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn flush(&mut self) -> nb::Result<(), Self::Error>;

    /// Sends the SDI-12 break condition (>= 12ms of spacing).
    ///
    /// Implementations must ensure the line is held low for the required duration.
    /// This might block or return `WouldBlock` depending on the implementation strategy.
    fn send_break(&mut self) -> nb::Result<(), Self::Error>;

    /// Changes the serial configuration (e.g., between 7E1 and 8N1).
    ///
    /// This operation might be blocking or complex, hence `Result` instead of `nb::Result`.
    /// Errors could occur if the hardware doesn't support the format or reconfiguration fails.
    fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

/// Abstraction for asynchronous SDI-12 serial communication (requires 'async' feature).
#[cfg(feature = "async")]
pub trait Sdi12SerialAsync {
    /// Associated error type for communication errors.
    /// Must implement Debug for error reporting.
    type Error: Debug;

    /// Asynchronously reads a single byte from the serial interface.
    async fn read_byte(&mut self) -> Result<u8, Self::Error>;

    /// Asynchronously writes a single byte to the serial interface.
    async fn write_byte(&mut self, byte: u8) -> Result<(), Self::Error>;

    /// Asynchronously flushes the transmit buffer.
    async fn flush(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously sends the SDI-12 break condition.
    async fn send_break(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously changes the serial configuration.
    async fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}


/// Bundles standard embedded-hal serial traits with native SDI-12 specific operations.
///
/// Implement this trait for a HAL's UART peripheral if it provides native support
/// for sending break signals and changing configuration efficiently. Then, use the
/// `NativeAdapter` to make it compatible with `sdi12-rs`.
///
/// Requires `embedded-hal` v1.0 traits and is enabled by the `impl-native` feature.
#[cfg(feature = "impl-native")]
pub trait NativeSdi12Uart:
    embedded_hal::serial::ErrorType // Use fully qualified path
    // Specify Error association for dependent traits using qualified syntax
    + embedded_hal::serial::Read<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    + embedded_hal::serial::Write<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    + embedded_hal::serial::Flush<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    // Add Debug bound on the associated Error type for our own trait requirements
    + where <Self as embedded_hal::serial::ErrorType>::Error: Debug
{
    // Note: The associated Error type comes from embedded_hal::serial::ErrorType

    /// Sends the SDI-12 break condition using native hardware capabilities.
    fn native_send_break(&mut self) -> Result<(), Self::Error>;

    /// Changes the serial configuration using native hardware capabilities.
    fn native_set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

/// Async version of `NativeSdi12Uart`.
/// Requires `embedded-hal-async` traits and is enabled by the `async` and `impl-native` features.
#[cfg(all(feature = "async", feature = "impl-native"))]
pub trait NativeSdi12UartAsync:
    embedded_hal_async::serial::ErrorType // Use fully qualified path
    // Specify Error association for dependent traits using qualified syntax
    + embedded_hal_async::serial::Read<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    + embedded_hal_async::serial::Write<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    + embedded_hal_async::serial::Flush<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    // Add Debug bound on the associated Error type for our own trait requirements
    + where <Self as embedded_hal_async::serial::ErrorType>::Error: Debug
{
    // Note: The associated Error type comes from embedded_hal_async::serial::ErrorType

    /// Asynchronously sends the SDI-12 break condition using native hardware capabilities.
    async fn native_send_break(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously changes the serial configuration using native hardware capabilities.
    async fn native_set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/mod.rs
=======================
// src/common/mod.rs

// --- Declare all public modules within common ---
pub mod address;
pub mod command;
pub mod crc;
pub mod error;
pub mod frame;
pub mod hal_traits;
pub mod response; // Points to the single file
pub mod timing;
pub mod types;

// --- Re-export key types/traits/functions for easier access ---

// From address.rs
pub use address::Sdi12Addr;

// From command.rs
pub use command::{
    Command, CommandIndexError, CommandFormatError, // Added FormatError
    MeasurementIndex, ContinuousIndex, DataIndex, IdentifyParameterIndex,
    IdentifyMeasurementCommand, IdentifyMeasurementParameterCommand,
};

// From crc.rs
pub use crc::{
    calculate_crc16, encode_crc_ascii, decode_crc_ascii, verify_response_crc_ascii,
    encode_crc_binary, decode_crc_binary, verify_packet_crc_binary,
};

// From error.rs
pub use error::Sdi12Error;

// From frame.rs
pub use frame::FrameFormat;

// From hal_traits.rs
pub use hal_traits::{Sdi12Serial, Sdi12Timer}; // Core sync traits

// From response.rs (Simplified re-exports)
pub use response::{
    ResponseParseError, // The error enum for frame/crc/address issues
    MeasurementTiming,  // The struct for specifically parsed timing responses
    PayloadSlice,       // The wrapper for returned raw payloads
};

// From timing.rs (constants)

// From types.rs
pub use types::{BinaryDataType, Sdi12ParsingError, Sdi12Value};


// --- Feature-gated re-exports ---

// Async traits (from hal_traits.rs)
#[cfg(feature = "async")]
pub use hal_traits::Sdi12SerialAsync;

// Native HAL integration traits (from hal_traits.rs)
#[cfg(feature = "impl-native")]
pub use hal_traits::NativeSdi12Uart;
#[cfg(all(feature = "async", feature = "impl-native"))]
pub use hal_traits::NativeSdi12UartAsync;

// Note: No alloc-dependent response types re-exported from common::response
// Types like IdentificationInfo, DataInfo etc. are now internal details
// potentially used by optional parsing helpers.

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/response.rs
=======================
// src/common/response.rs

use crate::common::address::Sdi12Addr;
use crate::common::types::Sdi12ParsingError; // Keep for error composition
use core::fmt;

/// Error type specific to parsing the framing/address/CRC of an SDI-12 response.
/// Does not cover errors from parsing the actual payload content (data values, ID fields etc.).
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ResponseParseError {
    /// Input buffer was empty.
    EmptyInput,
    /// Input buffer doesn't end with <CR><LF> (for ASCII responses).
    MissingCrLf,
    /// Response string is too short for basic structure (e.g., address or CRC).
    TooShort,
    /// Invalid or unexpected address character at the start (e.g., '?').
    InvalidAddressChar,
    /// CRC validation failed.
    CrcMismatch,
    /// Binary packet size/structure inconsistent (if library handles binary framing).
    InconsistentBinaryPacketSize,
    /// Feature needed for a specific check/parse is not enabled.
    FeatureNotEnabled,
    /// Generic framing or structural format error.
    InvalidFormat,
    // NOTE: Errors like ValueError, NumericError, InvalidIdentificationLength etc.
    // are removed as they relate to parsing the *payload*, which is now the user's responsibility
    // or handled by optional helpers. ResponseParseError focuses on the layer the library handles.
}

impl fmt::Display for ResponseParseError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         // Simple display for now
         write!(f, "{:?}", self)
     }
}

// If std feature is enabled, implement the Error trait
#[cfg(feature = "std")]
impl std::error::Error for ResponseParseError {}


/// Timing and count information returned directly by Measurement/Concurrent/Identify commands.
/// (Example: `aTTTN<CR><LF>`)
/// This is one structure the library *might* still parse directly, as it's not payload data.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct MeasurementTiming {
    /// The address of the responding sensor.
    pub address: Sdi12Addr,
    /// Time estimate in seconds until data is ready (ttt). 0-999.
    pub time_seconds: u16,
    /// Number of measurement values that will be returned (n, nn, or nnn). 0-999.
    pub values_count: u16,
}


// --- Placeholder for the Payload Slice Wrapper ---
// This struct would be returned by recorder methods after validating
// address, CRC, CRLF and stripping them.

/// Represents the validated payload of an SDI-12 response, borrowed from a read buffer.
/// Excludes the leading address, trailing CRC (if any), and trailing <CR><LF>.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct PayloadSlice<'a>(pub &'a [u8]);

impl<'a> PayloadSlice<'a> {
    /// Returns the payload as a byte slice.
    pub fn as_bytes(&self) -> &'a [u8] {
        self.0
    }

    /// Attempts to interpret the payload as a UTF-8 string slice.
    pub fn as_str(&self) -> Result<&'a str, core::str::Utf8Error> {
        core::str::from_utf8(self.0)
    }

    // Optional: Add helper methods here later under features?
    // #[cfg(feature = "alloc")]
    // pub fn parse_data_values(&self) -> Result<Vec<Sdi12Value>, ResponseParseError> { ... }
}

impl<'a> AsRef<[u8]> for PayloadSlice<'a> {
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

// No parsing functions like parse_response defined here anymore.
// That logic moves into internal recorder helpers or optional user-facing helpers.

// --- Tests ---
#[cfg(test)]
mod tests {
    use super::*;

     fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    #[test]
    fn test_measurement_timing_struct() {
        let mt = MeasurementTiming {
            address: addr('1'),
            time_seconds: 15,
            values_count: 4,
        };
        assert_eq!(mt.time_seconds, 15);
    }

     #[test]
    fn test_payload_slice_wrapper() {
        let data: &[u8] = b"+1.23-45";
        let payload = PayloadSlice(data);
        assert_eq!(payload.as_bytes(), b"+1.23-45");
        assert_eq!(payload.as_ref(), b"+1.23-45");
        assert_eq!(payload.as_str().unwrap(), "+1.23-45");

        let non_utf8: &[u8] = &[0x80, 0x81]; // Invalid UTF-8
        let payload_bad = PayloadSlice(non_utf8);
        assert!(payload_bad.as_str().is_err());
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/timing.rs
=======================
// src/common/timing.rs

use core::time::Duration;

// Note: Tolerances are generally +/- 0.40 ms according to the spec (Sec 7.0),
// except for inter-character time. We define the nominal values here.
// Implementations using these should factor in tolerances where appropriate,
// especially when checking received timings.

// === Break Timing (Sec 7.0, 7.1) ===

/// Minimum duration for a valid break signal (recorder must send >= 12 ms).
pub const BREAK_DURATION_MIN: Duration = Duration::from_millis(12);
/// Sensor must recognize a break if spacing > 12 ms.
pub const BREAK_RECOGNITION_MAX: Duration = Duration::from_millis(12);
/// Sensor will *not* recognize a break if spacing < 6.5 ms.
pub const BREAK_IGNORE_MAX: Duration = Duration::from_micros(6500);
/// Marking time required after a break before sensor looks for an address.
pub const POST_BREAK_MARKING_MIN: Duration = Duration::from_micros(8330);

// === Command/Response Timing (Sec 7.0) ===

/// Maximum time from end of command stop bit for recorder to release line.
pub const RECORDER_RELEASE_TIME_MAX: Duration = Duration::from_micros(7_900); // 7.5ms + 0.4ms tol
/// Nominal marking time sent by sensor before starting response.
pub const SENSOR_PRE_RESPONSE_MARKING: Duration = Duration::from_micros(8330);
/// Maximum time from end of command stop bit to start bit of first response byte.
pub const RESPONSE_START_TIME_MAX: Duration = Duration::from_micros(15_400); // 15ms + 0.4ms tol
/// Maximum time from end of response stop bit for sensor to release line.
pub const SENSOR_RELEASE_TIME_MAX: Duration = Duration::from_micros(7_900); // 7.5ms + 0.4ms tol
/// Maximum marking time allowed between characters in a command or response.
pub const INTER_CHARACTER_MARKING_MAX: Duration = Duration::from_micros(1660);


// === Sensor Wake/Sleep Timing (Sec 7.0) ===

/// Maximum time for sensor to wake up after detecting a break and be ready for command start bit.
pub const SENSOR_WAKEUP_TIME_MAX: Duration = Duration::from_millis(100);
/// Marking time after which sensor returns to low-power standby (if not actively processing/responding).
pub const SENSOR_SLEEP_MARKING_TIME: Duration = Duration::from_millis(100);
/// Time threshold after which a break *must* precede the next command if line was marking.
/// (Spec says > 87 ms in Sec 7.1 implies break needed, aligned with retry logic in Sec 7.2).
pub const PRE_COMMAND_BREAK_MARKING_THRESHOLD: Duration = Duration::from_millis(87);

// === Retry Timing (Sec 7.2) ===

/// Minimum wait time after a command before recorder issues a retry (if no response).
pub const RETRY_WAIT_MIN: Duration = Duration::from_micros(16670); // 16.67 ms
/// Maximum wait time after a command before recorder issues a retry without a preceding break.
/// (This period also covers the RETRY_WAIT_MIN).
pub const RETRY_WAIT_MAX_NO_BREAK: Duration = Duration::from_millis(87);
/// Minimum delay after the *end of the break* before issuing at least one retry,
/// to ensure sensor has had SENSOR_WAKEUP_TIME_MAX to wake up.
pub const RETRY_POST_BREAK_DELAY_MIN: Duration = SENSOR_WAKEUP_TIME_MAX;

// === Other ===

/// Time between lines for multi-line text responses (Sec 4.4.13.1). Max 150ms.
pub const MULTILINE_INTER_LINE_DELAY_MAX: Duration = Duration::from_millis(150);

// === Byte Timing at 1200 Baud (7E1) ===
// 1 start bit + 7 data bits + 1 parity bit + 1 stop bit = 10 bits per byte
// Time per bit = 1 / 1200 seconds = 0.8333... ms
// Time per byte = 10 * (1 / 1200) seconds = 10 / 1200 s = 1 / 120 s = 8.333... ms

/// Nominal duration of a single bit at 1200 baud.
pub const BIT_DURATION: Duration = Duration::from_nanos(833_333); // Approx 0.833 ms
/// Nominal duration of a single byte (10 bits total) at 1200 baud (7E1 format).
pub const BYTE_DURATION: Duration = Duration::from_micros(8333); // Approx 8.33 ms

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/types.rs
=======================
// src/common/types.rs

use core::fmt;
use core::str::FromStr; // For parsing strings to numbers

// --- SDI-12 Standard Data Value (`<values>`) ---

/// Represents a single data value as returned in the `<values>` part of D or R commands.
/// Format: `p[d.d]` where p is '+' or '-', d are digits, '.' is optional. Max 7 digits. Max 9 chars total.
///
/// We store it internally potentially as a scaled integer or a float, depending on needs.
/// Using f32 might be simplest for representation, but parsing needs care.
/// Alternatively, parse into integer + scale factor. Let's try f32 for now.
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]
pub struct Sdi12Value(f32); // Store as f32 for simplicity

impl Sdi12Value {
    /// Creates a new Sdi12Value.
    pub fn new(value: f32) -> Self {
        // TODO: Potentially add checks/clamping based on SDI-12 format limits?
        // The format itself limits precision/range implicitly.
        Self(value)
    }

    /// Returns the value as f32.
    pub fn as_f32(&self) -> f32 {
        self.0
    }

    /// Parses a single value string (like "+1.23", "-10", "+1234567") into an Sdi12Value.
    /// Does not handle multiple values in one string.
    pub fn parse_single(s: &str) -> Result<Self, Sdi12ParsingError> {
        // Validate basic structure and length (max 9 chars: sign + 7 digits + opt decimal)
        if s.is_empty() || s.len() > 9 {
            return Err(Sdi12ParsingError::InvalidFormat);
        }
        let mut chars = s.chars();
        let sign_char = chars.next().ok_or(Sdi12ParsingError::InvalidFormat)?;
        let sign = match sign_char {
            '+' => 1.0,
            '-' => -1.0,
            _ => return Err(Sdi12ParsingError::InvalidSign),
        };

        let rest = chars.as_str();
        // Validate remaining chars are digits or a single '.'
        let mut decimal_found = false;
        let mut digit_count = 0;
        for c in rest.chars() {
            match c {
                '0'..='9' => digit_count += 1,
                '.' => {
                    if decimal_found { return Err(Sdi12ParsingError::MultipleDecimals); }
                    decimal_found = true;
                }
                _ => return Err(Sdi12ParsingError::InvalidCharacter),
            }
        }
        if digit_count == 0 || digit_count > 7 {
            return Err(Sdi12ParsingError::InvalidDigitCount);
        }

        // Attempt to parse the numeric part (without sign)
        let num_part = f32::from_str(rest).map_err(|_| Sdi12ParsingError::ParseFloatError)?;

        Ok(Self(sign * num_part))
    }

    // TODO: Implement formatting logic later if needed (e.g., for sensor implementation)
    // pub fn format(&self, buffer: &mut [u8]) -> Result<usize, Sdi12FormattingError> { ... }
}

/// Error during parsing of SDI-12 <values>.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Sdi12ParsingError {
    InvalidFormat,
    InvalidSign,
    MultipleDecimals,
    InvalidCharacter,
    InvalidDigitCount,
    ParseFloatError, // Error converting string part to float
}

impl fmt::Display for Sdi12ParsingError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use Sdi12ParsingError::*;
        match self {
            InvalidFormat => write!(f, "Invalid SDI-12 value format"),
            InvalidSign => write!(f, "Invalid or missing sign character"),
            MultipleDecimals => write!(f, "Multiple decimal points found"),
            InvalidCharacter => write!(f, "Invalid character in numeric part"),
            InvalidDigitCount => write!(f, "Invalid number of digits (must be 1-7)"),
            ParseFloatError => write!(f, "Failed to parse numeric part as float"),
        }
    }
}


// --- High Volume Binary Data Types (Sec 5.2.1, Table 16) ---

/// Data types used in High-Volume Binary command responses.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[repr(u8)]
pub enum BinaryDataType {
    InvalidRequest = 0, // Indicates an invalid DBn request index
    SignedI8 = 1,
    UnsignedU8 = 2,
    SignedI16 = 3,
    UnsignedU16 = 4,
    SignedI32 = 5,
    UnsignedU32 = 6,
    SignedI64 = 7,
    UnsignedU64 = 8,
    Float32 = 9, // IEEE 754 Single Precision
    Float64 = 10, // IEEE 754 Double Precision
}

impl BinaryDataType {
    /// Tries to convert a u8 into a BinaryDataType.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BinaryDataType::InvalidRequest),
            1 => Some(BinaryDataType::SignedI8),
            2 => Some(BinaryDataType::UnsignedU8),
            3 => Some(BinaryDataType::SignedI16),
            4 => Some(BinaryDataType::UnsignedU16),
            5 => Some(BinaryDataType::SignedI32),
            6 => Some(BinaryDataType::UnsignedU32),
            7 => Some(BinaryDataType::SignedI64),
            8 => Some(BinaryDataType::UnsignedU64),
            9 => Some(BinaryDataType::Float32),
            10 => Some(BinaryDataType::Float64),
            _ => None,
        }
    }

    /// Returns the size in bytes of a single value of this data type.
    /// Returns 0 for InvalidRequest.
    pub fn size_in_bytes(&self) -> usize {
        match self {
            BinaryDataType::InvalidRequest => 0,
            BinaryDataType::SignedI8 => 1,
            BinaryDataType::UnsignedU8 => 1,
            BinaryDataType::SignedI16 => 2,
            BinaryDataType::UnsignedU16 => 2,
            BinaryDataType::SignedI32 => 4,
            BinaryDataType::UnsignedU32 => 4,
            BinaryDataType::SignedI64 => 8,
            BinaryDataType::UnsignedU64 => 8,
            BinaryDataType::Float32 => 4,
            BinaryDataType::Float64 => 8,
        }
    }
}


// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sdi12value_parsing_valid() {
        assert_eq!(Sdi12Value::parse_single("+1.23").unwrap(), Sdi12Value(1.23));
        assert_eq!(Sdi12Value::parse_single("-0.456").unwrap(), Sdi12Value(-0.456));
        assert_eq!(Sdi12Value::parse_single("+100").unwrap(), Sdi12Value(100.0));
        assert_eq!(Sdi12Value::parse_single("-5").unwrap(), Sdi12Value(-5.0));
        assert_eq!(Sdi12Value::parse_single("+1234567").unwrap(), Sdi12Value(1234567.0));
        assert_eq!(Sdi12Value::parse_single("-9999999").unwrap(), Sdi12Value(-9999999.0));
        assert_eq!(Sdi12Value::parse_single("+.1").unwrap(), Sdi12Value(0.1));
        assert_eq!(Sdi12Value::parse_single("-0.").unwrap(), Sdi12Value(-0.0)); // Note: -0.0 comparison
        assert_eq!(Sdi12Value::parse_single("+0").unwrap(), Sdi12Value(0.0));
    }

    #[test]
    fn test_sdi12value_parsing_invalid() {
        assert_eq!(Sdi12Value::parse_single(""), Err(Sdi12ParsingError::InvalidFormat));
        assert_eq!(Sdi12Value::parse_single("+"), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("-"), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("1.23"), Err(Sdi12ParsingError::InvalidSign));
        assert_eq!(Sdi12Value::parse_single(" +1.23"), Err(Sdi12ParsingError::InvalidSign));
        assert_eq!(Sdi12Value::parse_single("+1.2.3"), Err(Sdi12ParsingError::MultipleDecimals));
        assert_eq!(Sdi12Value::parse_single("+1a2"), Err(Sdi12ParsingError::InvalidCharacter));
        assert_eq!(Sdi12Value::parse_single("+."), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("+12345678"), Err(Sdi12ParsingError::InvalidDigitCount)); // 8 digits, len 9 -> OK length, bad digit count

        // Input "+123.45678" (Length 10) - Should fail length check first.
        assert_eq!(
            Sdi12Value::parse_single("+123.45678"), // This was line 186
            Err(Sdi12ParsingError::InvalidFormat) // CORRECTED: Expect InvalidFormat due to length > 9
        );

        // Input "+1234567." (Length 9) - Should parse OK if trailing '.' is allowed
        assert!(Sdi12Value::parse_single("+1234567.").is_ok());

        // Input "+1234567.0" (Length 10) - Should fail length check first.
        assert_eq!(
            Sdi12Value::parse_single("+1234567.0"),
            Err(Sdi12ParsingError::InvalidFormat) // Expect InvalidFormat due to length > 9
        );
        // Input "+12345.678" (Length 10) - This also fails length check first.
         assert_eq!(
            Sdi12Value::parse_single("+12345.678"), // This was previously expecting InvalidDigitCount incorrectly
            Err(Sdi12ParsingError::InvalidFormat) // CORRECTED: Expect InvalidFormat due to length > 9
        );
        assert_eq!(Sdi12Value::parse_single("+123456789"), Err(Sdi12ParsingError::InvalidFormat)); // Too long (len 10)
    }

    #[test]
    fn test_binary_data_type_from_u8() {
        assert_eq!(BinaryDataType::from_u8(0), Some(BinaryDataType::InvalidRequest));
        assert_eq!(BinaryDataType::from_u8(1), Some(BinaryDataType::SignedI8));
        assert_eq!(BinaryDataType::from_u8(2), Some(BinaryDataType::UnsignedU8));
        assert_eq!(BinaryDataType::from_u8(3), Some(BinaryDataType::SignedI16));
        assert_eq!(BinaryDataType::from_u8(4), Some(BinaryDataType::UnsignedU16));
        assert_eq!(BinaryDataType::from_u8(5), Some(BinaryDataType::SignedI32));
        assert_eq!(BinaryDataType::from_u8(6), Some(BinaryDataType::UnsignedU32));
        assert_eq!(BinaryDataType::from_u8(7), Some(BinaryDataType::SignedI64));
        assert_eq!(BinaryDataType::from_u8(8), Some(BinaryDataType::UnsignedU64));
        assert_eq!(BinaryDataType::from_u8(9), Some(BinaryDataType::Float32));
        assert_eq!(BinaryDataType::from_u8(10), Some(BinaryDataType::Float64));
        assert_eq!(BinaryDataType::from_u8(11), None);
        assert_eq!(BinaryDataType::from_u8(255), None);
    }

     #[test]
    fn test_binary_data_type_size() {
        assert_eq!(BinaryDataType::InvalidRequest.size_in_bytes(), 0);
        assert_eq!(BinaryDataType::SignedI8.size_in_bytes(), 1);
        assert_eq!(BinaryDataType::UnsignedU8.size_in_bytes(), 1);
        assert_eq!(BinaryDataType::SignedI16.size_in_bytes(), 2);
        assert_eq!(BinaryDataType::UnsignedU16.size_in_bytes(), 2);
        assert_eq!(BinaryDataType::SignedI32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::UnsignedU32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::SignedI64.size_in_bytes(), 8);
        assert_eq!(BinaryDataType::UnsignedU64.size_in_bytes(), 8);
        assert_eq!(BinaryDataType::Float32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::Float64.size_in_bytes(), 8);
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/lib.rs
=======================
// src/lib.rs

#![no_std] // Specify no_std at the crate root

#[cfg(feature = "alloc")]
extern crate alloc;

pub mod common;
pub mod recorder;
pub mod sensor;

// Re-export key types for convenience
pub use common::Sdi12Addr;
pub use common::Sdi12Error;

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/recorder/mod.rs
=======================
// src/recorder/mod.rs

use crate::common::{
    address::Sdi12Addr,
    command::Command,
    error::Sdi12Error,
    hal_traits::{Sdi12Serial, Sdi12Timer},
    response::{PayloadSlice, ResponseParseError}, // Keep ResponseParseError
    timing, // Need timing constants
    FrameFormat, // Need frame format enum
};
use core::fmt::Debug; // Needed for IF::Error bound
use core::time::Duration; // May be needed for timeouts later

// Use nb::Result for non-blocking operations from Sdi12Serial
use nb::Result as NbResult;


/// Represents an SDI-12 Recorder (Datalogger) instance for SYNCHRONOUS operations.
///
/// This struct owns the SDI-12 interface (serial and timer abstraction)
/// and provides methods to interact with sensors on the bus using a blocking approach.
#[derive(Debug)]
pub struct SyncRecorder<IF> {
    interface: IF,
    // TODO: Add internal state if needed (e.g., last communication time, requires_break flag)
}

// --- Constructor ---

impl<IF> SyncRecorder<IF>
where
    // The interface needs to provide both Serial and Timer capabilities
    IF: Sdi12Serial + Sdi12Timer,
    // Require Debug on the serial error for mapping in execute_blocking_io
    IF::Error: Debug,
{
    /// Creates a new SyncRecorder instance using the provided SDI-12 interface.
    ///
    /// The interface must implement both `Sdi12Serial` for communication
    /// and `Sdi12Timer` for handling delays and timeouts. Adapter structs
    /// provided by `sdi12-rs` (like `NativeAdapter`, `GenericHalAdapter`)
    /// typically implement both.
    ///
    /// # Arguments
    ///
    /// * `interface`: An object implementing `Sdi12Serial` and `Sdi12Timer`.
    pub fn new(interface: IF) -> Self {
        SyncRecorder {
            interface,
            // TODO: Initialize internal state
        }
    }

    // --- Public Blocking Methods ---

    /// Sends the Acknowledge Active command (`a!`) and waits for a valid acknowledgement.
    ///
    /// Returns `Ok(())` if the sensor acknowledges correctly (empty payload received).
    /// Returns `Err(Sdi12Error::...)` on timeout, CRC error (if applicable later),
    /// incorrect response payload, or communication errors.
    pub fn acknowledge(&mut self, address: Sdi12Addr) -> Result<(), Sdi12Error<IF::Error>> {
        let cmd = Command::AcknowledgeActive { address };
        // TODO: Determine appropriate buffer size or pass slice from caller
        let mut read_buffer = [0u8; 8]; // Small buffer for simple ack/error
        let payload = self.execute_transaction(&cmd, &mut read_buffer)?;

        // For acknowledge, the payload should be empty after stripping address/CRC/CRLF
        if payload.as_bytes().is_empty() {
            Ok(())
        } else {
            // Received unexpected data after address
            Err(Sdi12Error::InvalidFormat) // Or maybe UnexpectedResponse?
        }
    }

    // --- Core Transaction Logic (Private Helper) ---

    /// Executes a full command-response transaction with retries.
    /// Handles break signal (if needed), command formatting/sending, response reading/validation.
    fn execute_transaction<'buf>(
        &mut self,
        command: &Command,
        read_buffer: &'buf mut [u8] // Buffer provided by caller
    ) -> Result<PayloadSlice<'buf>, Sdi12Error<IF::Error>>
    {
        // TODO: Implement full sequence:
        // 1. Check timing state - Do we need a break? Call check_and_send_break()
        // 2. Format command into a temporary buffer (needs allocation or stack buffer)
        //    let command_bytes = format_command(command)?; // Need this helper
        // 3. Retry loop (e.g., up to 3 times per spec)
        //    a. send_command_bytes(&command_bytes)?
        //    b. read_response_line(read_buffer)?
        //    c. process_response_payload(line)? -> Returns PayloadSlice on success
        //    d. If successful, break loop and return PayloadSlice
        //    e. If timeout/error, handle retry wait logic (Sec 7.2) - might need break on some retries.
        // 4. If retries exhausted, return last error (e.g., Timeout)
        // 5. Update timing state after successful communication

        // Placeholder implementation
        let _ = command;
        let _ = read_buffer;
        Err(Sdi12Error::Timeout)
    }


    // --- Low-Level I/O Helpers (Private) ---

    // TODO: Implement check_and_send_break (needs timing state)
    // fn check_and_send_break(&mut self) -> Result<(), Sdi12Error<IF::Error>> { ... }

    // TODO: Implement send_command_bytes (needs formatting helper)
    // fn send_command_bytes(&mut self, cmd_bytes_with_term: &[u8]) -> Result<(), Sdi12Error<IF::Error>> { ... }

    // TODO: Implement read_response_line (needs timeout logic)
    // fn read_response_line<'buf>(&mut self, buffer: &'buf mut [u8]) -> Result<&'buf [u8], Sdi12Error<IF::Error>> { ... }

    // TODO: Implement process_response_payload (needs CRC check, address check)
    // fn process_response_payload<'buf>(&mut self, response_line: &'buf [u8]) -> Result<PayloadSlice<'buf>, Sdi12Error<IF::Error>> { ... }

    /// Executes a non-blocking I/O operation (`f`) repeatedly until it
    /// stops returning `WouldBlock`, returning the final result.
    /// Effectively a blocking wrapper around an nb::Result returning function.
    /// NOTE: Current implementation lacks timeout!
    fn execute_blocking_io<F, T>(&mut self, mut f: F) -> Result<T, Sdi12Error<IF::Error>>
    where
        F: FnMut(&mut IF) -> NbResult<T, IF::Error>,
    {
        loop {
            match f(&mut self.interface) {
                Ok(result) => return Ok(result),
                Err(nb::Error::WouldBlock) => {
                    // WARNING: Lacks timeout logic!
                    // In a real scenario, check elapsed time against a deadline here.
                    // If deadline exceeded, return Err(Sdi12Error::Timeout).
                    // A simple busy loop or short delay might be used temporarily,
                    // but isn't ideal for responsiveness or power consumption.
                    // self.interface.delay_us(100); // Example short delay - use with caution!
                    continue; // Retry the operation
                }
                Err(nb::Error::Other(e)) => return Err(Sdi12Error::Io(e)), // Map HAL error
            }
        }
        // Note: Could use nb::block! macro if IF::Error implements Copy.
        // nb::block!(f(&mut self.interface)).map_err(Sdi12Error::Io)
    }

} // end impl SyncRecorder


// --- Async Recorder Definition (Placeholder) ---
#[cfg(feature = "async")]
pub struct AsyncRecorder<IF> {
    interface: IF,
    // ... state ...
}

#[cfg(feature = "async")]
impl<IF> AsyncRecorder<IF>
where
    IF: crate::common::hal_traits::Sdi12SerialAsync + Sdi12Timer, // Assume timer can be sync or need async version
    IF::Error: Debug,
{
     pub fn new(interface: IF) -> Self {
         // ... constructor ...
         unimplemented!()
     }

     pub async fn acknowledge(&mut self, _address: Sdi12Addr) -> Result<(), Sdi12Error<IF::Error>> {
         // ... async implementation using .await ...
         unimplemented!()
     }

     // ... other async methods and helpers ...
}


// --- Tests ---
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::{
        address::Sdi12Addr,
        hal_traits::{Sdi12Serial, Sdi12Timer},
        FrameFormat, Sdi12Error, Command, // Added Command for acknowledge test
    };
    use nb;

    // --- Mock Interface ---
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct MockCommError;

    struct MockInterface {
        break_sent: bool,
        config: FrameFormat,
        // Add fields to control mock behavior for specific tests
        // e.g. bytes_to_read: Vec<u8>, write_calls: Vec<u8>, read_calls: usize etc.
    }
    impl MockInterface { fn new() -> Self { MockInterface { break_sent: false, config: FrameFormat::Sdi12_7e1 } } }
    impl Sdi12Timer for MockInterface { fn delay_us(&mut self, _us: u32) {} fn delay_ms(&mut self, _ms: u32) {} }
    impl Sdi12Serial for MockInterface {
        type Error = MockCommError;
        fn read_byte(&mut self) -> NbResult<u8, Self::Error> { Err(nb::Error::WouldBlock) } // Default: no data
        fn write_byte(&mut self, _byte: u8) -> NbResult<(), Self::Error> { Ok(()) } // Default: success
        fn flush(&mut self) -> NbResult<(), Self::Error> { Ok(()) }
        fn send_break(&mut self) -> NbResult<(), Self::Error> { self.break_sent = true; Ok(()) }
        fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error> { self.config = config; Ok(()) }
    }


    #[test]
    fn test_recorder_construction() {
        let mock_interface = MockInterface::new();
        let _recorder = SyncRecorder::new(mock_interface);
    }

     #[test]
    fn test_acknowledge_placeholder() {
         let mock_interface = MockInterface::new();
         let mut recorder = SyncRecorder::new(mock_interface);
         let addr = Sdi12Addr::new('0').unwrap();
         // Still expecting placeholder error from execute_transaction
         assert!(matches!(recorder.acknowledge(addr), Err(Sdi12Error::Timeout)));
     }

     // src/recorder/mod.rs
// ... inside #[cfg(test)] mod tests ...

    #[test]
    fn test_execute_blocking_io_helper() {
        let mut mock_interface = MockInterface::new();
        let mut recorder = SyncRecorder::new(mock_interface);

        let mut call_count = 0;
        // Test the Ok path, T is i32
        let result: Result<i32, Sdi12Error<MockCommError>> = recorder.execute_blocking_io(|_iface| {
             call_count += 1;
             if call_count < 3 { Err(nb::Error::WouldBlock) } else { Ok(123) }
        });
        assert_eq!(call_count, 3);
        assert_eq!(result, Ok(123));

        call_count = 0;
         // Test the Err path. Specify the Ok type T as () for the Result.
         let result_err: Result<(), Sdi12Error<MockCommError>> = recorder.execute_blocking_io(|_iface| {
             call_count += 1;
              if call_count < 2 {
                  Err(nb::Error::WouldBlock)
              } else {
                  // Ensure the closure returns nb::Result<(), MockCommError> in the error case
                  Err(nb::Error::Other(MockCommError))
              }
              // No Ok(()) path needed here as it's unreachable for the error test logic,
              // but the type annotation on result_err tells the compiler T = ().
         });
         assert_eq!(call_count, 2);
         assert_eq!(result_err, Err(Sdi12Error::Io(MockCommError)));
         assert!(matches!(result_err, Err(Sdi12Error::Io(MockCommError))));

        // TODO: Test timeout case once timer logic added to helper
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/sensor/mod.rs
=======================



=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/sdi12.txt
=======================
SDI-12
A Serial-Digital Interface Standard
for
Microprocessor-Based Sensors
Version 1.4

February 20, 2023

Prepared By
SDI-12 Support Group
(Technical Committee)
165 East 500 South
River Heights, Utah
435-752-4200
435-752-1691 (FAX)
www.sdi-12.org

SDI-12 is not currently registered by any professional society, standards organization, or Government agency. Document
copies, current document status, and other information can be obtained by contacting the SDI-12 Support Group at 165 East
500 South, River Heights, Utah 84321, 435-752-4200, FAX 435-752-1691.

TABLE OF CONTENTS

1.0 INTRODUCTION....................................................................................................................1
2.0 ADVANTAGES OF SDI-12 ....................................................................................................1
3.0 SDI-12 ELECTRICAL INTERFACE....................................................................................2
3.1 Serial Data Line .............................................................................................................3
3.1.1 Voltage Transitions .........................................................................................3
3.1.2 Impedance .......................................................................................................3
3.2 Ground Line ...................................................................................................................4
3.2.1 Transient Protection ........................................................................................4
3.3 12-Volt Line ...................................................................................................................4
3.4 Connectors .....................................................................................................................5
4.0 SDI-12 COMMUNICATIONS PROTOCOL........................................................................5
4.1 Baud Rate and Byte Frame Format ................................................................................6
4.2 Allowable Characters .....................................................................................................6
4.3 Device Addresses ...........................................................................................................6
4.4 SDI-12 Commands and Responses ................................................................................7
4.4.1 Acknowledge Active Command (a!) ..............................................................9
4.4.1.1 Examples of the Acknowledge Active Command (a!) ..................9
4.4.2 Send Identification Command (aI!) ................................................................9
4.4.2.1 Example of the Send Identification Command ............................10
4.4.3 Address Query Command (?!) ......................................................................10
4.4.4 Change Address Command (aAb!) ...............................................................11
4.4.5 Start Measurement Command (aM!) ............................................................11
4.4.5.1 Aborting a Measurement ..............................................................12
4.4.6 Service Request .............................................................................................13

2/20/2023 Version 1.4

ii

4.4.7 Start Concurrent Measurement Command....................................................13
4.4.7.1 Aborting a Concurrent Measurement ...........................................14
4.4.8 Send Data Command (aD0! ... aD9!) ............................................................14
4.4.8.1 Continuous Measurements (aR0! ... aR9!) .................................. 16
4.4.8.2 Example of the aR0! Command .................................................. 16
4.4.8.3 Return of Multiple Measurements (Parameters) by a Sensor (D1!
… D9!) .....................................................................................................16
4.4.8.4 Examples of the Start Measurement Command (aM!) and the
Send Data Commands ..............................................................................17
4.4.8.5 Example of the Concurrent Measurement Command (aC!) and the
Send Data Command (aD0!) ................................................................... 18
4.4.9 Additional Measurement Commands (aM1! . . . aM9!) ...............................18
4.4.9.1 Examples of the Additional M Commands (aMn!) ......................19
4.4.10 Additional Concurrent Measurement Commands (aC1! … aC9!) .............19
4.4.11 Start Verification (aV!) ...............................................................................19
4.4.11.1 Examples of the Start Verification Command (aV!) ..................20
4.4.12 Requesting a Cyclic Redundancy Check ....................................................20
4.4.12.1 CRC-16 Computation.................................................................20
4.4.12.2 Encoding the CRC as ASCII Characters ....................................21
4.4.12.3 Examples of the CRC-16 Start Measurement Command (aMC!)
and the Send Data Command .................................................................. 21
4.4.13 Extended Commands ..................................................................................22
4.4.13.1 Extended Commands Returning Multiple Lines of Text .............23

4.4.14 Transparent Mode .......................................................................................24

2/20/2023 Version 1.4

iii

5.0 HIGH-VOLUME COMMANDS ......................................................................................... 24
5.1 Start High-Volume ASCII Measurement.....................................................................24
5.1.1 Example of High-Volume ASCII Measurement.......................................................25
5.2 Start High-Volume Binary Measurement ....................................................................26
5.2.1 High-Volume Binary Data Types .....................................................27
5.2.2 Example of High-Volume Binary Command .................................. 28
5.3 Concurrency of High-Volume Commands ................................................................. 29
5.4 Compliance with High-Volume Commands ............................................................... 29
6.0 METADATA COMMANDS .................................................................................................29
6.1 Identify Measurement Commands ...............................................................................29
6.1.1 Examples of the Identify Measurement Commands .........................30
6.2 Identify Measurement Parameter Commands ..............................................................30
6.2.1 Field One ...........................................................................................31
6.2.2 Field Two ..........................................................................................31
6.2.3 Optional Fields ..................................................................................31
6.2.4 Examples of the Identify Measurement Parameter Commands ........33
6.3 Compliance with Metadata Commands .......................................................................33
7.0 SDI-12 Timing ........................................................................................................................34
7.1 Rules for the Break ......................................................................................................35
7.2 Retries ..........................................................................................................................36

2/20/2023 Version 1.4

iv

APPENDICES ..............................................................................................................................37
Appendix A:
Appendix B:
Appendix C:
Appendix D:

2/20/2023 Version 1.4

Suggested SDI-12 Circuits .................................................................... A-1
Suggested SDI-12 Flow Control for SDI-12 Data Recorders ................B-1
& SDI-12 Sensors...................................................................................B-2
SDI-12 Glossary .....................................................................................C-1
Revisions ............................................................................................... D-1

v

LIST OF TABLES

Table 1. Logic and Voltage Levels for Serial Data .......................................................................3
Table 2. SDI-12 Byte Frame Format .............................................................................................6
Table 3. Printable Characters .........................................................................................................6
Table 4. Sensor Address Codes .....................................................................................................7
Table 5. The SDI-12 Basic Command/Response Set ....................................................................8
Table 6. The Acknowledge Active Command (a!) ........................................................................9
Table 7. The Send Identification Command (aI!) ........................................................................10
Table 8. The Change Address Command (aAb!) ........................................................................11
Table 9. The Start Measurement Command (aM!) ......................................................................11
Table 10. The Start Concurrent Measurement Command (aC!) ....................................................14
Table 11. The Send Data Command (aD0!, aD1 . . . aD9!) ...........................................................15
Table 12. High-Volume ASCII Measurement ...............................................................................24
Table 13. High-Volume Binary Measurement...............................................................................25
Table 14. Data Packet ....................................................................................................................26
Table 15. Empty Data Packet.........................................................................................................26
Table 16. Data Types .....................................................................................................................27
Table 17. Data Values in High-Volume Binary Command Example ............................................28
Table 18. Data Packet Examples ...................................................................................................28
Table 19. The Identify Measurement Commands................................................................ 29 & 30
Table 20. The Identify Measurement Parameter Commands .............................................. 32 & 33

2/20/2023 Version 1.4

vi

LIST OF FIGURES

Figure 1. The SDI-12 Bus ................................................................................................................. 3
Figure 2. Equivalent Circuit.............................................................................................................. 4
Figure 3. SDI-12 Timing................................................................................................................. 34

2/20/2023 Version 1.4

vii

SDI-12
A SERIAL-DIGITAL INTERFACE STANDARD
FOR MICROPROCESSOR-BASED SENSORS
SDI-12 Version 1.4

1.0 INTRODUCTION
This document describes Version 1.4 of the SDI-12 standard. Version 1.4 is an upgrade
from Version 1.3, dated January 28, 2016. The purpose of this document is to describe SDI-12 in
detail and to provide examples of all SDI-12 commands and responses. (See appendix D for a list
of upgrades made since Version 1.0.)
SDI-12 is a standard for interfacing data recorders with microprocessor-based sensors.
SDI-12 stands for serial/digital interface at 1200 baud. This document describes the electrical
interface, the communications protocol, and the timing requirements for SDI-12 data recorders
and SDI-12 sensors.
SDI-12 is intended for applications with the following requirements:
• Battery powered operation with minimal current drain
• Low system cost
• Use of a single data recorder with multiple sensors on one cable (see section 3.0
for details)
2.0 ADVANTAGES OF SDI-12
A serial-digital interface is a logical choice for interfacing microprocessor-based sensors
with a data recorder. This has advantages for sensors and data recorders.
• Unique and complex self-calibration algorithms can be done in
microprocessor-based sensors.
• Sensors can be interchanged without reprogramming the data recorder with
calibration or other information.
• Power is supplied to sensors through the interface.
• Hybrid circuit and surface mount technologies make it practical to include the
power supply regulator, a microprocessor, and other needed circuitry in small
sensor packages.
2/20/2023 Version 1.4

1

• Sensors can use low cost EEPROMs (electrically erasable programmable read
only memory) for calibration coefficients and other information instead of internal
trimming operations.
• The use of a standard serial interface eliminates significant complexity in the
design of data recorders.
• Data recorders can be designed and produced independently of future sensor
development.
• SDI-12 data recorders interface with a variety of sensors.
• SDI-12 sensors interface with a variety of data recorders.
• Personnel trained in SDI-12 will have skills to work with a variety of SDI-12
data recorders and SDI-12 sensors.
• SDI-12 sensors with the most recent version of SDI-12 will work with data
recorders using earlier versions of SDI-12 and vice versa.

3.0 SDI-12 ELECTRICAL INTERFACE
The SDI-12 electrical interface uses the SDI-12 bus to transmit serial data between
SDI-12 data recorders and sensors. The SDI-12 bus is the cable that connects multiple SDI-12
devices. This is a cable with three conductors:
1) a serial data line
2) a ground line
3) a 12-volt line
In the following specifications, all values not indicating specific limits, have an allowable
tolerance of ±10% of the value.
Figure 1 shows the SDI-12 bus connecting one data recorder with two sensors. The
SDI-12 bus is capable of having at least 10 sensors connected to it, each with 200 feet of cable.
With fewer sensors, longer cable lengths are possible.

2/20/2023 Version 1.4

2

3.1 Serial Data Line
The data line is a bidirectional, three-state, data transfer line. Table 1 shows the logic and
voltage levels for the transmission of serial data for the SDI-12 standard. The data line uses
negative logic.
Condition

Binary state

Voltage range

marking

1

-0.5 to 1.0 volts

spacing

0

3.5 to 5.5 volts

transition

undefined

1.0 to 3.5 volts

Table 1. Logic and voltage levels for serial data
3.1.1 Voltage Transitions
During normal operation, the data line voltage slew rate must not be greater than 1.5
volts per microsecond.
3.1.2 Impedance
When an SDI-12 device has its transmitter on, its direct current (DC) source resistance
must be greater than 1000 ohms and less than 2000 ohms. Due to this impedance, the maximum
cable length depends on the capacitance of all cables connected to the data line. When any
SDI-12 device's transmitter is off, including during a low-power standby mode, the DC
resistance to ground must be within 160K to 360K ohms. If an SDI-12 sensor does not use the
12-volt line for power, its data line resistance to ground while powered down must be within
160K to 360K ohms. Figure 2 shows an equivalent circuit.
2/20/2023 Version 1.4

3

3.2 Ground Line
The ground line must be connected to the circuit ground and the earth ground at the data
recorder. The sensor circuit ground also must be connected to the ground line, but not normally
to its own earth ground. If it is necessary to connect the sensor circuitry to earth ground, a heavy
(12 AWG or larger) ground wire should be connected between the sensor earth ground and the
data recorder earth ground for lightning protection.
The ground conductor should be large enough to keep the voltage drop between the data
recorder and all sensors less than 0.5 volts during the maximum combined sensor current drain.
3.2.1 Transient Protection
Transient protection is recommended on the SDI-12 bus. See appendix A for a suggested
SDI-12 transient protection method.
3.3 12 Volt-Line
The data recorder (or the external power supply) provides between 9.6 volts and 16 volts
to the 12-volt line, with respect to ground, as measured under a maximum sensor load of 0.5
amperes. SDI-12 does not require the data recorder to be the source of power to the 12-volt line.

2/20/2023 Version 1.4

4

For sensors connected to the 12-volt line that exhibit an inductive load, a series diode is
recommended. SDI-12 does not require voltage limiting for transient protection in the sensor.
Transient protection is, however, recommended. See appendix A for suggested circuits for
transient protection.
3.4 Connectors
A connector type for SDI-12 is not specified.
4.0 SDI-12 COMMUNICATIONS PROTOCOL
SDI-12 data recorders and sensors communicate by an exchange of ASCII characters on
the data line. The data recorder sends a break to wake up the sensors on the data line. A break is
continuous spacing on the data line for at least 12 milliseconds. The data recorder then sends a
command. The sensor, in turn, returns the appropriate response. Each command is for a specific
sensor. The first character of each command is a unique sensor address that specifies with which
sensor the recorder wants to communicate. Other sensors on the SDI-12 bus ignore the command
and return to low-power standby mode. When a data recorder tells a sensor to start its
measurement procedure, the recorder does not communicate with any other sensor until the data
collection from the first sensor is complete. (During a concurrent measurement command,
however, a data recorder can communicate with other sensors while one or more sensors are
taking measurements. See section 4.4.7.)
A typical recorder/sensor measurement sequence proceeds as follows:
Step 1. The data recorder wakes all sensors on the SDI-12 bus with a break.
Step 2. The recorder transmits a command to a specific, addressed sensor, instructing it
to make a measurement.
Step 3. The addressed sensor responds within 15.0 milliseconds returning the maximum
time until the measurement data will be ready and the number of data values it will
return.
Step 4. If the measurement is immediately available, the recorder transmits a command
to the sensor instructing it to return the measurement(s). If the measurement is not ready,
the data recorder waits for the sensor to send a request to the recorder, which indicates
that the data are ready. The recorder then transmits a command to get the data.
Step 5. The sensor responds, returning one or more measurements.

2/20/2023 Version 1.4

5

4.1 Baud Rate and Byte Frame Format
The baud rate for SDI-12 is 1200. Table 2 shows the byte frame format for SDI-12.
1 start bit
7 data bits, least significant bit transmitted first
1 parity bit, even parity
1 stop bit

Table 2. SDI-12 byte frame format

4.2 Allowable Characters
All characters transmitted on the SDI-12 bus must be printable ASCII characters. Table 3
shows the printable characters.
space, 32 decimal
through
~, 126 decimal

Table 3. Printable characters

There are three exceptions:
1) all responses from an SDI-12 sensor end with a carriage return (0D hex, 13 decimal)
and a line feed (0A hex, 10 decimal) character, shown as <CR><LF> in this document;
2) in some cases the second and third character of a CRC code may not be printable
ASCII characters;
3) the contents of data packets returned by the high-volume binary command.
4.3 Device Addresses
The first character of every command must be a sensor address. Likewise, the first
character of a response is also the address character. This lets an SDI-12 recorder verify that the
response has come from the correct sensor. (An address is a single character used to indicate
which sensor is to respond to the command.) Table 4 shows the address codes.

2/20/2023 Version 1.4

6

ASCII address
(a single character)

Decimal

Hex

Description

"0" (zero)

48

30

Default address, all sensors are initially set to
"0" (zero) by the manufacturer for use in single
sensor systems

"1" to "9"

49 to 57

31 to 39

Addresses for additional sensors on the SDI-12
bus

Table 4. Sensor address codes

ASCII '0' through ASCII '9' are the standard addresses which all sensors and data
recorders must support. Should there be a need for more than 10 sensors, use an address in the
range ASCII 'A' through ASCII 'Z' (decimal 65 through 90) and ASCII 'a' through ASCII 'z'
(decimal 97 through 122).

4.4 SDI-12 Commands and Responses
Table 5 lists each basic SDI-12 command, its format, and the format of each response to a
command. All SDI-12 Version 1.4 sensors and data recorders must support all commands in this
table. None of the basic commands should affect the sensor’s calibration. In addition, sensors
may support extended commands as described in section 4.4.13. The terms in this table
(a,ll,cccccccc,mmmmmm,vvv,xxx,<values>, etc.) are described in sections 4.4.1 to 4.4.12.

2/20/2023 Version 1.4

7

Name

Command

Response

Break

Continuous
spacing for at least
12 milliseconds
a!
aI!
aAb!

None

Acknowledge Active
Send Identification
Change Address
Address Query
Start Measurement*
Start Measurement and Request
CRC*
Send Data

Additional Measurements*

?!
aM!
aMC!

a<CR><LF>
allccccccccmmmmmmvvvxxx...xx<CR><LF>
b<CR><LF> (support for this command is required only if
the sensor supports software changeable addresses)
a<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aD0!
.
.
.
aD9!
aM1!
.
.
.
aM9!
aMC1! ... aMC9!

a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
a<values><CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

Additional Measurements and
Request CRC*
Start Verification*
aV!
Start Concurrent Measurement
aC!
Start Concurrent Measurement and aCC!
Request CRC
Additional Concurrent
aC1!
Measurements
.
.
.
aC9!
Additional Concurrent
aCC1! ... aCC9!
Measurements and Request CRC
Continuous Measurements
aR0! ... aR9!
Continuous Measurements and
aRC0! ... aRC9!
Request CRC
*

or
or
or
or
or

a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>
a<values><CRC><CR><LF>

atttn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
a<values><CR><LF> (formatted like the D commands)
a<values><CRC><CR><LF> (formatted like the D
commands)

This command may result in a service request. See section 4.4.6.

Table 5. The SDI-12 basic command/response set
See Tables 12 and 13 for the high-volume commands (pages 24-25), Table 19 for the identify measurement
commands (page 29), and Table 20 for the identify measurement parameter commands (page 32).

2/20/2023 Version 1.4

8

The first character of all commands and responses is always a device address. The last
character of a command is the "!" character. The “!” can only be in a command as the command
terminator. The last two bytes of a response are a carriage return and line feed (<CR><LF>).
The maximum number of characters that can be returned in the <values> part of the
response to a D command is either 35 or 75. If the D command is issued to retrieve data in
response to a concurrent measurement command, or in response to a high-volume ASCII
measurement command, the maximum is 75. The maximum is also 75 in response to a
continuous measurement command. Otherwise, the maximum is 35.

4.4.1 Acknowledge Active Command (a!)
This command is used to ensure that a sensor is responding to a data recorder or another
SDI-12 device. It asks a sensor to acknowledge its presence on the SDI-12 bus. Table 6 shows
the acknowledge active command.
Command

Response

a!

a<CR><LF>

a - the sensor address

a - the sensor address

! - terminates the command

<CR><LF> - terminates the response

Table 6. The acknowledge active command (a!)

4.4.1.1 Examples of the Acknowledge Active Command (a!)
0!0<CR><LF>
1!1<CR><LF>

4.4.2 Send Identification Command (aI!)
This command is used to query sensors for their SDI-12 compatibility level, model
number, and firmware version number. Table 7 shows the send identification command.

2/20/2023 Version 1.4

9

Command

Response

aI!

allccccccccmmmmmmvvvxxx . . . xxx<CR><LF>

a - the sensor address

a - the sensor address

I – the send identification
command

ll - the SDI-12 version number, indicating SDI-12 version
compatibility; for example, version 1.4 is encoded as 14

! - terminates the command

cccccccc - an 8 character vendor identification, usually a company
name or its abbreviation
mmmmmm - 6 characters specifying the sensor model number
vvv - 3 characters specifying the sensor version
xxx . . . xx - an optional field, up to 13 characters, used for a serial
number or other specific sensor information that is not relevant for
operation of the data recorder
<CR><LF> - terminates the response

Table 7. The send identification command (aI!)
4.4.2.1 Example of the Send Identification Command (AI!)

4.4.3 Address Query Command (?!)
When a question mark (?) is used as the address character with the acknowledge active
command (a!), the sensor will respond as if it is being addressed on the SDI-12 bus. For
example, if a sensor detects ?!, it will respond with a<CR><LF>, no matter what its address may
be. This will allow a user to determine the address of a sensor. The user should understand that if
more than one sensor is connected to the bus, they will all respond, causing a bus contention. A
sensor is required to support the wild card address character (?) with the acknowledge active
command (?!). The sensor may also support the wild card address with all other commands; this
is not, however, a requirement.

2/20/2023 Version 1.4

10

4.4.4 Change Address Command (aAb!)
This command changes the address of a sensor. If the sensor supports software
changeable addresses, it must support the change address command. Table 8 shows this
command.
After this command has been issued and responded to, the sensor is not required to
respond to another command for one second. This gives the sensor time to write the new address
to non-volatile memory.
Command

Response

aAb!

b<CR><LF>

a - the sensor address

b - the address of the sensor (will equal the new address or
the original address if the sensor is unable to change the
address)

A - the change address command
b - the address to change to
! - terminates the command

<CR><LF> - terminates the response

Table 8. The change address command (aAb!)
4.4.5 Start Measurement Command (aM!)
This command tells the sensor to take a measurement. The sensor does not, however,
return the measurement to the data recorder after this command. It returns the time until one or
more measurements will be ready and the number of measurements that it will make. The send
data (D0!) command must be issued to get the measurement(s). Table 9 shows the start
measurement command.

Command

Response

aM!

atttn<CR><LF>

a - the sensor address

a - the sensor address

M - the start measurement

ttt - the specified time, in seconds, until the sensor will have the
measurement(s) ready

! - terminates the command

n - the number of measurement values the sensor will make and return
in one or more subsequent D commands; n is a single digit integer with
a valid range of 1 to 9

Table 9. The start measurement command (aM!)

2/20/2023 Version 1.4

11

If the sensor returns 000 (ttt), the measurement is immediately available for transfer to
the data recorder. The data recorder should issue the D0 command to get the data.
If ttt is not equal to zero (000), the data recorder must wait for the specified time to
elapse. The ttt time period begins upon completion of the transmission of the line feed character.
Then it wakes the sensor with a break and issues the D0 command. If, however, the sensor has
the measurement ready before ttt seconds elapse, it will send a service request to the recorder.
This tells the recorder to stop marking time and issue the D0 command.
When a data recorder issues an M command, it must complete the command/response
sequence with the sensor before it sends any command to any other sensor. For example,
suppose that following the issuance of the M command, the sensor responds
0M!00101<CR><LF>
This response shows that one data value will be ready in 10 seconds. The data recorder
must wait for either of two events to occur before issuing a D0 command:
1) receipt of a service request (a<CR><LF>) from the sensor
2) the specified time to elapse (10 seconds)
The recorder then issues the D0 command to get the data. After the M command and
before the sensor issues the service request, the data recorder will not communicate with any
other sensor. The sensor must not drive the data line until it sends a service request. The
recorder must not drive the data line while waiting for the service request.
A sensor should return a ttt value greater than the time it takes to make a measurement, to
allow for timing tolerances and for the service request. (See section 4.4.6.) The data recorder
may wait for the entire ttt time. Therefore, the tolerance above the measurement, added to ttt,
should be minimal.
After a sensor finishes its measurement procedure, the sensor must retain the measured
data in memory until it receives another M or V command, or another command that returns data
via the D0 command.
See the send data command, aD0!, aD1! . . . aD9!, for examples of this command.
Because the start measurement command is closely related to the send data command, examples
for both commands are shown on page 17.
4.4.5.1 Aborting a Measurement
If a sensor detects a break after it receives an M command, but before it issues a service
request, it must abort its measurement procedure. The sensor address, followed by <CR><LF>,
(or followed by <CRC><CR><LF> if a CRC was requested) should be returned in response to

2/20/2023 Version 1.4

12

subsequent D commands. This requirement provides a way for a data recorder to abort a
measurement so it can communicate with another sensor, or this sensor, on the SDI-12 bus.

4.4.6 Service Request (a<CR><LF>)
A service request is a response from a sensor. It is not a command. It is sent, after an M
command, to tell the data recorder that the sensor has finished its measurement(s) and the data
are ready. A service request is issued by the sensor after an M, MC, or V command, when it has
finished its measurement. The entire service request must be returned before ttt seconds (see
Start Measurement Command, page 11) have elapsed. The time (ttt) is the maximum time that a
sensor will take before it has data available.
If a data recorder does not detect a service request, the data recorder must wait for the
specified time (ttt), given in response to the M or V command, and then issue the D0 command
to get the data. The minimum time before a data recorder can issue the D0 command to get the
data, in this case, is ttt seconds.
A sensor is required to issue a service request if it indicates that it will take one second or
longer before data are ready, in response to an M or V command. If a sensor says it will take zero
seconds before the data are ready, then a sensor must not issue a service request.
4.4.7 Start Concurrent Measurement Command (aC!)
This command, introduced in Version 1.2 of the SDI-12 Specification, tells the sensor to
take a concurrent measurement. A concurrent measurement is one which occurs while other
SDI-12 sensors on the bus are also taking measurements. The sensor does not, however, return
the measurement to the data recorder after this command. It returns the time until all
measurements will be ready and the number of measurement that it will make. The send data
(D0!) command must be issued to collect the measurements(s). Table 10 shows the start
concurrent measurement command.
If the sensor returns 000 (ttt), the measurement is immediately available for transfer to
the data recorder. The data recorder should issue the D0 command to get the data.
If ttt is not equal to zero (000), the data recorder must wait for the specified time to elapse
before attempting to retrieve the data. The ttt time period begins upon completion of the
transmission of the line feed character. During this time the data recorder can collect data from
sensors at other addresses. Communicating with other sensors will not abort a concurrent
measurement. After the specified time has elapsed, the data recorder wakes the sensor with a
break and issues the D0 command. The sensor will not issue a service request when it has
completed the measurement. The sensor must not drive the data line from the time it
completes its atttnn<CR><LF> response until it starts responding to the D0 command.

2/20/2023 Version 1.4

13

Command

Response

aC!

atttnn<CR><LF>

a - the sensor address

a - the sensor address

C - the start concurrent
measurement command

ttt - the specified time, in seconds, until the sensor will have the
measurement(s) ready

! - terminates the command

nn - the number of measurement values the sensor will make and
return in response to one or more subsequent D commands

Table 10. The start concurrent measurement command (aC!)
The data recorder should document the number of data values it can store in response to a
C command.
After a sensor finishes its measurement procedure, the sensor must retain the measured
data in memory until it receives another C, M, or V command, or another command that returns
data via the D0 command.
See the send data command, aD0!, aD1! . . . aD9!, section 4.4.8, for the data response
requirements. Because the start concurrent measurement command is closely related to the send
data command, examples for both commands are in sections 4.4.8.3 and 4.4.8.4.
For a sensor or data logger to claim support of Version 1.2 or higher of the SDI-12
Specification, it must support this command. Claiming zero data values in response to this
command (i.e. a response of a00000<CR><LF>) is not a valid support of this command. The
command must initiate a true measurement cycle. Sensors or data recorders that conform to a
previous version of SDI-12 will most likely not support this command, and will therefore not
respond to this command.
4.4.7.1 Aborting a Concurrent Measurement
If a sensor receives a valid command addressed to it while it is in the process of a
concurrent measurement, it should abort the measurement procedure. The sensor address
followed by <CR><LF> (or <CRC><CR><LF> if a CRC was requested) should be returned in
response to subsequent D commands. This requirement provides a way for a data recorder to
abort a measurement.
4.4.8 Send Data Command (aD0!, aD1! . . . aD9!)
This command is used to get groups of data from the sensor. D0! is issued after an M, MC, C,
CC, V, or HA command. The sensor responds by sending the data. If the expected number of
measurements is not returned in response to a D0! command, the data recorder issuesD1!, D2!,
etc. until all measurement values are received. (The expected number of measurements is given
in the response to an M, C, or V command.) Table 11 shows the send data command.
2/20/2023 Version 1.4

14

Command

Response

aD0! (aD1! . . . aD9!)

a<values><CR><LF>
or
a<values><CRC><CR><LF>

a - the sensor address

a - the sensor address

D0 - the send data command, D1 . .
. D9 additional send data
commands

values (see below)

! - terminates the command

<CR><LF> - terminates the response
<values> - pd.d
p - the polarity sign (+ or -)
d - numeric digits before the decimal place
. - the decimal point (optional)
d - numeric digits after the decimal point
the maximum number of digits for a data
value is 7, even without a decimal point
the minimum number of digits for a data
value (excluding the decimal point) is 1
the maximum number of characters in a
data value is 9 (the (polarity sign + 7
digits + the decimal point))
<CRC> - 3 character CRC code, appended if data was
requested with the aMC!, aMC1! ... aMC9!, aCC!, or
aCC1! ... aCC9! commands (see section 4.4.12)

Table 11. The send data command (aD0!, aD1! . . . aD9!)
If the response to a D command is valid, but no data are returned, the sensor has aborted
the measurement. To obtain data the recorder must issue another M, C, or V command.
Notes: in response to certain commands, the data returned after a D command may have a
Cyclic Redundancy Check (CRC) appended to it. See section 4.4.12. The hig1h volume ASCII
command, HA, extends the range of the send data commands. See section 5.1.

2/20/2023 Version 1.4

15

The maximum number of characters that can be returned in the <values> part of the
response to a D command is either 35 or 75. If the D command is issued to retrieve data in
response to a concurrent command, or a high-volume ASCII command, the maximum is 75.
Otherwise, the maximum is 35.
4.4.8.1 Continuous Measurements (aR0! ... aR9!)
Sensors that are able to continuously monitor the phenomena to be measured, such as a
shaft encoder, do not require a start measurement command (M!, M1! . . . M9!). They can be
read directly with the R commands (R0! ... R9!). For example:
if (the sensor is operating in a continuous measurement mode) then
aR0! will get and return the current reading of the sensor

The response to R commands (R0! ... R9!) are formatted like the D commands (D0! ...
D9!). The main difference is that the R commands do not need to be preceded with an M
command, which tells the sensor to take a measurement. The maximum number of characters
that can be returned in the <values> part of the response to an R command is 75.
Each R command is an independent measurement. For example, R5 need not be preceded
by R0 ... R4.
If a sensor is unable to take a continuous measurement, then it must return its address
followed by a carriage return/line feed (a<CR><LF>) in response to an R command. If a CRC
was requested, then the <CR><LF> must be preceded by the CRC. For example:
0AP@<CR><LF>.
4.4.8.2 Example of the aR0! Command
One measurement is immediately available after the R0! command:
0R0!0+3.14<CR><LF>

4.4.8.3 Return of Multiple Measurements (Parameters) by a Sensor (D1! . . . D9!)
The commands D1 . . . D9 are used with sensors that return multiple measurements. The
purpose of the D commands is for the sensor to return as many measurements as possible in
response to each command. The limiting constraint is that the total number of characters that can
be returned in the <values> field (see section 4.4.8). If the total number of characters exceeds the
maximum length of the <values> field, the sensor fragments the response, sending the first group
of measurements in response to D0, the next group in response to D1, and so on. A group can
have one or more measurements; data collection always begins with the D0 command. See
section 4.4.8.4 for examples.
The sensor must never split individual data values, sending part of a value in response to
one D command, sending the rest of the characters, for that value, in response to the next D
command.
2/20/2023 Version 1.4

16

If possible, a sensor should return all measurements in response to the D0 command. This
is not, however, a requirement.
4.4.8.4 Examples of the Start Measurement Command (aM!) and the Send Data
Commands
a. One measurement is immediately available after the M command:
0M!00001<CR><LF>
0D0!0+3.14<CR><LF>

b. Three measurements will be ready 5 seconds after the M command, and the sensor issues a
service request. All 3 measurements are returned in response to the D0 command:
0M!00053<CR><LF>
0<CR><LF>
0D0!0+3.14+2.718+1.414<CR><LF>

c. Nine measurements will be ready 35 seconds after the M command, and the sensor issues a
service request. Because the number of characters in all 9 measurements exceeds the limit in the
<values> field, a D1 command must be issued to get the second group of measurements:
0M!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66<CR><LF>
0D1!0+7.77+8.88+9.99<CR><LF>

d. Two measurements will be available in 1 second, and the sensor does not issue a service
request. After 1 second, the data recorder sends a break to wake the sensor and issues the D0
command:
0M!00012<CR><LF>
0D0!0+3.14+2.718<CR><LF>
Note: this example shows the proper operation of the data recorder, but the sensor is out of
compliance because it did not issue a service request.

2/20/2023 Version 1.4

17

e. Three measurements will be ready 5 seconds after the M command, and the sensor issues a
service request. Upon receipt of the service request, the data recorder issues D0 to get the data.
However, only 1 measurement is returned. The data recorder then issues the D1 command to get
the next group of data. In response, the second measurement is returned. Then the recorder issues
D2 to get the next, and last, group of data. In the example, each group contains only one
measurement.
0M!00053<CR><LF>
0<CR><LF>
0D0!0+3.14<CR><LF>
0D1!0+2.718<CR><LF>
0D2!0+1.414<CR><LF>
Note: This is in compliance with the standard. As many measurements as possible, however,
should be returned in response to each D command.
4.4.8.5 Example of the Concurrent Measurement Command (aC!) and the Send Data
Command (aD0!)
Two sensors, one returning 12 readings after 45 seconds and the other returning 4
readings after 15 seconds. The measurements are taken concurrently. Fifteen seconds after
starting a measurement from sensor 1, the data recorder issues a break followed by the D0
command to sensor address 1. Forty-five seconds (or longer) after starting a measurement from
the sensor at address 0, the data recorder sends a break and a D0 command to sensor 0. Note that
since a concurrent measurement was requested of sensor 0, it is allowed to return up to 75
characters in its <values> field of the response. An M command only allows 35 characters in its
<values> field to ensure compatibility with data recorders prior to version 1.2.
0C!004512<CR><LF>
1C!101504<CR><LF>
1D0!1+1.23+2.34+345+4.4678<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12<CR><LF>

4.4.9 Additional Measurement Commands (aM1! . . . aM9!)
Additional M commands provide a means to request different types of measurements
from a sensor or to instruct a sensor to do a calibration or a control function. For example, a
sensor could measure pressure and temperature: M tells it to measure pressure and M1 tells it to
measure the temperature.
Additional M commands have the same format as the aM! command. Data collection
always begins with the D0 command. If the sensor does not return the expected number of
measurements in response to the D0 command, the recorder should issue aD1, aD2, etc. until the
sensor returns all measurements.
To comply with Version 1.2 or higher of SDI-12, sensors must respond to the additional
measurement commands (aM1! . . . aM9!) and data recorders must be able to log data from the

2/20/2023 Version 1.4

18

additional measurement commands. If a sensor has no data defined for an additional
measurement command, it should return a0000<CR><LF>, saying that it has zero data values
ready. Not responding to the command is not acceptable.
4.4.9.1 Examples of the Additional M Commands (aMn!)
a. A sensor supports the aM1! command:
0M1!00011<CR><LF>
0<CR><LF>
0D0!0+3.14<CR><LF>
b. A sensor takes 9 measurements in response to the M2 command:
0M2!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66<CR><LF>
0D1!0+7.77+8.88+9.99<CR><LF>
4.4.10 Additional Concurrent Measurement Commands (aC1! . . . aC9!)
Additional C commands provide a means to request different types of measurements
from a sensor or to instruct a sensor to do a calibration or a control function. To comply with
Version 1.2 or higher of SDI-12, sensors must respond to the additional concurrent measurement
commands and data recorders must be able to log data from the additional concurrent
measurement commands. If a sensor has no parameters defined for an additional concurrent
measurement command, then it should return a00000<CR><LF>, saying that it has zero data
values ready. Not responding to the command is not acceptable.
Additional C commands have the same format and constraints as the aC! command. Data
collection always begins with the D0 command. If the sensor does not return the expected
number of measurements in response to the D0 command, the recorder should issue aD1, aD2,
etc., until the sensor returns all measurements.
4.4.11 Start Verification (aV!)
This command tells the sensor to return a verification in response to a subsequent D
command. A verification sequence may include ROM signatures, CRC's, RAM test results, or
the results of other diagnostics in the sensor. A standard response to the V command is not
specified.
The format of this command is the same as the M commands. The format of the response
is the same as the D commands.

2/20/2023 Version 1.4

19

4.4.11.1 Example of the Start Verification Command (aV!)
0V!00011<CR><LF>
0<CR><LF>
0D0!0+1<CR><LF>

4.4.12 Requesting a Cyclic Redundancy Check (CRC)
To enhance the error detection capability in SDI-12 data collection systems, a variation of
the Start Measurement Commands (M!, M1! ... M9!), Start Concurrent Measurement Commands
(C!, C1! ... C9!), and Continuous Measurement Commands (aR0! ... aR9!) request that the data
be returned with a 16 bit Cyclic Redundancy Check (CRC) appended to it. These commands
use the existing command letters with a C appended, namely: aMC!, aMC1! ... aMC9!, aCC!,
aCC1! ... aCC9!, and aRC0! ... aRC9!. When these commands are used, the data returned in
response to the D commands, or R commands, must have a CRC code appended to it.
The number of measurements returned in response to a CRC command should be the
same as the measurement that was made in response to a non-CRC command. In other words, the
CRC command causes the same measurements to be taken as the non-CRC command.
To be version 1.3 (or higher) compliant, the sensor must support CRCs.
4.4.12.1 CRC-16 Computation
The computation of the CRC is performed on the data response before parity is added.
All operations are assumed to be on 16 bit unsigned integers. The least significant bit is on the
right. Numbers preceded by 0x are in hexadecimal. All shifts shift in a zero. The algorithm is:
Initialize the CRC to zero. For each character beginning with the address, up to but not including, the carriage return
(<CR>).
{
Set the CRC equal to the exclusive OR of the character and itself
for count = 1 to 8
{
if the least significant bit of the CRC is one
{
right shift the CRC one bit
set CRC equal to the exclusive OR of 0xA001 and itself
}
else
{
right shift the CRC one bit
}
}
}

2/20/2023 Version 1.4

20

4.4.12.2 Encoding the CRC as ASCII Characters
The 16 bit CRC is encoded as three ASCII characters using the following algorithm:
1st character = 0x40 OR (CRC shifted right 12 bits)
2nd character = 0x40 OR ((CRC shifted right 6 bits) AND 0x3F)
3rd character = 0x40 OR (CRC AND 0x3F)

The three ASCII characters are placed after the data before the <CR><LF>. Parity is
applied to all three characters when they are transmitted. The AND and OR operators are bitwise
operators, not logical operators.
4.4.12.3 Examples of the CRC-16 Start Measurement Command (aMC!) and the Send Data
Command (aD0!)
a. One measurement is immediately available after the MC command:
0MC!00001<CR><LF>
0D0!0+3.14OqZ<CR><LF>
b. Three measurements will be ready 5 seconds after the MC command, and the sensor issues a
service request. All 3 measurements are returned in response to the D0 command:
0MC!00053<CR><LF>
0<CR><LF>
0D0!0+3.14+2.718+1.414Ipz<CR><LF>
c. Nine measurements will be ready 35 seconds after the MC command, and the sensor issues a
service request. Because the number of characters in all 9 measurements exceeds the limit for the
<values> field, a D1 command must be issued to get the second group of measurements:
0MC!00359<CR><LF>
0<CR><LF>
0D0!0+1.11+2.22+3.33+4.44+5.55+6.66I]q<CR><LF>
0D1!0+7.77+8.88+9.99IvW<CR><LF>
d. Two measurements will be available in one second, and the sensor does not issue a service
request. After one second, the data recorder sends a break to wake the sensor and issues the D0
command:
0MC!00012<CR><LF>
0D0!0+3.14+2.718IWO<CR><LF>
Note: this example shows the proper operation of the data recorder, but the sensor is out of
compliance because it did not issue a service request.
e. Three measurements will be ready five seconds after the MC command, and the sensor issues

2/20/2023 Version 1.4

21

a service request. Upon receipt of the service request, the data recorder issues D0 to get the data.
Only one measurement, however, is returned. The data recorder then issues the D1 command to
get the next group of data. In response, the second measurement is returned. Then the recorder
issues D2 to get the next, and last, group of data. In this example, each group contains only one
measurement.
0MC!00053<CR><LF>
0<CR><LF>
0D0!0+3.14OqZ<CR><LF>
0D1!0+2.718Gbc<CR><LF>
0D2!0+1.414GtW<CR><LF>
Note: this is in compliance with the standard. As many measurements as possible, however,
should be returned in response to each D command.
f. Two sensors, one returning 12 readings after 45 seconds and the other returning 4 readings
after 15 seconds. The measurements are taken concurrently. Fifteen seconds after starting a
measurement from sensor 1, the data recorder issues a break followed by the D0 command to
sensor address one. Forty-five seconds (or longer) after starting a measurement from the sensor
at address 0, the data recorder sends a break and a D0 command to sensor 0. Since a concurrent
measurement was requested of sensor 0, it is allowed to return up to 75 characters in the
<values> field of its response:
0CC!004512<CR><LF>
1CC!101504<CR><LF>
1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12
Ba]<CR><LF>
4.4.13 Extended Commands
Sensors are required only to respond to the basic SDI-12 command set. Sensors,
however, usually require calibration or other setup commands. Extended commands provide the
means for such functions. An extended command is a command for a specific make of sensor to
tell that sensor to do a specific task. Extended commands are defined and documented by the
manufacturer of each sensor.
Extended commands have the following attributes:
• an extended command must be prefixed with an address
• an extended command must be terminated with an exclamation point
• the response must be prefixed with an address
• the response must be terminated with <CR><LF>
• the transparent mode must support basic SDI-12 commands and extended
commands

2/20/2023 Version 1.4

22

Extended commands should be prefixed with an upper case X, for example, aXNNN!,
where X says that an extended command follows and NNN is the extended command. NNN is
not limited to three characters. Prefixing extended commands with an upper case X is a
recommendation only and is not a requirement. Future versions of SDI-12, however, may
require this.
4.4.13.1 Extended Commands Returning Multiple Lines of Text
Many SDI-12 sensors have sufficient memory to store and return multiple lines of text to
a data recorder, such as returning detailed documentation about the sensor. To support this, an
extended command may return multiple lines of text, with each line of text terminated with a
carriage return/line feed pair (<CR><LF>).
The transmission of each text line must conform with the same timing requirements for
all SDI-12 sensor responses.
When multiple lines of text are going to be returned, the sensor must indicate that two or
more lines of text will be returned in response to the extended command by placing the ASCII
character “start of text” (STX, decimal value 2) after the address character, in the first line of text
returned to the data recorder.
The sensor must indicate the last line of text with the ASCII character “end of text,”
(ETX, decimal value 3) after the <CR><LF> pair in the final line of text.
The maximum number of ASCII characters allowed in each line of text, exclusive of the
SDI-12 address, <STX>, <CR>, <LF>. and <ETX> characters, is 75.
ASCII CRC error detection characters are not appended to the lines of text.
The time between the transmission of each line of text must be less than or equal to 150
milliseconds. If the start bit of the first character in the next expected line of text is not received
in 150 milliseconds, then the data recorder should conclude that no more lines of text are
forthcoming.
Here is an example:
0XHELP!0<STX>This is the first line of text.<CR><LF>
This is the second line of text.<CR><LF>
This is the third and final line of text.<CR><LF> <ETX>

Sensor and data logger support for returning and receiving multiple lines of text is not an
SDI-12 requirement.

2/20/2023 Version 1.4

23

4.4.14 Transparent Mode
SDI-12 data recorders must have a mode in which extended commands can be sent to
sensors. This is called the transparent mode. The transparent mode has the following
characteristics.
• The data recorder buffers a command string received from a computer, terminal, or
modem, until the command string is terminated.
• The data recorder wakes the sensor with a break, then it sends the buffered command
to the sensor, using the SDI-12 protocol.
• The data recorder receives the response from the sensor and transmits the response to
the computer, the terminal, or the modem.

5.0 HIGH-VOLUME COMMANDS
The high-volume commands, introduced in version 1.4 of the SDI-12 Specification,
expand the concurrent measurement commands to allow up to 999 parameters to be returned
from a sensor.
5.1 Start High-Volume ASCII Measurement
Table 12 shows the high-volume ASCII measurement command.
Command Name

Command

Response

High-Volume ASCII

aHA!

atttnnn<CR><LF>

Table 12. High-Volume ASCII measurement
The commands to get high-volume data after the aHA! command are: aD0! … aD999!
If after obtaining the data values from aD9! there are still more data values to obtain,
continue to send data requests with aD10!...aD99! as needed. If after obtaining the data values
from aD99! there are still more data values to obtain, continue to the send data requests with
aD100!...aD999! as needed. Leading zeros are not placed after the “D”
The responses to the send data commands follow the same rules as with the Concurrent
Measurement send data commands. The maximum number of characters that can be returned in
the <values> part of the response is 75 and a three character <CRC> is appended to the data
before the <CR><LF>. The CRC must be present.

2/20/2023 Version 1.4

24

5.1.1 Example of High-Volume ASCII Measurement
In this example there are two sensors, one returning 12 data values after 45 seconds and
the other returning 4 data values after 15 seconds. The first measurement uses the high-volume
ASCII command; the second one uses the concurrent command with a CRC. Fifteen seconds
after requesting data from sensor one, the data recorder issues a break followed by the D0
command to sensor address 1. Forty-five seconds (or longer) after starting the measurement from
the sensor at address 0, the data recorder sends a break and a D0 command to sensor 0. Since a
high-volume ASCII measurement was requested of sensor 0, it is allowed to return up to 75
characters in the <values> field of its response, and it does not abort when sensor 1 is addressed:
0HA!0045012<CR><LF>
1CC!101504<CR><LF
1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>
0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12Ba]<CR><LF>

5.2 Start High-Volume Binary Measurement
The high-volume binary measurement allows for collection of large volumes of data from
a sensor more efficiently than the ASCII transfer methods.
Command Name

Command

Response

High-Volume Binary

aHB!

atttnnn<CR><LF>

Table 13. High-Volume binary measurement
The commands to get high-volume binary data after the aHB! command are: aDB0! …
aDB999!
If after obtaining the data values from aDB9! there are still more data values to obtain,
continue the send data requests with aDB10!...aDB99! as needed. If after obtaining the data
values from aDB99! there are still more data values to obtain, continue the send data requests
with aDB100!...aDB999! as needed.
Responses to the aDB0! … aDB999! commands are an exception to section 4.1 Table 2
because the byte frame format is 8 data bits, no parity bit. The SDI-12 address is
transmitted as the ASCII character, but no parity bit. The remaining fields are encoded as
binary numbers. The least significant byte is transferred first for multi-byte binary
numbers.

2/20/2023 Version 1.4

25

SDI-12
Address

ASCII

Packet Size

Data Type

16 bit unsigned integer, indicates
the size, in bytes, of the binary
data payload

8 bit unsigned
integer, indicates
the data type in
the binary data
payload

Binary Data
Payload

must be <= 1,000
bytes

CRC
16 bit CRC value, using
the same algorithm as the
other measurement
commands that request a
CRC, but encoded in
binary (not converted to
3 byte ASCII)

Table 14. Data packet
If the value of n in aDBn! is invalid due to being higher than necessary to return data values, then
the data package must be:
SDI-12
Address

Packet Size

Data Type

Binary Data
Payload

CRC

address

0

0

nil

16 bit CRC

Table 15. Empty data packet
All data values in a particular response must be of the same type, but data types can differ
between aDBn! commands.
Nil, as shown in Table 15, means that the binary data payload is empty: there are zero data
bytes in it. An empty data packet, therefore, has six bytes only:
1 byte:
2 bytes:
1 byte:
2 bytes:

the address;
the packet size (zero);
the data type (zero);
the CRC value.

2/20/2023 Version 1.4

26

5.2.1 High-Volume Binary Data Types
Table 16 shows the high-volume binary data types.
Data
Type

Range

Size

0

Indicates an invalid request

No data returned

1

-128 to 127

Signed 8-bit integer

2

0 to 255

Unsigned 8-bit integer

3

-32,768 to 32,767

Signed 16-bit integer

4

0 to 65,535

Unsigned 16-bit integer

5

-2,147,483,648 to 2,147,483,647

Signed 32-bit integer

6

0 to 4,294,967,295

Unsigned 32-bit integer

7

-9,223,372,036,854,775,808 to
9,223,372,036,854,775,807

Signed 64-bit integer

8

0 to 18,446,744,073,709,551,615

Unsigned 64-bit integer

9

±1.18×10−38 to ±3.4×1038

IEEE 32-bit floating point single
precision/binary32

10

±2.23×10−308 to ±1.80×10308

IEEE-64 bit floating point double
precision/binary64

Table 16. Data types

2/20/2023 Version 1.4

27

5.2.2 Example of High-Volume Binary Command
In this example a data recorder transmits a high-volume binary command and the sensor
responds, indicating that four data values will be available after five seconds:
1HB!1005004<CR><LF>
Table 17 shows the data values, returned in binary data packets, that are used in this
example. Two of the four data values are returned in a data packet as signed 16-bit integers; the
other two data values are returned in a data packet as 32-bit single precision floating point
numbers.
Data Type

Size

Data Value

Data Value in Hexadecimal

3

Signed 16-bit integer

-1

0xFFFF

3

Signed 16-bit integer

1

0x0001

9

IEEE-32 bit floating point

3.14

0x4048F5C3

9

IEEE-32 bit floating point

1.0

0x3F800000

Table 17. Data values in the high-volume binary command example
Table 18 shows each data packet returned in response to the commands 1DB0!,1DB1!,
and 1DB2! as a string of bytes, shown in hexadecimal.
The commands, 1DB0!, 1DB1!, and 1DB2 are transmitted to the sensor as 7 bit ASCII
characters with even parity. The SDI-12 address, 0x31 in this example, is returned as an 8 bit
ASCII character, without a parity bit.
Table 18 also shows that it was unnecessary to transmit the command 1DB2!, because all
four data values were already received. Therefore, the sensor returned an empty data packet.
Command

Data Packet

1DB0!

0x31 0x04 0x00 0x03 0xFF 0xFF 0x01 0x00 0xC2 0xAC

1DB1!

0x31 0x08 0x00 0x09 0xC3 0xF5 0x48 0x40 0x00 0x00 0x80 0x3F 0x3B 0x6E

1DB2!

0x31 0x00 0x00 0x00 0x0E 0xFC
Table 18. Data packet examples

2/20/2023 Version 1.4

28

5.3 Concurrency of High-Volume Commands
The high-volume commands are concurrent commands, as described in section 4.4.7,
with section 4.4.7.1 explaining how to abort a concurrent measurement command.
5.4 Compliance with High-Volume Commands
To claim compliance with version 1.4, SDI-12 data recorders must support the
high-volume commands.
No requirement is imposed on SDI-12 sensors to support the high-volume commands.
The functionality of an SDI-12 sensor dictates the need to support the high-volume commands,
because there is no advantage in collecting a low number of parameters from a sensor with a
high-volume command.
Version 1.4 sensors that do not support the high-volume ASCII command, or the
high-volume binary command, should respond with a000000<CR><LF> saying that it has zero
data values ready.
6.0 METADATA COMMANDS
The metadata commands, introduced in version 1.4 of the SDI-12 Specification, provide
a means to get the response to a command without actually initiating a measurement.
6.1 Identify Measurement Commands
The identify measurement commands are formed by placing the capital letter I into the
measurement commands immediately after the address. The response is identical to having
issued the command without the capital letter I following the address. The format is
atttn<CR><LF>, atttnn<CR><LF>, or atttnnn<CR><LF> depending on the measurement
command.
The continuous measurement commands (aR0! … aR9! And aRC0! … aRC9!) provide their data
instantly and therefore do not have an identify measurement command.
Command

Response

aIM!

atttn<CR><LF>

aIMC!

atttn<CR><LF>

aIM1!
.
.
.
aIM9!

atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aIMC1!

atttn<CR><LF>

2/20/2023 Version 1.4

29

Command

Response

.
.
.
aIMC9!

atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>
atttn<CR><LF>

aIV!

atttn<CR><LF>

aIC!

atttnn<CR><LF>

aICC!

atttnn<CR><LF>

aIC1!
.
.
.
aIC9!

atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>

aICC1!
.
.
.
aICC9!

atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>
atttnn<CR><LF>

aIHA!

atttnnn<CR><LF>

aIHB!

atttnnn<CR><LF>

Table 19. The identify measurement commands
6.1.1 Examples of the Identify Measurement Commands
a. One data value will be immediately available after the M command:
8IM!80001<CR><LF>
b. Nine data values will be available 10 seconds after the M command:
8IM!80109<CR><LF>
c. Ninety-nine data values will be available 10 seconds after the C5 command:
8IC5!801099<CR><LF>
6.2 Identify Measurement Parameter Commands
The identify measurement parameter commands provide details about the parameters
returned by a particular command. The form of the command is an expansion of the Identify

2/20/2023 Version 1.4

30

Measurement Commands. An underscore character ("_") plus a three-digit decimal number is
placed immediately before the exclamation point ("!"). The decimal number is the data value of
interest.
The response is a comma separated value (CSV) string with several fields that provide
information about the data value of interest. Two fields are required. Additional fields can be
added by the sensor manufacturer. Fields are expected to contain printable ASCII characters
other than the comma character (“,”) or the semicolon character (“;”) since they are used to
delimit fields.
6.2.1 Field One
The first field contains a concise identification of the parameter, which is the data value
of interest. The recommendation is to use a Standard Hydrometeorological Exchange Format
(SHEF) code.
SHEF codes are published by the National Oceanic and Atmospheric Administration
(NOAA), National Weather Service in the “Standard Hydrometeorological Exchange Format
(SHEF) Code Manual.” This document is available on the Internet at:
http://www.nws.noaa.gov/oh/hrl/shef/indexshef.htm
The SHEF codes are listed in “Appendix G, Physical Element Definitions,” in the NOAA
document.
If an appropriate SHEF code does not exist for the parameter, or if the sensor
manufacturer chooses not to use a SHEF code for the parameter, then field one may contain a
concise identification of the parameter as determined by the sensor manufacturer. The
recommendation, however, is to use a SHEF code when an appropriate SHEF code does exist.
6.2.2 Field Two
Field two contains the units for the parameter. If the parameter is unit-less, the field must
still be present. A single space character is recommended for an empty field to make it easier to
read.
6.2.3 Optional Fields
The sensor manufacturer may provide additional information relevant to the parameter by
adding additional fields. This may be a more descriptive name than found in field one. For
example, it may contain calibration data or dates. If the parameter represents a probe that has a
unique serial number, there may be a field that contains that serial number. The only limit on the
number of additional fields is that the maximum length of the response, through the terminating
semicolon, is 75 characters.
The last field is terminated by a semicolon “;” and then followed by either the
<CR><LF> sequence or a three character CRC followed by the <CR><LF> sequence if the
measurement command was one that returns a CRC.
2/20/2023 Version 1.4

31

If the parameter number, nnn, is invalid for the measurement, then the response shall be:
a<CR><LF> or a<CRC><CR><LF> if a CRC was expected.
To poll the Continuous Measurement commands (aR0! … aR9! and aRC0! … aRC9!) to
identify their measurement parameters, increment sequentially through the parameters until the
response indicates the parameter number, nnn, is invalid for the measurement.
Command

Response

aIM_001!
.
.
.
aIM_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIMC_001!
.
.
.
aIMC_009!

a,field1,field2;<CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIM1_001! … aIM1_009!
.
.
.
aIM9_001! … aIM9_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIMC1_001! … aIMC1_009!
.
.
.
aIMC9_001! … aIMC9_009!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIV_001! … aIV_009!

a,field1,field2;<CR><LF>

aIC_001! … aIC_099!

a,field1,field2;<CR><LF>

aICC_001! … aICC_099!

a,field1,field2; <CRC><CR><LF>

aIC1_001 … aIC1_009!
.
.
.
aIC9_001 … aIC9_009!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aICC1_001! … aICC1_099!
.
.

a,field1,field2;< CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

2/20/2023 Version 1.4

32

Command

Response

.
aICC9_001! … aICC9_099!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIR0_001! … aIR0_099!
.
.
.
aIR9_001! … aIR9_099!

a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>
a,field1,field2;<CR><LF>

aIRC0_001! … aIRC0_099!
.
.
.
aIRC9_001! … aIRC9_099!

a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>
a,field1,field2; <CRC><CR><LF>

aIHA_001! … aIHA_999!

a,field1,field2; <CRC><CR><LF>

aIHB_001! … aIHB_999!

a,field1,field2; <CRC><CR><LF>

Table 20. The identify measurement parameter commands
6.2.4 Examples of the Identify Measurement Parameter Commands
a. Generic example:
0IM!0001!<CR><LF>
0IM_001!0,field1,field2,field3;<CR><LF>
b. Metadata for an M command, showing that the M command takes a precipitation
measurement, using optional field 3 to describe the data value:
0IM!00001<CR><LF>
0IM_001!0,PR,mm,precipitation rate per day;<CR><LF>
c. Metadata CC command, showing that the CC command takes an average air temperature
measurement, using additional/optional fields to provide additional metadata, with a CRC
appended to the response:
0ICC!000502<CR><LF>
0ICC_001!0,CU,degrees C,average air temperature,calibration data,40,1235;@|e<CR><LF>
6.3 Compliance with Metadata Commands
To claim compliance with version 1.4, an SDI-12 sensor must support the metadata
commands. Because there is no requirement for an SDI-12 data recorder to manage or store the
metadata, the transparent mode (section 4.4.13.1) on the data recorder is sufficient support for
these commands. Explicit data recorder support for these commands is not otherwise required.
2/20/2023 Version 1.4

33

7.0 SDI-12 TIMING
Figure 3 shows a timing diagram for an SDI-12 command and its response. The tolerance for all
SDI-12 timing is ± 0.40 milliseconds. The only exception to this is the time between the stop bit
of one character and the start bit of the next character. The maximum time for this is 1.66
milliseconds, with no tolerance.

• A data recorder transmits a break by setting the data line to spacing for at least 12
milliseconds.
• The sensor will not recognize a break condition for a continuous spacing time of less
than 6.5 milliseconds and will always recognize a break when the line is continuously
spacing for more than 12 milliseconds.
• Upon receiving a break, a sensor must detect 8.33 milliseconds of marking on the data
line before it looks for an address.

2/20/2023 Version 1.4

34

• A sensor must wake up from a low-power standby mode and be capable of detecting a
start bit from a valid command within 100 milliseconds after detecting a break.
• After a data recorder transmits the last character of a command, it must relinquish
control of the data line within 7.5 milliseconds following the end of the stop bit.
(Tolerance: +0.40 milliseconds.)
• After receiving the break and the command, the addressed sensor sets the data line to
marking for 8.33 milliseconds and then send the response. (Tolerance: -0.40
milliseconds.) The start bit of the first response byte must start within 15 milliseconds
after the stop bit of the last byte of the command. (Tolerance: +0.40 milliseconds.
• After a sensor transmits the last character of a response, it must relinquish control of
the data line within 7.5 milliseconds. (Tolerance: +0.40 milliseconds.)
• No more than 1.66 milliseconds of marking are allowed between the end of the stop bit
and the start bit (e.g., between characters) on any characters in the command or the
response. (No tolerance.) This permits a response to an M command to be sent within a
380 millisecond window.
• Sensors must return to a low-power standby mode after receiving an invalid address or
after detecting a marking state on the data line for 100 milliseconds. (Tolerance: +0.40
milliseconds.)
• When a recorder addresses a different sensor, or if the data line has been in the
marking state for more than 87 milliseconds, the next command must be preceded by a
break.
Note: The low power standby mode, in addition to being a power consumption state, is a
protocol state and a break is required to leave that state.
7.1 Rules for the Break
The data recorder sends a break when it is necessary to wake a sensor from low-power
standby mode. An SDI-12 sensor is required to return to low-power standby mode after
receiving an invalid address or after detecting a marking state on the data line for 100
milliseconds. For this reason, a break must precede a command whenever a new sensor is
addressed and after 87 milliseconds of marking on the data line.
When a data recorder receives a service request, it does not have to send a break if it
issues the D0 command within 87 milliseconds after the service request. If, however, more than
87 milliseconds elapse, the D0 command must be preceded with a break.

2/20/2023 Version 1.4

35

7.2 Retries
A data recorder must support retries. Sensors have up to 100 milliseconds to wake up
after detecting a break and will not respond to any commands until they have awakened. Also,
sensors will go to sleep after detecting 100 milliseconds of idle time (marking) on the SDI-12
bus.
When issuing retries, if no response is received from a sensor, the recorder must wait for
at least 16.67 milliseconds after the last stop bit of the command, but no longer than 87
milliseconds, and then issue a retry (without a break). (This period of 87 milliseconds includes
the 16.67 milliseconds spent waiting for a response from the sensor.) If a correct response is not
received after re-transmitting the command at least two more times, with at least one of those
retries more than 100 milliseconds after the end of the break, the entire sequence (including
the break and the retries) should be repeated at least two more times. The flow chart in appendix
B of this document illustrates this retry logic. At least one of the retries must be issued after 100
milliseconds after the falling edge of the break to ensure that the sensor has been given the full
100 milliseconds to wake up after the break. A retry is needed if one of the following three
conditions exist:
1) no response from the sensor;
2) 8.33 milliseconds of marking on the data line, after receiving the start bit of the
response;
3) an invalid response.
Invalid responses include responses in an incorrect format, parity errors, framing errors,
CRC errors, or bus contentions. The data recorder must wait for the response to complete before
sending a retry. If one of the above conditions exists, the data recorder will issue retries. Under
extraordinary conditions, not as normal operating procedure, the data recorder has the option of
not issuing retries.

2/20/2023 Version 1.4

36

APPENDICES

2/20/2023 Version 1.4

37

Appendix A
Suggested SDI-12 Circuits

s
e
ns
orordat
ar
e
c
or
de
r
i
nt
e
r
f
ac
ec
i
r
c
ui
t
wi
t
h
t
r
ans
i
e
ntpr
ot
e
c
t
i
on

2/20/2023

Version 1.4

Appendix B
Suggested SDI-12 Flow Control
for
SDI-12 Data Recorders and Sensors

2/20/2023 Version 1.4

B-1

start

SDI-12 Sensor
Flow Chart

!

!

2/20/2023 Version 1.4

Page B-2

Appendix C
SDI-12 Glossary

2/20/2023 Version 1.4

B-3

Appendix C: SDI-12 Glossary

Address. A single character used to identify each sensor on the SDI-12 bus. The first character
of every command and the first character of every response is an address. The normal address
characters are "0" to "9."
Basic command set. The following SDI-12 commands: a!, aAb!, ?!, aI!, aM!, aM1! . . . aM9!,
aC!, aC1! . . . aC9!, aD0! . . . aD9!, aR0! . . . aR9!, aV!, aMC!, aMC1! . . . aMC9!, aCC!, aCC1!
.. . .aCC9!, aRC0! . . . aRC9!
Break. Continuous spacing, by the data recorder, on the data line for at least 12 milliseconds.
This is a special condition used to wake sensors from a low power standby mode.
Buffer. Memory in the sensor that holds the sensor's most recent measurement. A sensor is
required to keep this information until it receives a new M or V command. When a sensor has a
measurement in its buffer, repeated D commands cause it to return the same data each time the D
command is issued. If, however, a break occurs while a sensor is making a measurement in
response to an M or V command, the sensor must abort its measurement and empty its data
buffer. In this case, no data is returned in response to a D command.
Byte frame format. The manner in which a character is encoded for serial transmission. SDI-12
uses 1 start bit, 7 data bits, even parity, and 1 stop bit.
CRC. Cyclical redundancy check, a form of error checking. The sensor appends a number,
which is encoded as ASCII characters, that is related mathematically to the characters to be
transmitted to the data recorder. Upon receiving the data, the data recorder recomputed the CRC
value to verify that the data was received without error.
Data bits. The bits in a character that carry information, as opposed to the start bit, the parity bit,
and the stop bit. SDI-12 uses 7 data bits.
Extended command. A command not in the basic SDI-12 command set. Extended commands
are defined by the manufacturer of the sensor. Extended commands calibrate sensors, run
diagnostic tests in sensors, and perform other tasks specific to a sensor.
Even parity. Setting the parity bit to 0 or 1, as needed, to ensure that the total number of binary
ones in the data bits and the parity bit are an even number. SDI-12 uses even, as opposed to odd,
parity.
Marking. A binary state of 1 on the SDI-12 data line, with a voltage range of -0.5 to 1.0 volts.
Parity bit. A bit after the data bits in a character, used for error detection. SDI-12 uses even
parity.

2/20/2022 Version 1.4

C-1

Printable characters. ASCII characters in the range 20 hex (a space) through 7E hex (~).
SDI-12 command. A string with 2 or more printable characters that will be sent to an SDI-12
sensor. The first character of an SDI-12 command is an address and the last character is an
exclamation point (!).
SDI-12 bus. A cable with three conductors: (1) serial data, (2) ground, and (3) 12 volts--used to
connect an SDI-12 data recorder with one to ten SDI-12 sensors.
SDI-12 data recorder. A data acquisition device that can be interfaced with one or more SDI-12
sensors. The recorder polls the sensor using the SDI-12 electrical interface and the SDI-12
communications protocol.
SDI-12 response. A string with 3 or more characters, returned to an SDI-12 data recorder by an
SDI-12 sensor. The first character of an SDI-12 response is an address and the last two
characters are a carriage return/line feed (<CR><LF>). Other than the carriage return/line feed,
all characters must be printable ASCII characters.
SDI-12 sensor. A measurement device that can be polled by an SDI-12 data recorder, using the
SDI-12 electrical interface and the SDI-12 communications protocol.
Service request. An address followed by carriage return/line feed (a<CR><LF). This is issued
by a sensor, after an M or V command, to tell the data recorder that the requested measurements
are ready.
Spacing. A binary state of 0 on the SDI-12 data line, with a voltage range of 3.5 to 5.5 volts.
Start bit. A bit indicating the start of a new character in an SDI-12 command or response.
Stop bit. A bit indicating the end of a character in an SDI-12 command or response. SDI-12
specifies one stop bit.
Transparent mode. A mode in an SDI-12 data recorder in which extended commands (or basic
commands), received from a computer, a terminal, or a modem can be sent to a sensor. In
transparent mode the data recorder buffers characters until terminated, wakes the sensor with a
break, and sends the command string to the sensor. An example of transparent mode is a data
recorder interfaced to a PC via a serial port. The user enters SDI-12 commands on the keyboard,
and the command is transmitted to the data recorder. The recorder reads the command, transmits
it to the sensor, and returns the response to the PC. The PC then displays the response.

2/20/2022 Version 1.4

C-2

<values> A string of one or more data values (e.g. measurements) returned from a sensor in
response to a D or an R command; each data value is in this format:
pd.d
where:
p - the polarity sign (+ or -) (required)
d - numeric digits before the decimal point
. - the decimal point (optional)
d - numeric digits after the decimal point
the maximum number of digits for a data value is 7, even without a decimal point
the minimum number of digits for a data value (excluding the decimal point) is 1
the maximum number of characters in a data value is 9 (polarity sign + 7 digits +
the decimal point)

2/20/2022 Version 1.4

C-3

Appendix D
Revisions

Appendix D: Revisions
Version 1.4 February 20, 2023
Added section 4.4.13.1, Extended Commands Returning Multiple Lines of Text.
Changed all instances of “high volume” to “high-volume.”
SDI-12 remains at Version 1.4 because the specification was not changed.
Version 1.4 January 30, 2021
Added two clarifications without changing the specification.
Paragraph 7.2, Retries, was modified by deleting two sentences and removing the word
master from this document. The use of the word master, and the two deleted sentences are
unneeded in describing retries. The word master was removed to join others in the digital design,
software, and information technology industries, eliminating the words master, slave, or both.
Modified the sensor flow chart in Appendix B-2, by making it clear what a sensor is
expected to do when it receives another command while in the processing of a concurrent
measurement. This was done by adding the decision, D command and processing done, when
executing the logic to manage a C command. Also added a title to the sensor flow chart.
Version 1.4 January 10, 2018
No changes or clarifications made to the specification. Added a sentence to Table 5, The
SDI-12 basic command/response set, on page 8: “See Tables 12 and 13 for the high-volume
commands (pages 24-25), Table 19 for the identify measurement commands (page 29), and
Table 20 for the identify measurement parameter commands (page 32),” so that references to all
SDI-12 commands are included on page 8.
Version 1.4 December 1, 2017
No changes or clarifications made to the specification. Made internal formatting changes
only, adding bookmarks for Portable Document File (PDF) readers to quickly see and go to
specific sections.
Version 1.4 May 1, 2017
Clarifications only made to the specification:
1) Page 10, Table 7, the send identification command, had numerous typographic errors
and omissions, introduced when this document was upgraded from version 1.3 to version 1.4.
Restored the content in the table to its original condition, correcting the errors.

2/20/2023 Version 1.4

D-1

2) Page 32, Section 6.2.4, examples of the identify measurement parameter commands:
example (a) and example (c) were missing the letter “I” in the command. Added the letter “I”.
3) Pages 31 and 32, Table 20, the identify measurement parameter commands, column
two was missing <CRC> for the measurement commands that return a CRC. It said:
a,field1,field2;<CR><LF>
rather than:
a,field1,field2;<CRC><CR><LF>
Added <CRC> for all of the measurement commands that return a CRC.
4) Page 28, Section 5.4, Compliance with High-Volume Command, omitted stating what
the required response is, to the aHA! and aHB! commands, for sensors that do not support the
high-volume commands. Added the following paragraph to correct this omission, as the same
requirement is imposed on the other measurement commands.
“Version 1.4 sensors that do not support the high-volume ASCII command, or the
high-volume binary command, should respond with a000000<CR><LF> saying that it has zero
data values ready.”
5) Appendix A-1, Suggested SDI-12 Circuits, had the same label for both circuits.
Restored the label for the bottom circuit to:
“sensor or data recorder interface circuit with transient protection”
Version 1.4 August 15, 2016
Corrected an error: Page 27, Table 17, Rows 1 and 2, Column 2, incorrectly said
“Signed-32 bit integer,” rather than “Signed-16 bit integer.”
Version 1.4 July 14, 2016
Added Sections:
5.0 High-volume Commands
6.0 Metadata Commands
This adds the High-volume ASCII Command, the High-volume Binary Command,
extends the use of the D commands to get up to 999 data values, adds binary data packets in
response to the High-volume Binary Command, adds the Identify Measurement Commands, and
the Identify Measurement Parameter Commands.

2/20/2023 Version 1.4

D-2

Renumbered section 5.0 SDI-Timing to 7.0 SDI-12 Timing.
Updated the table of contents to include the additions.
Other modifications, as needed, to include text about the High-volume Commands and
the Metadata Commands, throughout the document.
Numerous clarifications in response to a full review by the SDI-12 Support Group’s
Technical Committee: some rewording, moved (without changing) some sentences and
paragraphs, corrected some typo-graphical errors, and corrected some minor formatting issues.
Version 1.3 January 28, 2016
Clarifications only made to the specification:
1) Page 26, Section 5.2. Added “CRC error” to the first sentence of the last paragraph as
one of five invalid response conditions, from a sensor, that require a data recorder retry.
2) Page 26, Section 5.2. Deleted the word three in the sentence, “If one of the above three
conditions exists the data recorder will issue retries.”
3) Appendix B-2, SDI-12 Sensor Flow Chart. Added “set data line to marking for 8.33
ms” to the box between “valid command?” and “more processing?” This clarifies the
supporting text on page 24, Section 5.0, which says, “After receiving the break and the
command, the addressed sensor sets the data line to marking for 8.33 milliseconds and then
sends the response.”
4) Appendices B-1 and B-2, SDI-12 Data Recorder Flow Chart/SDI-12 Sensor Flow
Chart. Changed all instances of “msec” to the correct abbreviation of “ms.”
Version 1.3 January 26, 2013
Clarifications only made to the specification:
1) Page 1, Section 1.0. Added “see section 3.0 for details” to the third bullet.
2) Page 1, Section 1.0. Deleted the fourth bullet, “Up to 200 feet of cable between a
sensor and data recorder.”
3) Page 11, Table 9. Made a correction. Changed “a valid range of 0 to 9" to “a valid
range of 1 to 9" in row 3, column 2.
4) Page 14, Table 10. Deleted this text, “(a data recorder must be able to read and store at
least 20 parameters from a sensor, nn = 20)”

2/20/2023 Version 1.4

D-3

5) Page 14, Section 4.4.7. Deleted this text, “The maximum number of data values a
sensor can return for nn is 20. A data recorder is also required to store 20 values. Future versions
of SDI-12 may increase this to a maximum of up to 99 values.”
6) Page 14, Section 4.4.7. Added this text, “The data recorder should document the
number of data values it can store in response to a C command.”
7) Page 14, Section 4.4.7. Changed the last paragraph from:
See the send data command, aD0!, aD1! . . . Ad9! for examples of this command. Because the
start concurrent measurement command is closely related to the send data command, examples
for both commands are in sections 4.4.8.3 and 4.4.8.4.
To:
“See the send data command, aD0!, aD1! . . . aD9!, section 4.4.8, for the data response
requirements. Because the start concurrent measurement command is closely related to the send
data command, examples for both commands are in sections 4.4.8.3 and 4.4.8.4.”
8) Page 14, Section 4.4.8. Change the paragraph heading from “aD0! ... aD9!” to “aD0!,
...aD1 ... aD9!.”
Version 1.3

January 3, 2012

Clarifications only made to the specification:
1) Page 5, Section 4.0. Reference to page 14 changed to reference to section 4.4.7.
2) Page 12, Section 4.4.5.1. Deleted the sentence, “It must also empty its buffer so that no
data are returned in response to a D command.” This sentence was deleted because the sentence
after it specifically states what information is to be returned to the sensor in response to
subsequent D commands.
3) Page 14, Section 4.4.7.1. Deleted the sentence, “It must also empty is buffer so that no
data are returned in response to a D command.” This sentence was deleted because the sentence
after it specifically states what information is to be returned to the sensor in response to
subsequent D commands.
4) Page 16, Section 4.4.8.3. Reference to section 4.4 changed to section 4.4.8.
5) Page 16, Section 4.4.8.3. Circular reference to section 4.4.8.3 changed to section
4.4.8.4.
6) Page 23, Section 4.4.13. Corrected typographical error. Deleted the letter s from

2/20/2023 Version 1.4

D-4

“extendeds.”
7) Formatted all paragraph headings in bold.
8) Changed Appendix B, Suggested SDI-12 Flow Control for SDI-12 Data Recorded so
that the logic for the concurrent command matches the text in the body of the document:
a) top left rectangle: deleted the text “in its buffer”
b) top left oval: changed “making” to “marking.”
c) bottom left rectangle: deleted the phrase “empty buffer so”
d) bottom right rectangle: changed the text so that it matches the text in the bottom left
rectangle
e) the “yes” branch of the “C command” decision now goes to the oval “look for address,
break, or 100 msec timeout while processing the command,” rather than the oval “look
for break while processing the command”
f) the “no” branch of “valid command” in the C command processing section now goes to
the oval “look for address, break, or 100 msec timeout while processing the command,”
rather than the oval “look for break while processing the command” oval
g) switched the positions of the two columns of logic for the C command logic to
minimize the crossing of lines
Version 1.3

January 12, 2009

Clarifications only made to the specification:
1) Page 2, Section 3.0. Appended a phrase and a sentence: “, each with 200 feet of cable.
With fewer sensors, longer cable lengths are possible.”
2) Page 4, Section 3.12. Added a sentence: “Due to this impedance, the maximum cable
length depends on the capacitance of all cables connected to the SDI-12 data line.”
3) Page 12, Section 4.4.5. Added a sentence: “The data recorder may wait for the entire
ttt time. Therefore, the tolerance above the measurement time, added to ttt, should be minimal
Version 1.3

July 18, 2005

Clarifications only made to the specification:
1) Page 7, Section 4.4. Added a sentence: “None of the basic commands should affect the
sensor’s calibration.”
2) Page 12, Section 4.4.5.1. Added “or this sensor,” to the sentence at the bottom of the
page.
3) Page 16. Corrected a typographical error.

2/20/2023 Version 1.4

D-5

Version 1.3

July 25, 2004

Clarifications only made to the specification:
1) Page 8, Table 5. Changed “same as the D commands” to “formatted like the D
commands.”
2) Page 16. Changed “The R commands (R0! ... R9!) work exactly like the D commands
(D0! ... D9!).” to “The response to R commands (R0! ... R9!) are formatted like the D commands
(D0! ... D9!).”
3) Page 16. Changed “The only difference is that the R commands do not need to be
preceded with an M command ...” to “The main difference is that the R commands do not need
to be precede with an M command ...”
4) Page 16. Added a new paragraph:
Each R command is an independent measurement. For example, R5 need not be preceded
by R0 ... R4.
5) Page 16. Changed “If a CRC was requested then a CRC must be appended to the
address.” to “If a CRC was requested then the <CR><LF> must be preceded by the CRC.”
6) Page 20. Changed “When these commands are used, the data returned in response to
the D commands must have a CRC code appended to it.” to “When these commands are used,
the data returned in response to the D commands, or R commands, must have a CRC code
appended to it.”
Version 1.3

September 17, 2002

Clarifications only made to the specification:
1) Page 8. Corrected the footnote at the bottom of Table 5 to reference section 4.4.6
rather than section 4.4.12. Section 4.4.6 is the correct section that footnote should reference.
2) Page 9. Added “The “!” character can only be used in a command as the terminator
character.”
3) Page 9. Corrected typographical error; changed “of” to “or.”
4) Page 11, table 9. Added “n is a single digit integer with a valid range of 0 to 9.”
5) Page 12 and Page 14. Added “(or followed by <CRC><CR><LF> if a CRC was
requested).”

2/20/2023 Version 1.4

D-6

6) Page 13. Changed: “A service request is issued by the sensor, after an M or V
command, when it has finished its measurement.” To: “A service request is issued by the
sensor, after an M, MC, or V command, when it has finished its measurement.”
7) Page 15, table 11, Added “the minimum number of digits for a data value (excluding
the decimal point) is 1.”
8) Page 16. Added “If a CRC was requested then a CRC must be appended to the
address. For example: 0AP@<CR><LF>.”
9) Page 20. Added “All shifts shift in a zero.”
10) Page 22. Corrected an error in an example that shows a sensor response with a CRC
value (changed 1.1234 to 1.234). With the additional ‘1' in the data, the CRC value shown in the
example was incorrect.
11) Page 25. Corrected typographical error; changed “sensor” to “data recorder.”
12) Page B-2. Corrected typographical error; changed “emty” to “empty.”
13) Page C-3. Added “the minimum number of digits for a data value (excluding the
decimal point) is 1.”
Version 1.3

April 7, 2000

1) Added a Cyclic Redundancy Check (CRC) to data returned from SDI-12 Sensors, by
the use of existing commands with a C appended, namely: aMC!, aMC1! ... aMC9!, aCC1! ...
aCC9!, and aRC0! ... aRC9!.
2) Changed the Data Line “OFF” impedance to be less restrictive (160K to 360K ohms,
rather than 200K ohms with a plus or minus 10% tolerance.
3) Reworded the paragraph about inductive loading.
4) Clarified the definition of low power standby mode.
Version 1.2

October 21, 1996

Clarifications only made to the specification:
1) Page 2. Added the following statement, which was in Version 1.0, but omitted from
Versions 1.1 and 1.2 (4/12/96) by mistake.
"In the following specifications, all values not indicating specific limits, have an
allowable tolerance of ±10% of the value."

2/20/2023 Version 1.4

D-7

2) Page 12. Added text to clarify when ttt seconds begins and added text to advise sensor
designers to return a ttt value that is greater than the time it takes the sensor to take a
measurement.
"The ttt time period begins upon completion of the transmission of the line feed
character."
"A sensor should return a ttt value greater than the time it takes to make a measurement,
to allow for timing tolerances and for the service request. (See section 4.4.6.)"
3) Page 14. Added text to clarify when ttt seconds begins.
"The ttt time period begins immediately after the sensor transmits the <LF> character."
Version 1.2

April 12, 1996

1) Added the concurrent measurement command (aC!) and the additional concurrent
measurement commands (aC1! . . . aC9!) to the basic command set.
2) Clarified the section on data recorder retries to indicate that a data recorder must issue
retries unless it has received a valid response or if it wishes to abort the measurement.
3) Clarified the no data response to the additional measurement commands (aM! . . .
aM9!)
4) Added the address query command (?!) to the basic command set.
5) Added the change address command (aAb!) to the basic command set.
6) Added the continuous measurement command (aR0! . . . aR9!) to the command set.
Version 1.1

July 7, 1994

Rewrite and clarification of the original specification. No technical changes.
Version 1.0

October 1988

Original release.

2/20/2023 Version 1.4

D-8



=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/address.rs
=======================
// src/common/address.rs

use super::error::Sdi12Error;
use core::convert::TryFrom;
use core::fmt;

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
pub struct Sdi12Addr(char);

impl Sdi12Addr {
    pub const DEFAULT_ADDRESS: Sdi12Addr = Sdi12Addr('0');
    pub const QUERY_ADDRESS: Sdi12Addr = Sdi12Addr('?');

    /// Creates a new `Sdi12Addr` if the given character is a valid address.
    /// Returns `Result<Self, Sdi12Error<()>>` because validation itself
    /// cannot cause an I/O error.
    pub fn new(address_char: char) -> Result<Self, Sdi12Error<()>> {
        if Self::is_valid_address_char(address_char) || address_char == '?' {
            Ok(Sdi12Addr(address_char))
        } else {
            // Directly create the specific error variant with E = ()
            Err(Sdi12Error::InvalidAddress(address_char))
        }
    }

    // Unsafe constructor remains the same
    pub const unsafe fn new_unchecked(address_char: char) -> Self {
        Sdi12Addr(address_char)
    }

    #[inline]
    pub const fn as_char(&self) -> char {
        self.0
    }

    #[inline]
    pub const fn is_query(&self) -> bool {
        self.0 == '?'
    }

    #[inline]
    pub const fn is_standard(&self) -> bool {
        // This one was okay because '0'..='9' is a single range pattern
        matches!(self.0, '0'..='9')
    }

    #[inline]
    pub const fn is_extended(&self) -> bool {
        // CORRECTED: Use '|' directly as a pattern separator
        matches!(self.0, 'a'..='z' | 'A'..='Z')
    }

    #[inline]
    pub const fn is_valid_address_char(c: char) -> bool {
        // CORRECTED: Use '|' directly as a pattern separator
        matches!(c, '0'..='9' | 'a'..='z' | 'A'..='Z')
    }
}

impl Default for Sdi12Addr {
    fn default() -> Self {
        Self::DEFAULT_ADDRESS
    }
}

// CORRECTED: Implement TryFrom<char> without the generic E
impl TryFrom<char> for Sdi12Addr {
    // The error type here is specific: Sdi12Error with no I/O error possibility
    type Error = Sdi12Error<()>;

    /// Attempts to convert a character into an `Sdi12Addr`.
    fn try_from(value: char) -> Result<Self, Self::Error> {
        // Reuse the validation logic from Self::new()
        // Since Self::new() now returns Result<_, Sdi12Error<()>>, this works directly.
        Self::new(value)
        // Or, implement directly:
        // if Sdi12Addr::is_valid_address_char(value) || value == '?' {
        //     Ok(Sdi12Addr(value))
        // } else {
        //     Err(Sdi12Error::InvalidAddress(value))
        // }
    }
}


impl From<Sdi12Addr> for char {
    fn from(value: Sdi12Addr) -> Self {
        value.0
    }
}

impl fmt::Display for Sdi12Addr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    // Mock error type is no longer strictly needed inside the tests for `new` or `try_from`
    // because they now return `Sdi12Error<()>` which doesn't involve a generic `E`.
    // We might still need it later for testing functions that *do* take an E.
    #[derive(Debug, Clone, PartialEq, Eq)]
    struct MockIoError;
    impl fmt::Display for MockIoError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "Mock I/O Error") }
    }

    #[test]
    fn test_valid_addresses() {
        assert!(Sdi12Addr::new('0').is_ok());
        assert!(Sdi12Addr::new('5').is_ok());
        assert!(Sdi12Addr::new('9').is_ok());
        assert!(Sdi12Addr::new('a').is_ok());
        assert!(Sdi12Addr::new('z').is_ok());
        assert!(Sdi12Addr::new('A').is_ok());
        assert!(Sdi12Addr::new('Z').is_ok());
        assert!(Sdi12Addr::new('?').is_ok());
    }

    #[test]
    fn test_invalid_addresses() {
        assert!(matches!(Sdi12Addr::new(' '), Err(Sdi12Error::InvalidAddress(' '))));
        assert!(matches!(Sdi12Addr::new('$'), Err(Sdi12Error::InvalidAddress('$'))));
        assert!(matches!(Sdi12Addr::new('\n'), Err(Sdi12Error::InvalidAddress('\n'))));
        assert!(matches!(Sdi12Addr::new('é'), Err(Sdi12Error::InvalidAddress('é'))));
    }

    // test_default_address, test_query_address, test_address_types remain the same

    #[test]
    fn test_try_from_char() {
        assert_eq!(Sdi12Addr::try_from('1').unwrap(), Sdi12Addr('1'));
        assert_eq!(Sdi12Addr::try_from('b').unwrap(), Sdi12Addr('b'));
        assert_eq!(Sdi12Addr::try_from('C').unwrap(), Sdi12Addr('C'));
        assert_eq!(Sdi12Addr::try_from('?').unwrap(), Sdi12Addr('?'));
        assert!(matches!(Sdi12Addr::try_from('*'), Err(Sdi12Error::InvalidAddress('*'))));
    }

    // test_into_char, test_display, test_as_char, test_is_valid_address_char, test_new_unchecked remain the same
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/command.rs
=======================
//! SDI-12 command definitions.
//!
//! See SDI-12 Specification v1.4, Section 5.7 "Command Set".

use core::fmt;

use super::{address::Sdi12Addr, Sdi12Error};

/// Represents an SDI-12 command.
///
/// Note: The `Display` implementation for this enum generates the standard SDI-12 command string
/// format (e.g., `aM!`, `aD0!`, `aAn!`). Extended commands require separate handling for formatting.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Command {
    /// Acknowledge Active Command (`a!`) - Causes the addressed sensor to send an acknowledgment.
    AcknowledgeActive { address: Sdi12Addr },

    /// Change Address Command (`aAn!`) - Changes the sensor's address from `a` to `n`.
    ChangeAddress { address: Sdi12Addr, new_address: Sdi12Addr },

    /// Start Measurement Command (`aM!` or `aM1!`..`aM9!`) - Initiates a measurement sequence.
    /// `None` corresponds to `aM!`. `Some(i)` corresponds to `aMi!` (1 <= i <= 9).
    StartMeasurement { address: Sdi12Addr, measurement_index: Option<u8> },

    /// Start Concurrent Measurement Command (`aMC!` or `aMC1!`..`aMC9!`) - Initiates a concurrent measurement.
    /// `None` corresponds to `aMC!`. `Some(i)` corresponds to `aMCi!` (1 <= i <= 9).
    StartConcurrentMeasurement { address: Sdi12Addr, measurement_index: Option<u8> },

    /// Start Verification Command (`aV!`) - Initiates a verification sequence.
    StartVerification { address: Sdi12Addr },

    /// Send Data Command (`aD0!`..`aD9!`) - Requests data from a completed measurement.
    SendData { address: Sdi12Addr, data_index: u8 }, // Index 0-9

    /// Continuous Measurement Command (`aR0!`..`aR9!`) - Initiates continuous measurements.
    ContinuousMeasurement { address: Sdi12Addr, measurement_index: u8 }, // Index 0-9

    /// Identify Sensor Command (`aI!`) - Requests sensor identification information.
    IdentifySensor { address: Sdi12Addr },

    /// Represents an Extended Command (`aX...`).
    /// The specific format depends on the manufacturer and command.
    /// Formatting these requires custom logic.
    Extended(ExtendedCommand),
    // TODO: Potentially define common extended commands? (e.g., HUM?)
}

/// Represents the payload of an extended SDI-12 command.
/// SDI-12 spec does not define a universal format for these.
/// For now, it just holds the raw command bytes/string after the address.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ExtendedCommand {
    /// The sensor address the command is directed to.
    pub address: Sdi12Addr,
    /// The command string *excluding* the initial address but *including* the final '!'.
    /// Example: For `0XHUM!`, `payload` would be `"XHUM!"`.
    // Using a simple array; adjust size if longer extended commands are common/needed.
    // Consider `heapless::String` if `alloc` feature is enabled and variable length is desired.
    pub payload: [u8; 16], // Max length TBD - adjust as needed
    pub len: usize,        // Actual length of payload used
                           // Consider adding specific known extended commands as variants later
}

impl fmt::Display for Command {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Command::AcknowledgeActive { address } => write!(f, "{}!", address),
            Command::ChangeAddress { address, new_address } => {
                // Spec Sec 5.7.5: aAn!
                write!(f, "{}A{}!", address, new_address)
            }
            Command::StartMeasurement { address, measurement_index } => {
                // Spec Sec 5.7.1: aM! or aM1!..aM9!
                match measurement_index {
                    None => write!(f, "{}M!", address),
                    Some(idx) => {
                        if *idx > 0 && *idx <= 9 {
                            write!(f, "{}M{}!", address, idx)
                        } else {
                            // Invalid index according to spec for aMx!
                            Err(fmt::Error)
                        }
                    }
                }
            }
            Command::StartConcurrentMeasurement { address, measurement_index } => {
                // Spec Sec 5.7.1: aMC! or aMC1!..aMC9!
                 match measurement_index {
                    None => write!(f, "{}MC!", address),
                    Some(idx) => {
                        if *idx > 0 && *idx <= 9 {
                            write!(f, "{}MC{}!", address, idx)
                        } else {
                            // Invalid index according to spec for aMCx!
                            Err(fmt::Error)
                        }
                    }
                }
            }
            Command::StartVerification { address } => {
                // Spec Sec 5.7.2: aV!
                write!(f, "{}V!", address)
            }
            Command::SendData { address, data_index } => {
                // Spec Sec 5.7.3: aD0!..aD9!
                // Ensure index is 0-9
                if *data_index <= 9 {
                    write!(f, "{}D{}!", address, data_index)
                } else {
                     Err(fmt::Error)
                }
            }
            Command::ContinuousMeasurement { address, measurement_index } => {
                // Spec Sec 5.7.4: aR0!..aR9!
                // Ensure index is 0-9
                if *measurement_index <= 9 {
                    write!(f, "{}R{}!", address, measurement_index)
                } else {
                     Err(fmt::Error)
                }
            }
            Command::IdentifySensor { address } => {
                // Spec Sec 5.7.6: aI!
                write!(f, "{}I!", address)
            }
            // Extended commands need careful formatting based on their specific structure
            Command::Extended(ext_cmd) => {
                 // Format as aX...! where X... is the payload
                write!(f, "{}", ext_cmd.address)?;
                // Write the payload bytes directly
                // Using write_str assumes valid UTF-8, which might not be true for all extended commands.
                // If payload can contain non-UTF8, write bytes individually or use a different approach.
                if let Ok(payload_str) = core::str::from_utf8(&ext_cmd.payload[..ext_cmd.len]) {
                    f.write_str(payload_str)
                } else {
                    // Handle non-UTF8 payload - maybe error? Or try lossy conversion?
                    Err(fmt::Error) // Simplest safe option for now
                }
            }
        }
    }
}


impl Command {
    /// Returns the address the command is directed to.
    pub fn address(&self) -> Sdi12Addr {
        match self {
            Command::AcknowledgeActive { address } => *address,
            Command::ChangeAddress { address, .. } => *address,
            Command::StartMeasurement { address, .. } => *address,
            Command::StartConcurrentMeasurement { address, .. } => *address,
            Command::StartVerification { address } => *address,
            Command::SendData { address, .. } => *address,
            Command::ContinuousMeasurement { address, .. } => *address,
            Command::IdentifySensor { address } => *address,
            Command::Extended(ext_cmd) => ext_cmd.address,
        }
    }

    /// Checks if a response is expected for this command according to the SDI-12 spec.
    /// Note: This doesn't account for service requests.
    pub fn requires_response(&self) -> bool {
        match self {
            // Commands that primarily expect a response (acknowledgement, data, info)
            Command::AcknowledgeActive { .. } => true,
            Command::StartMeasurement { .. } => true,      // Expects service request or ack+timing
            Command::StartConcurrentMeasurement { .. } => true, // Expects ack+timing
            Command::StartVerification { .. } => true,      // Expects ack+timing
            Command::SendData { .. } => true,               // Expects data or ack
            Command::IdentifySensor { .. } => true,         // Expects identification string
            // Commands that change state but might have a response
            Command::ChangeAddress { .. } => true, // Expects the new address as acknowledgment
            // Commands related to continuous measurements might or might not have immediate actionable responses
            // other than the data stream itself, which isn't a typical command-response pair.
            // R commands usually just get an ack+timing, then data streams.
            Command::ContinuousMeasurement { .. } => true, // Expects ack+timing
            // Extended commands are manufacturer-specific; assume they might require a response.
            Command::Extended(_) => true, // Safer to assume yes
        }
    }

    // Helper to create extended commands (example)
    // You might want more specific constructors for known extended commands.
    pub fn new_extended<E: core::fmt::Debug>(
        address: Sdi12Addr,
        payload_str: &str,
    ) -> Result<Self, Sdi12Error<E>> {
        if !payload_str.ends_with('!') {
            return Err(Sdi12Error::CommandFormat("Extended command payload must end with '!'"));
        }
        if payload_str.len() > 16 { // Matches array size
             return Err(Sdi12Error::CommandFormat("Extended command payload too long"));
        }
        let mut payload = [0u8; 16];
        payload[..payload_str.len()].copy_from_slice(payload_str.as_bytes());
        Ok(Command::Extended(ExtendedCommand {
            address,
            payload,
            len: payload_str.len(),
        }))
    }
}

// Placeholder for potential ExtendedCommand specific methods if needed later
impl ExtendedCommand {
    // pub fn command_code(&self) -> Option<&str> { ... }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::address::Sdi12Addr; // Make sure Addr is imported
    // Need a Write implementation for testing formatting errors
    use heapless::String as HeaplessString;
    use core::fmt::Write; // Import the Write trait

    // Helper for creating commands in tests
    fn addr(c: char) -> Sdi12Addr {
        Sdi12Addr::new(c).unwrap()
    }

    #[test]
    fn test_command_formatting() {
        assert_eq!(
            Command::AcknowledgeActive { address: addr('1') }.to_string(),
            "1!"
        );
        assert_eq!(
            Command::ChangeAddress { address: addr('1'), new_address: addr('2') }.to_string(),
            "1A2!"
        );
        assert_eq!(
            Command::StartMeasurement { address: addr('1'), measurement_index: None }.to_string(),
            "1M!"
        );
        assert_eq!(
            Command::StartMeasurement { address: addr('1'), measurement_index: Some(3) }.to_string(),
            "1M3!"
        );
        assert_eq!(
            Command::StartConcurrentMeasurement { address: addr('1'), measurement_index: None }.to_string(),
            "1MC!"
        );
         assert_eq!(
            Command::StartConcurrentMeasurement { address: addr('1'), measurement_index: Some(9) }.to_string(),
            "1MC9!"
        );
        assert_eq!(
            Command::StartVerification { address: addr('1') }.to_string(),
            "1V!"
        );
        assert_eq!(
            Command::SendData { address: addr('1'), data_index: 0 }.to_string(),
            "1D0!"
        );
        assert_eq!(
            Command::SendData { address: addr('1'), data_index: 9 }.to_string(),
            "1D9!"
        );
        assert_eq!(
            Command::ContinuousMeasurement { address: addr('1'), measurement_index: 0 }.to_string(),
             "1R0!"
        );
         assert_eq!(
            Command::ContinuousMeasurement { address: addr('1'), measurement_index: 5 }.to_string(),
             "1R5!"
        );
        assert_eq!(
            Command::IdentifySensor { address: addr('1') }.to_string(),
            "1I!"
        );

        // Test extended command formatting
        let ext_cmd = Command::new_extended::<()>(addr('0'), "XTEST!").unwrap();
         assert_eq!(ext_cmd.to_string(), "0XTEST!");

        let ext_cmd_long = Command::new_extended::<()>(addr('Z'), "LONGPAYLOAD1234!").unwrap();
        assert_eq!(ext_cmd_long.to_string(), "ZLONGPAYLOAD1234!");
    }

    #[test]
    fn test_invalid_measurement_index_format() {
         // Index 0 is invalid for aMx! / aMCx!
         let cmd_m0 = Command::StartMeasurement { address: addr('1'), measurement_index: Some(0) };
         // fmt::Display returns Err(fmt::Error), .to_string() yields empty
         // Using write! macro directly to check the Result
         let mut output = HeaplessString::<8>::new(); // Need a Write impl
         assert!(write!(output, "{}", cmd_m0).is_err());

         let cmd_mc0 = Command::StartConcurrentMeasurement { address: addr('1'), measurement_index: Some(0) };
         output.clear();
         assert!(write!(output, "{}", cmd_mc0).is_err());


         // Index > 9 is invalid
         let cmd_m10 = Command::StartMeasurement { address: addr('1'), measurement_index: Some(10) };
         output.clear();
          assert!(write!(output, "{}", cmd_m10).is_err());

         let cmd_mc10 = Command::StartConcurrentMeasurement { address: addr('1'), measurement_index: Some(10) };
         output.clear();
          assert!(write!(output, "{}", cmd_mc10).is_err());
    }

     #[test]
    fn test_invalid_data_index_format() {
         // Index > 9 is invalid for aDx!
         let cmd_d10 = Command::SendData { address: addr('1'), data_index: 10 };
         let mut output = HeaplessString::<8>::new();
         assert!(write!(output, "{}", cmd_d10).is_err());
    }

      #[test]
    fn test_invalid_continuous_index_format() {
         // Index > 9 is invalid for aRx!
         let cmd_r10 = Command::ContinuousMeasurement { address: addr('1'), measurement_index: 10 };
         let mut output = HeaplessString::<8>::new();
         assert!(write!(output, "{}", cmd_r10).is_err());
    }

     #[test]
     fn test_extended_command_creation_errors() {
         // Test with CommandFormat variant instead of MockError
         assert!(Command::new_extended::<()>(addr('0'), "XTEST").is_err()); // Missing !
         assert!(Command::new_extended::<()>(addr('0'), "THISPAYLOADISWAYTOOLONGFORARRAY!").is_err()); // Too long
     }
    #[test]
    fn test_address_retrieval() {
        assert_eq!(Command::AcknowledgeActive { address: addr('0') }.address(), addr('0'));
        assert_eq!(Command::ChangeAddress { address: addr('1'), new_address: addr('2') }.address(), addr('1'));
        assert_eq!(Command::StartMeasurement { address: addr('3'), measurement_index: None }.address(), addr('3'));
        assert_eq!(Command::StartConcurrentMeasurement { address: addr('4'), measurement_index: Some(1) }.address(), addr('4'));
        assert_eq!(Command::StartVerification { address: addr('5') }.address(), addr('5'));
        assert_eq!(Command::SendData { address: addr('6'), data_index: 0 }.address(), addr('6'));
        assert_eq!(Command::ContinuousMeasurement { address: addr('7'), measurement_index: 9 }.address(), addr('7'));
        assert_eq!(Command::IdentifySensor { address: addr('8') }.address(), addr('8'));
        let ext_cmd = Command::new_extended::<()>(addr('9'), "XCMD!").unwrap();
        assert_eq!(ext_cmd.address(), addr('9'));
    }

    #[test]
    fn test_requires_response() {
        assert!(Command::AcknowledgeActive { address: addr('0') }.requires_response());
        assert!(Command::ChangeAddress { address: addr('1'), new_address: addr('2') }.requires_response());
        assert!(Command::StartMeasurement { address: addr('3'), measurement_index: None }.requires_response());
        assert!(Command::StartConcurrentMeasurement { address: addr('4'), measurement_index: Some(1) }.requires_response());
        assert!(Command::StartVerification { address: addr('5') }.requires_response());
        assert!(Command::SendData { address: addr('6'), data_index: 0 }.requires_response());
        // Continuous measurements expect an ack+timing initially
        assert!(Command::ContinuousMeasurement { address: addr('7'), measurement_index: 9 }.requires_response());
        assert!(Command::IdentifySensor { address: addr('8') }.requires_response());
        let ext_cmd = Command::new_extended::<()>(addr('9'), "XCMD!").unwrap();
        assert!(ext_cmd.requires_response()); // Assume true for extended
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/crc.rs
=======================
// src/common/crc.rs

use super::error::Sdi12Error;
use crc::{Crc, Algorithm};

/// Custom CRC algorithm matching SDI-12 specification (CRC-16/ARC).
/// Polynomial: 0x8005 (normal representation of 0xA001 reversed)
/// Initial Value: 0x0000
/// Input Reflected: true
/// Output Reflected: true
/// Final XOR: 0x0000
/// Check Value: 0xBB3D (for "123456789") - standard for CRC-16/ARC
/// Residue: 0x0000
pub const SDI12_CRC: Algorithm<u16> = Algorithm {
    poly: 0x8005,
    init: 0x0000,
    refin: true,
    refout: true,
    xorout: 0x0000,
    check: 0xBB3D,
    width: 16,
    residue: 0x0000,
};

// Create a Crc instance for the SDI-12 algorithm for reuse.
const CRC_COMPUTER: Crc<u16> = Crc::<u16>::new(&SDI12_CRC);

/// Calculates the SDI-12 CRC-16 (CRC-16/ARC) for the given data buffer.
///
/// Uses the `crc` crate configured for the standard CRC-16/ARC algorithm,
/// which matches the SDI-12 specification. The calculation starts from the
/// first byte (typically the address) up to the byte *before* the CRC
/// itself or the trailing `<CR><LF>`.
///
/// # Arguments
///
/// * `data`: A slice of bytes for which to calculate the CRC.
///
/// # Returns
///
/// The calculated 16-bit CRC value.
#[inline]
pub fn calculate_crc16(data: &[u8]) -> u16 {
    CRC_COMPUTER.checksum(data)
}

/// Encodes a 16-bit CRC value into three ASCII characters according to SDI-12 standard.
///
/// Follows section 4.4.12.2 of the SDI-12 specification v1.4.
///
/// # Arguments
///
/// * `crc_value`: The 16-bit CRC to encode.
///
/// # Returns
///
/// An array of three `u8` bytes representing the ASCII-encoded CRC.
pub fn encode_crc_ascii(crc_value: u16) -> [u8; 3] {
    let char1 = 0x40 | ((crc_value >> 12) & 0x3F) as u8;
    let char2 = 0x40 | ((crc_value >> 6) & 0x3F) as u8;
    let char3 = 0x40 | (crc_value & 0x3F) as u8;
    [char1, char2, char3]
}

/// Decodes three SDI-12 ASCII-encoded CRC characters back into a 16-bit value.
///
/// # Arguments
///
/// * `crc_chars`: A slice or array of three `u8` bytes representing the ASCII-encoded CRC.
///
/// # Returns
///
/// The decoded 16-bit CRC value.
///
/// # Panics
///
/// Panics if `crc_chars` does not have a length of exactly 3.
pub fn decode_crc_ascii(crc_chars: &[u8]) -> u16 {
    assert_eq!(crc_chars.len(), 3, "ASCII CRC must be 3 bytes long");
    let byte1 = u16::from(crc_chars[0] & 0x3F);
    let byte2 = u16::from(crc_chars[1] & 0x3F);
    let byte3 = u16::from(crc_chars[2] & 0x3F);
    (byte1 << 12) | (byte2 << 6) | byte3
}

/// Verifies an SDI-12 response string that includes an ASCII CRC.
///
/// Assumes the buffer ends with the 3 CRC bytes and does *not* include `<CR><LF>`.
///
/// # Arguments
///
/// * `response_with_crc`: The response buffer including the 3-byte ASCII CRC.
///
/// # Returns
///
/// * `Ok(())` if the CRC is valid.
/// * `Err(Sdi12Error::InvalidFormat)` if the buffer is too short.
/// * `Err(Sdi12Error::CrcMismatch)` if the CRCs don't match.
pub fn verify_response_crc_ascii<E>(response_with_crc: &[u8]) -> Result<(), Sdi12Error<E>>
where
    E: core::fmt::Debug,
{
    if response_with_crc.len() < 3 {
        return Err(Sdi12Error::InvalidFormat);
    }
    let data_len = response_with_crc.len() - 3;
    let data_part = &response_with_crc[..data_len];
    let received_crc_bytes = &response_with_crc[data_len..];

    let calculated_crc = calculate_crc16(data_part);
    let received_crc = decode_crc_ascii(received_crc_bytes);

    if calculated_crc == received_crc {
        Ok(())
    } else {
        Err(Sdi12Error::CrcMismatch { expected: received_crc, calculated: calculated_crc, })
    }
}

/// Encodes a 16-bit CRC value into two bytes (LSB first) for binary responses.
///
/// # Arguments
///
/// * `crc_value`: The 16-bit CRC to encode.
///
/// # Returns
///
/// An array of two `u8` bytes `[LSB, MSB]`.
pub fn encode_crc_binary(crc_value: u16) -> [u8; 2] {
    crc_value.to_le_bytes()
}

/// Decodes two bytes (LSB first) from a binary response into a 16-bit CRC value.
///
/// # Arguments
///
/// * `crc_bytes`: A slice or array of two `u8` bytes `[LSB, MSB]`.
///
/// # Returns
///
/// The decoded 16-bit CRC value.
///
/// # Panics
///
/// Panics if `crc_bytes` does not have a length of exactly 2.
pub fn decode_crc_binary(crc_bytes: &[u8]) -> u16 {
    assert_eq!(crc_bytes.len(), 2, "Binary CRC must be 2 bytes long");
    u16::from_le_bytes([crc_bytes[0], crc_bytes[1]])
}

/// Verifies an SDI-12 high-volume binary response packet including its binary CRC.
///
/// Assumes the buffer ends with the 2 raw CRC bytes.
///
/// # Arguments
///
/// * `packet_with_crc`: The complete binary packet buffer including the 2-byte CRC.
///
/// # Returns
///
/// * `Ok(())` if the CRC is valid.
/// * `Err(Sdi12Error::InvalidFormat)` if the buffer is too short.
/// * `Err(Sdi12Error::CrcMismatch)` if the CRCs don't match.
pub fn verify_packet_crc_binary<E>(packet_with_crc: &[u8]) -> Result<(), Sdi12Error<E>>
where
    E: core::fmt::Debug,
{
    if packet_with_crc.len() < 2 {
        return Err(Sdi12Error::InvalidFormat);
    }
    let data_len = packet_with_crc.len() - 2;
    let data_part = &packet_with_crc[..data_len];
    let received_crc_bytes = &packet_with_crc[data_len..];

    let calculated_crc = calculate_crc16(data_part);
    let received_crc = decode_crc_binary(received_crc_bytes);

    if calculated_crc == received_crc {
        Ok(())
    } else {
        Err(Sdi12Error::CrcMismatch { expected: received_crc, calculated: calculated_crc, })
    }
}

// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    // Mock error type for verify function generic parameter
    #[derive(Debug, Clone, PartialEq, Eq)]
    struct MockIoError;
    impl core::fmt::Display for MockIoError {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result { write!(f, "Mock I/O Error") }
    }

    // --- ASCII CRC Tests Based Directly on Spec v1.4 Section 4.4.12.3 ---

    #[test]
    fn test_spec_example_a() {
        // "0D0!0+3.14OqZ<CR><LF>"
        let data = b"0+3.14";
        let expected_crc_str = b"OqZ";
        let expected_crc_val = decode_crc_ascii(expected_crc_str); // Derive value from spec string

        // 1. Test calculation
        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example A: Calculation mismatch");

        // 2. Test encoding
        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example A: Encoding mismatch");

        // 3. Test verification helper
        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example A: Verification failed");
    }

    #[test]
    fn test_spec_example_b() {
        // "0D0!0+3.14+2.718+1.414Ipz<CR><LF>"
        let data = b"0+3.14+2.718+1.414";
        let expected_crc_str = b"Ipz";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example B: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example B: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example B: Verification failed");
    }

    #[test]
    fn test_spec_example_c_d0() {
        // "0D0!0+1.11+2.22+3.33+4.44+5.55+6.66I]q<CR><LF>"
        let data = b"0+1.11+2.22+3.33+4.44+5.55+6.66";
        let expected_crc_str = b"I]q";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example C D0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example C D0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example C D0: Verification failed");
    }

    #[test]
    fn test_spec_example_c_d1() {
        // "0D1!0+7.77+8.88+9.99IvW<CR><LF>"
        let data = b"0+7.77+8.88+9.99";
        let expected_crc_str = b"IvW";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example C D1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example C D1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example C D1: Verification failed");
    }

    #[test]
    fn test_spec_example_d() {
        // "0D0!0+3.14+2.718IWO<CR><LF>"
        let data = b"0+3.14+2.718";
        let expected_crc_str = b"IWO";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example D: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example D: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example D: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d0() {
        // "0D0!0+3.14OqZ<CR><LF>" - Same as Example A
        let data = b"0+3.14";
        let expected_crc_str = b"OqZ";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D0: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d1() {
        // "0D1!0+2.718Gbc<CR><LF>"
        let data = b"0+2.718";
        let expected_crc_str = b"Gbc";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D1: Verification failed");
    }

    #[test]
    fn test_spec_example_e_d2() {
        // "0D2!0+1.414GtW<CR><LF>"
        let data = b"0+1.414";
        let expected_crc_str = b"GtW";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example E D2: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example E D2: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example E D2: Verification failed");
    }

    #[test]
    fn test_spec_example_f_sensor1() {
        // "1D0!1+1.23+2.34+345+4.4678KoO<CR><LF>"
        let data = b"1+1.23+2.34+345+4.4678";
        let expected_crc_str = b"KoO";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example F S1: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example F S1: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example F S1: Verification failed");
    }

     #[test]
    fn test_spec_example_f_sensor0() {
        // "0D0!0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12Ba]<CR><LF>"
        let data = b"0+1.234-4.56+12354-0.00045+2.223+145.5+7.7003+4328.8+9+10+11.433+12";
        let expected_crc_str = b"Ba]";
        let expected_crc_val = decode_crc_ascii(expected_crc_str);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Example F S0: Calculation mismatch");

        let encoded_crc = encode_crc_ascii(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_str, "Example F S0: Encoding mismatch");

        let mut response = data.to_vec();
        response.extend_from_slice(expected_crc_str);
        assert!(verify_response_crc_ascii::<MockIoError>(&response).is_ok(), "Example F S0: Verification failed");
    }


    // --- Binary CRC Tests Based Directly on Spec v1.4 Section 5.2.2 ---

    #[test]
    fn test_spec_binary_example_db0() {
        // Data: 0x31 0x04 0x00 0x03 0xFF 0xFF 0x01 0x00
        // CRC: 0xC2 0xAC -> 0xACC2
        let data = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00];
        let expected_crc_bytes = &[0xC2, 0xAC]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        // 1. Test calculation
        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB0: Calculation mismatch");

        // 2. Test encoding
        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB0: Encoding mismatch");

        // 3. Test verification helper
        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB0: Verification failed");
    }

     #[test]
    fn test_spec_binary_example_db1() {
        // Data: 0x31 0x08 0x00 0x09 0xC3 0xF5 0x48 0x40 0x00 0x00 0x80 0x3F
        // CRC: 0x3B 0x6E -> 0x6E3B
        let data = &[0x31, 0x08, 0x00, 0x09, 0xC3, 0xF5, 0x48, 0x40, 0x00, 0x00, 0x80, 0x3F];
        let expected_crc_bytes = &[0x3B, 0x6E]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB1: Calculation mismatch");

        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB1: Encoding mismatch");

        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB1: Verification failed");
    }

    #[test]
    fn test_spec_binary_example_db2_empty() {
        // Data: 0x31 0x00 0x00 0x00 (Empty packet indicator)
        // CRC: 0x0E 0xFC -> 0xFC0E
        let data = &[0x31, 0x00, 0x00, 0x00];
        let expected_crc_bytes = &[0x0E, 0xFC]; // LSB, MSB
        let expected_crc_val = decode_crc_binary(expected_crc_bytes);

        let calculated_crc = calculate_crc16(data);
        assert_eq!(calculated_crc, expected_crc_val, "Binary Ex DB2: Calculation mismatch");

        let encoded_crc = encode_crc_binary(calculated_crc);
        assert_eq!(&encoded_crc, expected_crc_bytes, "Binary Ex DB2: Encoding mismatch");

        let mut packet = data.to_vec();
        packet.extend_from_slice(expected_crc_bytes);
        assert!(verify_packet_crc_binary::<MockIoError>(&packet).is_ok(), "Binary Ex DB2: Verification failed");
    }

    // --- Optional: Keep basic roundtrip/error tests if desired ---
    #[test]
    fn test_crc_ascii_encoding_decoding_roundtrip_extra() {
        let test_cases = [0x0000, 0xFFFF, 0x1234, 0xABCD]; // Non-spec examples
        for crc_val in test_cases {
            let encoded = encode_crc_ascii(crc_val);
            let decoded = decode_crc_ascii(&encoded);
            assert_eq!(decoded, crc_val, "ASCII Encode/Decode roundtrip failed for {:#06x}", crc_val);
        }
    }

    #[test]
    fn test_binary_crc_encoding_decoding_roundtrip_extra() {
         let test_cases = [0x0000, 0xFFFF, 0x1234, 0xABCD]; // Non-spec examples
        for crc_val in test_cases {
            let encoded = encode_crc_binary(crc_val);
            let decoded = decode_crc_binary(&encoded);
            assert_eq!(decoded, crc_val, "Binary Encode/Decode roundtrip failed for {:#06x}", crc_val);
        }
    }

    #[test]
    fn test_verify_ascii_crc_invalid_cases() {
        // Wrong CRC characters
        let result1 = verify_response_crc_ascii::<MockIoError>(b"0+3.14OqX"); // Correct is OqZ
        assert!(matches!(result1, Err(Sdi12Error::CrcMismatch { .. })));

        // Corrupted data, correct CRC characters
        let result2 = verify_response_crc_ascii::<MockIoError>(b"0+3.15OqZ"); // Changed 4 to 5
        assert!(matches!(result2, Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer too short for CRC
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b"0+"), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b"Oq"), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_response_crc_ascii::<MockIoError>(b""), Err(Sdi12Error::InvalidFormat)));
    }

     #[test]
    fn test_verify_binary_crc_invalid_cases() {
        // Correct data, wrong CRC bytes
        let data = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00];
        let mut packet_bad_crc = data.to_vec();
        packet_bad_crc.extend_from_slice(&[0xC3, 0xAC]); // Original CRC was C2 AC
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&packet_bad_crc), Err(Sdi12Error::CrcMismatch { .. })));

        // Corrupted data, original CRC bytes
        let data_bad = &[0x31, 0x04, 0x00, 0x03, 0xFE, 0xFF, 0x01, 0x00];
        let mut packet_bad_data = data_bad.to_vec();
        let correct_crc = calculate_crc16(data); // CRC for original data
        packet_bad_data.extend_from_slice(&encode_crc_binary(correct_crc));
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&packet_bad_data), Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer has data but only 1 byte for CRC
        let packet_short_crc = &[0x31, 0x04, 0x00, 0x03, 0xFF, 0xFF, 0x01, 0x00, 0xC2];
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(packet_short_crc), Err(Sdi12Error::CrcMismatch { .. })));

        // Buffer genuinely too short
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(&[0x31]), Err(Sdi12Error::InvalidFormat)));
        assert!(matches!(verify_packet_crc_binary::<MockIoError>(b""), Err(Sdi12Error::InvalidFormat)));
    }

    // Panic tests for decode functions remain useful
    #[test]
    #[should_panic]
    fn test_decode_ascii_panic_short() { decode_crc_ascii(b"Oq"); }
    #[test]
    #[should_panic]
    fn test_decode_ascii_panic_long() { decode_crc_ascii(b"OqZZ"); }
    #[test]
    #[should_panic]
    fn test_decode_binary_panic_short() { decode_crc_binary(&[0xC2]); }
    #[test]
    #[should_panic]
    fn test_decode_binary_panic_long() { decode_crc_binary(&[0xC2, 0xAC, 0x00]); }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/error.rs
=======================
// src/common/error.rs

#[cfg(feature = "alloc")]
use alloc::string::String;

// Import the specific command error types
use crate::common::command::{CommandFormatError, CommandIndexError}; // Added this line

// No more cfg_attr needed here, thiserror is always available
#[derive(Debug, PartialEq, Eq, thiserror::Error)]
pub enum Sdi12Error<E = ()>
where
    E: core::fmt::Debug, // Still need Debug for the generic Io error
{
    /// Underlying I/O error from the HAL implementation.
    #[error("I/O error: {0:?}")] // Format string requires Debug on E
    Io(E),

    /// Operation timed out.
    #[error("Operation timed out")]
    Timeout,

    /// Invalid character received where it's not allowed (e.g., non-printable ASCII).
    #[error("Invalid character received: {0:#04x}")]
    InvalidCharacter(u8),

    /// Provided address character is not a valid SDI-12 address.
    #[error("Invalid SDI-12 address character: '{0}'")]
    InvalidAddress(char),

    /// Received response format is invalid or unexpected.
    #[error("Invalid response format")]
    InvalidFormat,

    /// Buffer provided was too small.
    #[error("Buffer overflow: needed {needed}, got {got}")]
    BufferOverflow { needed: usize, got: usize },

    /// UART framing error detected by HAL.
    #[error("UART framing error")]
    Framing,

    /// UART parity error detected by HAL.
    #[error("UART parity error")]
    Parity,

    /// Received CRC does not match calculated CRC.
    #[error("CRC mismatch: expected {expected:#06x}, calculated {calculated:#06x}")]
    CrcMismatch { expected: u16, calculated: u16 },

    /// Got a validly formatted response, but not the one expected in the current state.
    #[error("Unexpected response received")]
    UnexpectedResponse, // Consider adding details later

    /// Bus contention detected (multiple devices responding simultaneously).
    #[error("Bus contention detected")]
    BusContention,

    /// Error related to command index validation.
    #[error("Invalid command index: {0}")] // Changed from CommandFormat
    InvalidCommandIndex(CommandIndexError), // Wrap CommandIndexError

    /// Error during command formatting.
    #[error("Command formatting failed: {0}")] // Changed from CommandFormat
    CommandFormatFailed(CommandFormatError), // Wrap CommandFormatError

    /// An error specific to the sensor's implementation/handler.
    /// Only available when the "alloc" feature is enabled.
    #[cfg(feature = "alloc")]
    #[error("Sensor specific error: {0}")] // String implements Display
    SensorSpecific(String),

    // Add other variants as needed...
}

// No manual Display impl needed - thiserror handles it.
// No manual std::error::Error impl needed - thiserror handles it when its 'std' feature is enabled.

// Allow mapping from underlying HAL error if From is implemented
impl<E: core::fmt::Debug> From<E> for Sdi12Error<E> {
    fn from(e: E) -> Self {
        Sdi12Error::Io(e)
    }
}

// Map command index errors into the main error type
impl<E: core::fmt::Debug> From<CommandIndexError> for Sdi12Error<E> {
    fn from(e: CommandIndexError) -> Self {
        Sdi12Error::InvalidCommandIndex(e)
    }
}

// Map command format errors into the main error type
impl<E: core::fmt::Debug> From<CommandFormatError> for Sdi12Error<E> {
    fn from(e: CommandFormatError) -> Self {
        Sdi12Error::CommandFormatFailed(e)
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/frame.rs
=======================
// src/common/frame.rs

/// Represents the serial frame formats used in SDI-12.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum FrameFormat {
    /// Standard SDI-12 format: 1200 baud, 7 data bits, Even parity, 1 stop bit.
    Sdi12_7e1,
    /// Format for High-Volume Binary data: 1200 baud, 8 data bits, No parity, 1 stop bit.
    Binary8N1,
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/hal_traits.rs
=======================
// src/common/hal_traits.rs

use super::frame::FrameFormat;
use core::fmt::Debug;

// We need these traits potentially for the NativeSdi12Uart bounds
#[cfg(feature = "impl-native")]
use embedded_hal; // Use version 1.0
#[cfg(all(feature = "async", feature = "impl-native"))]
use embedded_hal_async; // Use version 1.0

/// Abstraction for timer/delay operations required by SDI-12.
///
/// Note: This could potentially be replaced by directly requiring
/// `embedded_hal::delay::DelayNs` if embedded-hal v1 is mandated.
pub trait Sdi12Timer {
    /// Delay for at least the specified number of microseconds.
    fn delay_us(&mut self, us: u32);

    /// Delay for at least the specified number of milliseconds.
    fn delay_ms(&mut self, ms: u32);
}

/// Abstraction for synchronous (non-blocking) SDI-12 serial communication.
pub trait Sdi12Serial {
    /// Associated error type for communication errors.
    /// Must implement Debug for error reporting.
    type Error: Debug;

    /// Attempts to read a single byte from the serial interface.
    ///
    /// Returns `Ok(byte)` if a byte was read, or `Err(nb::Error::WouldBlock)`
    /// if no byte is available yet. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn read_byte(&mut self) -> nb::Result<u8, Self::Error>;

    /// Attempts to write a single byte to the serial interface.
    ///
    /// Returns `Ok(())` if the byte was accepted for transmission, or `Err(nb::Error::WouldBlock)`
    /// if the write buffer is full. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn write_byte(&mut self, byte: u8) -> nb::Result<(), Self::Error>;

    /// Attempts to flush the transmit buffer, ensuring all written bytes have been sent.
    ///
    /// Returns `Ok(())` if the flush completed, or `Err(nb::Error::WouldBlock)` if
    /// transmission is still in progress. Other errors are returned as `Err(nb::Error::Other(Self::Error))`.
    fn flush(&mut self) -> nb::Result<(), Self::Error>;

    /// Sends the SDI-12 break condition (>= 12ms of spacing).
    ///
    /// Implementations must ensure the line is held low for the required duration.
    /// This might block or return `WouldBlock` depending on the implementation strategy.
    fn send_break(&mut self) -> nb::Result<(), Self::Error>;

    /// Changes the serial configuration (e.g., between 7E1 and 8N1).
    ///
    /// This operation might be blocking or complex, hence `Result` instead of `nb::Result`.
    /// Errors could occur if the hardware doesn't support the format or reconfiguration fails.
    fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

/// Abstraction for asynchronous SDI-12 serial communication (requires 'async' feature).
#[cfg(feature = "async")]
pub trait Sdi12SerialAsync {
    /// Associated error type for communication errors.
    /// Must implement Debug for error reporting.
    type Error: Debug;

    /// Asynchronously reads a single byte from the serial interface.
    async fn read_byte(&mut self) -> Result<u8, Self::Error>;

    /// Asynchronously writes a single byte to the serial interface.
    async fn write_byte(&mut self, byte: u8) -> Result<(), Self::Error>;

    /// Asynchronously flushes the transmit buffer.
    async fn flush(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously sends the SDI-12 break condition.
    async fn send_break(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously changes the serial configuration.
    async fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}


/// Bundles standard embedded-hal serial traits with native SDI-12 specific operations.
///
/// Implement this trait for a HAL's UART peripheral if it provides native support
/// for sending break signals and changing configuration efficiently. Then, use the
/// `NativeAdapter` to make it compatible with `sdi12-rs`.
///
/// Requires `embedded-hal` v1.0 traits and is enabled by the `impl-native` feature.
#[cfg(feature = "impl-native")]
pub trait NativeSdi12Uart:
    embedded_hal::serial::ErrorType // Use fully qualified path
    // Specify Error association for dependent traits using qualified syntax
    + embedded_hal::serial::Read<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    + embedded_hal::serial::Write<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    + embedded_hal::serial::Flush<u8, Error = <Self as embedded_hal::serial::ErrorType>::Error>
    // Add Debug bound on the associated Error type for our own trait requirements
    + where <Self as embedded_hal::serial::ErrorType>::Error: Debug
{
    // Note: The associated Error type comes from embedded_hal::serial::ErrorType

    /// Sends the SDI-12 break condition using native hardware capabilities.
    fn native_send_break(&mut self) -> Result<(), Self::Error>;

    /// Changes the serial configuration using native hardware capabilities.
    fn native_set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

/// Async version of `NativeSdi12Uart`.
/// Requires `embedded-hal-async` traits and is enabled by the `async` and `impl-native` features.
#[cfg(all(feature = "async", feature = "impl-native"))]
pub trait NativeSdi12UartAsync:
    embedded_hal_async::serial::ErrorType // Use fully qualified path
    // Specify Error association for dependent traits using qualified syntax
    + embedded_hal_async::serial::Read<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    + embedded_hal_async::serial::Write<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    + embedded_hal_async::serial::Flush<u8, Error = <Self as embedded_hal_async::serial::ErrorType>::Error>
    // Add Debug bound on the associated Error type for our own trait requirements
    + where <Self as embedded_hal_async::serial::ErrorType>::Error: Debug
{
    // Note: The associated Error type comes from embedded_hal_async::serial::ErrorType

    /// Asynchronously sends the SDI-12 break condition using native hardware capabilities.
    async fn native_send_break(&mut self) -> Result<(), Self::Error>;

    /// Asynchronously changes the serial configuration using native hardware capabilities.
    async fn native_set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error>;
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/mod.rs
=======================
// src/common/mod.rs

// --- Declare all public modules within common ---
pub mod address;
pub mod command;
pub mod crc;
pub mod error;
pub mod frame;
pub mod hal_traits;
pub mod response; // Points to the single file
pub mod timing;
pub mod types;

// --- Re-export key types/traits/functions for easier access ---

// From address.rs
pub use address::Sdi12Addr;

// From command.rs
pub use command::{
    Command, CommandIndexError, CommandFormatError, // Added FormatError
    MeasurementIndex, ContinuousIndex, DataIndex, IdentifyParameterIndex,
    IdentifyMeasurementCommand, IdentifyMeasurementParameterCommand,
};

// From crc.rs
pub use crc::{
    calculate_crc16, encode_crc_ascii, decode_crc_ascii, verify_response_crc_ascii,
    encode_crc_binary, decode_crc_binary, verify_packet_crc_binary,
};

// From error.rs
pub use error::Sdi12Error;

// From frame.rs
pub use frame::FrameFormat;

// From hal_traits.rs
pub use hal_traits::{Sdi12Serial, Sdi12Timer}; // Core sync traits

// From response.rs (Simplified re-exports)
pub use response::{
    ResponseParseError, // The error enum for frame/crc/address issues
    MeasurementTiming,  // The struct for specifically parsed timing responses
    PayloadSlice,       // The wrapper for returned raw payloads
};

// From timing.rs (constants)

// From types.rs
pub use types::{BinaryDataType, Sdi12ParsingError, Sdi12Value};


// --- Feature-gated re-exports ---

// Async traits (from hal_traits.rs)
#[cfg(feature = "async")]
pub use hal_traits::Sdi12SerialAsync;

// Native HAL integration traits (from hal_traits.rs)
#[cfg(feature = "impl-native")]
pub use hal_traits::NativeSdi12Uart;
#[cfg(all(feature = "async", feature = "impl-native"))]
pub use hal_traits::NativeSdi12UartAsync;

// Note: No alloc-dependent response types re-exported from common::response
// Types like IdentificationInfo, DataInfo etc. are now internal details
// potentially used by optional parsing helpers.

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/response.rs
=======================
// src/common/response.rs

use crate::common::address::Sdi12Addr;
use crate::common::types::Sdi12ParsingError; // Keep for error composition
use core::fmt;

/// Error type specific to parsing the framing/address/CRC of an SDI-12 response.
/// Does not cover errors from parsing the actual payload content (data values, ID fields etc.).
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ResponseParseError {
    /// Input buffer was empty.
    EmptyInput,
    /// Input buffer doesn't end with <CR><LF> (for ASCII responses).
    MissingCrLf,
    /// Response string is too short for basic structure (e.g., address or CRC).
    TooShort,
    /// Invalid or unexpected address character at the start (e.g., '?').
    InvalidAddressChar,
    /// CRC validation failed.
    CrcMismatch,
    /// Binary packet size/structure inconsistent (if library handles binary framing).
    InconsistentBinaryPacketSize,
    /// Feature needed for a specific check/parse is not enabled.
    FeatureNotEnabled,
    /// Generic framing or structural format error.
    InvalidFormat,
    // NOTE: Errors like ValueError, NumericError, InvalidIdentificationLength etc.
    // are removed as they relate to parsing the *payload*, which is now the user's responsibility
    // or handled by optional helpers. ResponseParseError focuses on the layer the library handles.
}

impl fmt::Display for ResponseParseError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         // Simple display for now
         write!(f, "{:?}", self)
     }
}

// If std feature is enabled, implement the Error trait
#[cfg(feature = "std")]
impl std::error::Error for ResponseParseError {}


/// Timing and count information returned directly by Measurement/Concurrent/Identify commands.
/// (Example: `aTTTN<CR><LF>`)
/// This is one structure the library *might* still parse directly, as it's not payload data.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct MeasurementTiming {
    /// The address of the responding sensor.
    pub address: Sdi12Addr,
    /// Time estimate in seconds until data is ready (ttt). 0-999.
    pub time_seconds: u16,
    /// Number of measurement values that will be returned (n, nn, or nnn). 0-999.
    pub values_count: u16,
}


// --- Placeholder for the Payload Slice Wrapper ---
// This struct would be returned by recorder methods after validating
// address, CRC, CRLF and stripping them.

/// Represents the validated payload of an SDI-12 response, borrowed from a read buffer.
/// Excludes the leading address, trailing CRC (if any), and trailing <CR><LF>.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct PayloadSlice<'a>(pub &'a [u8]);

impl<'a> PayloadSlice<'a> {
    /// Returns the payload as a byte slice.
    pub fn as_bytes(&self) -> &'a [u8] {
        self.0
    }

    /// Attempts to interpret the payload as a UTF-8 string slice.
    pub fn as_str(&self) -> Result<&'a str, core::str::Utf8Error> {
        core::str::from_utf8(self.0)
    }

    // Optional: Add helper methods here later under features?
    // #[cfg(feature = "alloc")]
    // pub fn parse_data_values(&self) -> Result<Vec<Sdi12Value>, ResponseParseError> { ... }
}

impl<'a> AsRef<[u8]> for PayloadSlice<'a> {
    fn as_ref(&self) -> &[u8] {
        self.0
    }
}

// No parsing functions like parse_response defined here anymore.
// That logic moves into internal recorder helpers or optional user-facing helpers.

// --- Tests ---
#[cfg(test)]
mod tests {
    use super::*;

     fn addr(c: char) -> Sdi12Addr { Sdi12Addr::new(c).unwrap() }

    #[test]
    fn test_measurement_timing_struct() {
        let mt = MeasurementTiming {
            address: addr('1'),
            time_seconds: 15,
            values_count: 4,
        };
        assert_eq!(mt.time_seconds, 15);
    }

     #[test]
    fn test_payload_slice_wrapper() {
        let data: &[u8] = b"+1.23-45";
        let payload = PayloadSlice(data);
        assert_eq!(payload.as_bytes(), b"+1.23-45");
        assert_eq!(payload.as_ref(), b"+1.23-45");
        assert_eq!(payload.as_str().unwrap(), "+1.23-45");

        let non_utf8: &[u8] = &[0x80, 0x81]; // Invalid UTF-8
        let payload_bad = PayloadSlice(non_utf8);
        assert!(payload_bad.as_str().is_err());
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/timing.rs
=======================
// src/common/timing.rs

use core::time::Duration;

// Note: Tolerances are generally +/- 0.40 ms according to the spec (Sec 7.0),
// except for inter-character time. We define the nominal values here.
// Implementations using these should factor in tolerances where appropriate,
// especially when checking received timings.

// === Break Timing (Sec 7.0, 7.1) ===

/// Minimum duration for a valid break signal (recorder must send >= 12 ms).
pub const BREAK_DURATION_MIN: Duration = Duration::from_millis(12);
/// Sensor must recognize a break if spacing > 12 ms.
pub const BREAK_RECOGNITION_MAX: Duration = Duration::from_millis(12);
/// Sensor will *not* recognize a break if spacing < 6.5 ms.
pub const BREAK_IGNORE_MAX: Duration = Duration::from_micros(6500);
/// Marking time required after a break before sensor looks for an address.
pub const POST_BREAK_MARKING_MIN: Duration = Duration::from_micros(8330);

// === Command/Response Timing (Sec 7.0) ===

/// Maximum time from end of command stop bit for recorder to release line.
pub const RECORDER_RELEASE_TIME_MAX: Duration = Duration::from_micros(7_900); // 7.5ms + 0.4ms tol
/// Nominal marking time sent by sensor before starting response.
pub const SENSOR_PRE_RESPONSE_MARKING: Duration = Duration::from_micros(8330);
/// Maximum time from end of command stop bit to start bit of first response byte.
pub const RESPONSE_START_TIME_MAX: Duration = Duration::from_micros(15_400); // 15ms + 0.4ms tol
/// Maximum time from end of response stop bit for sensor to release line.
pub const SENSOR_RELEASE_TIME_MAX: Duration = Duration::from_micros(7_900); // 7.5ms + 0.4ms tol
/// Maximum marking time allowed between characters in a command or response.
pub const INTER_CHARACTER_MARKING_MAX: Duration = Duration::from_micros(1660);


// === Sensor Wake/Sleep Timing (Sec 7.0) ===

/// Maximum time for sensor to wake up after detecting a break and be ready for command start bit.
pub const SENSOR_WAKEUP_TIME_MAX: Duration = Duration::from_millis(100);
/// Marking time after which sensor returns to low-power standby (if not actively processing/responding).
pub const SENSOR_SLEEP_MARKING_TIME: Duration = Duration::from_millis(100);
/// Time threshold after which a break *must* precede the next command if line was marking.
/// (Spec says > 87 ms in Sec 7.1 implies break needed, aligned with retry logic in Sec 7.2).
pub const PRE_COMMAND_BREAK_MARKING_THRESHOLD: Duration = Duration::from_millis(87);

// === Retry Timing (Sec 7.2) ===

/// Minimum wait time after a command before recorder issues a retry (if no response).
pub const RETRY_WAIT_MIN: Duration = Duration::from_micros(16670); // 16.67 ms
/// Maximum wait time after a command before recorder issues a retry without a preceding break.
/// (This period also covers the RETRY_WAIT_MIN).
pub const RETRY_WAIT_MAX_NO_BREAK: Duration = Duration::from_millis(87);
/// Minimum delay after the *end of the break* before issuing at least one retry,
/// to ensure sensor has had SENSOR_WAKEUP_TIME_MAX to wake up.
pub const RETRY_POST_BREAK_DELAY_MIN: Duration = SENSOR_WAKEUP_TIME_MAX;

// === Other ===

/// Time between lines for multi-line text responses (Sec 4.4.13.1). Max 150ms.
pub const MULTILINE_INTER_LINE_DELAY_MAX: Duration = Duration::from_millis(150);

// === Byte Timing at 1200 Baud (7E1) ===
// 1 start bit + 7 data bits + 1 parity bit + 1 stop bit = 10 bits per byte
// Time per bit = 1 / 1200 seconds = 0.8333... ms
// Time per byte = 10 * (1 / 1200) seconds = 10 / 1200 s = 1 / 120 s = 8.333... ms

/// Nominal duration of a single bit at 1200 baud.
pub const BIT_DURATION: Duration = Duration::from_nanos(833_333); // Approx 0.833 ms
/// Nominal duration of a single byte (10 bits total) at 1200 baud (7E1 format).
pub const BYTE_DURATION: Duration = Duration::from_micros(8333); // Approx 8.33 ms

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/common/types.rs
=======================
// src/common/types.rs

use core::fmt;
use core::str::FromStr; // For parsing strings to numbers

// --- SDI-12 Standard Data Value (`<values>`) ---

/// Represents a single data value as returned in the `<values>` part of D or R commands.
/// Format: `p[d.d]` where p is '+' or '-', d are digits, '.' is optional. Max 7 digits. Max 9 chars total.
///
/// We store it internally potentially as a scaled integer or a float, depending on needs.
/// Using f32 might be simplest for representation, but parsing needs care.
/// Alternatively, parse into integer + scale factor. Let's try f32 for now.
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]
pub struct Sdi12Value(f32); // Store as f32 for simplicity

impl Sdi12Value {
    /// Creates a new Sdi12Value.
    pub fn new(value: f32) -> Self {
        // TODO: Potentially add checks/clamping based on SDI-12 format limits?
        // The format itself limits precision/range implicitly.
        Self(value)
    }

    /// Returns the value as f32.
    pub fn as_f32(&self) -> f32 {
        self.0
    }

    /// Parses a single value string (like "+1.23", "-10", "+1234567") into an Sdi12Value.
    /// Does not handle multiple values in one string.
    pub fn parse_single(s: &str) -> Result<Self, Sdi12ParsingError> {
        // Validate basic structure and length (max 9 chars: sign + 7 digits + opt decimal)
        if s.is_empty() || s.len() > 9 {
            return Err(Sdi12ParsingError::InvalidFormat);
        }
        let mut chars = s.chars();
        let sign_char = chars.next().ok_or(Sdi12ParsingError::InvalidFormat)?;
        let sign = match sign_char {
            '+' => 1.0,
            '-' => -1.0,
            _ => return Err(Sdi12ParsingError::InvalidSign),
        };

        let rest = chars.as_str();
        // Validate remaining chars are digits or a single '.'
        let mut decimal_found = false;
        let mut digit_count = 0;
        for c in rest.chars() {
            match c {
                '0'..='9' => digit_count += 1,
                '.' => {
                    if decimal_found { return Err(Sdi12ParsingError::MultipleDecimals); }
                    decimal_found = true;
                }
                _ => return Err(Sdi12ParsingError::InvalidCharacter),
            }
        }
        if digit_count == 0 || digit_count > 7 {
            return Err(Sdi12ParsingError::InvalidDigitCount);
        }

        // Attempt to parse the numeric part (without sign)
        let num_part = f32::from_str(rest).map_err(|_| Sdi12ParsingError::ParseFloatError)?;

        Ok(Self(sign * num_part))
    }

    // TODO: Implement formatting logic later if needed (e.g., for sensor implementation)
    // pub fn format(&self, buffer: &mut [u8]) -> Result<usize, Sdi12FormattingError> { ... }
}

/// Error during parsing of SDI-12 <values>.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Sdi12ParsingError {
    InvalidFormat,
    InvalidSign,
    MultipleDecimals,
    InvalidCharacter,
    InvalidDigitCount,
    ParseFloatError, // Error converting string part to float
}

impl fmt::Display for Sdi12ParsingError {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use Sdi12ParsingError::*;
        match self {
            InvalidFormat => write!(f, "Invalid SDI-12 value format"),
            InvalidSign => write!(f, "Invalid or missing sign character"),
            MultipleDecimals => write!(f, "Multiple decimal points found"),
            InvalidCharacter => write!(f, "Invalid character in numeric part"),
            InvalidDigitCount => write!(f, "Invalid number of digits (must be 1-7)"),
            ParseFloatError => write!(f, "Failed to parse numeric part as float"),
        }
    }
}


// --- High Volume Binary Data Types (Sec 5.2.1, Table 16) ---

/// Data types used in High-Volume Binary command responses.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[repr(u8)]
pub enum BinaryDataType {
    InvalidRequest = 0, // Indicates an invalid DBn request index
    SignedI8 = 1,
    UnsignedU8 = 2,
    SignedI16 = 3,
    UnsignedU16 = 4,
    SignedI32 = 5,
    UnsignedU32 = 6,
    SignedI64 = 7,
    UnsignedU64 = 8,
    Float32 = 9, // IEEE 754 Single Precision
    Float64 = 10, // IEEE 754 Double Precision
}

impl BinaryDataType {
    /// Tries to convert a u8 into a BinaryDataType.
    pub fn from_u8(value: u8) -> Option<Self> {
        match value {
            0 => Some(BinaryDataType::InvalidRequest),
            1 => Some(BinaryDataType::SignedI8),
            2 => Some(BinaryDataType::UnsignedU8),
            3 => Some(BinaryDataType::SignedI16),
            4 => Some(BinaryDataType::UnsignedU16),
            5 => Some(BinaryDataType::SignedI32),
            6 => Some(BinaryDataType::UnsignedU32),
            7 => Some(BinaryDataType::SignedI64),
            8 => Some(BinaryDataType::UnsignedU64),
            9 => Some(BinaryDataType::Float32),
            10 => Some(BinaryDataType::Float64),
            _ => None,
        }
    }

    /// Returns the size in bytes of a single value of this data type.
    /// Returns 0 for InvalidRequest.
    pub fn size_in_bytes(&self) -> usize {
        match self {
            BinaryDataType::InvalidRequest => 0,
            BinaryDataType::SignedI8 => 1,
            BinaryDataType::UnsignedU8 => 1,
            BinaryDataType::SignedI16 => 2,
            BinaryDataType::UnsignedU16 => 2,
            BinaryDataType::SignedI32 => 4,
            BinaryDataType::UnsignedU32 => 4,
            BinaryDataType::SignedI64 => 8,
            BinaryDataType::UnsignedU64 => 8,
            BinaryDataType::Float32 => 4,
            BinaryDataType::Float64 => 8,
        }
    }
}


// --- Unit Tests ---
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sdi12value_parsing_valid() {
        assert_eq!(Sdi12Value::parse_single("+1.23").unwrap(), Sdi12Value(1.23));
        assert_eq!(Sdi12Value::parse_single("-0.456").unwrap(), Sdi12Value(-0.456));
        assert_eq!(Sdi12Value::parse_single("+100").unwrap(), Sdi12Value(100.0));
        assert_eq!(Sdi12Value::parse_single("-5").unwrap(), Sdi12Value(-5.0));
        assert_eq!(Sdi12Value::parse_single("+1234567").unwrap(), Sdi12Value(1234567.0));
        assert_eq!(Sdi12Value::parse_single("-9999999").unwrap(), Sdi12Value(-9999999.0));
        assert_eq!(Sdi12Value::parse_single("+.1").unwrap(), Sdi12Value(0.1));
        assert_eq!(Sdi12Value::parse_single("-0.").unwrap(), Sdi12Value(-0.0)); // Note: -0.0 comparison
        assert_eq!(Sdi12Value::parse_single("+0").unwrap(), Sdi12Value(0.0));
    }

    #[test]
    fn test_sdi12value_parsing_invalid() {
        assert_eq!(Sdi12Value::parse_single(""), Err(Sdi12ParsingError::InvalidFormat));
        assert_eq!(Sdi12Value::parse_single("+"), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("-"), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("1.23"), Err(Sdi12ParsingError::InvalidSign));
        assert_eq!(Sdi12Value::parse_single(" +1.23"), Err(Sdi12ParsingError::InvalidSign));
        assert_eq!(Sdi12Value::parse_single("+1.2.3"), Err(Sdi12ParsingError::MultipleDecimals));
        assert_eq!(Sdi12Value::parse_single("+1a2"), Err(Sdi12ParsingError::InvalidCharacter));
        assert_eq!(Sdi12Value::parse_single("+."), Err(Sdi12ParsingError::InvalidDigitCount));
        assert_eq!(Sdi12Value::parse_single("+12345678"), Err(Sdi12ParsingError::InvalidDigitCount)); // 8 digits, len 9 -> OK length, bad digit count

        // Input "+123.45678" (Length 10) - Should fail length check first.
        assert_eq!(
            Sdi12Value::parse_single("+123.45678"), // This was line 186
            Err(Sdi12ParsingError::InvalidFormat) // CORRECTED: Expect InvalidFormat due to length > 9
        );

        // Input "+1234567." (Length 9) - Should parse OK if trailing '.' is allowed
        assert!(Sdi12Value::parse_single("+1234567.").is_ok());

        // Input "+1234567.0" (Length 10) - Should fail length check first.
        assert_eq!(
            Sdi12Value::parse_single("+1234567.0"),
            Err(Sdi12ParsingError::InvalidFormat) // Expect InvalidFormat due to length > 9
        );
        // Input "+12345.678" (Length 10) - This also fails length check first.
         assert_eq!(
            Sdi12Value::parse_single("+12345.678"), // This was previously expecting InvalidDigitCount incorrectly
            Err(Sdi12ParsingError::InvalidFormat) // CORRECTED: Expect InvalidFormat due to length > 9
        );
        assert_eq!(Sdi12Value::parse_single("+123456789"), Err(Sdi12ParsingError::InvalidFormat)); // Too long (len 10)
    }

    #[test]
    fn test_binary_data_type_from_u8() {
        assert_eq!(BinaryDataType::from_u8(0), Some(BinaryDataType::InvalidRequest));
        assert_eq!(BinaryDataType::from_u8(1), Some(BinaryDataType::SignedI8));
        assert_eq!(BinaryDataType::from_u8(2), Some(BinaryDataType::UnsignedU8));
        assert_eq!(BinaryDataType::from_u8(3), Some(BinaryDataType::SignedI16));
        assert_eq!(BinaryDataType::from_u8(4), Some(BinaryDataType::UnsignedU16));
        assert_eq!(BinaryDataType::from_u8(5), Some(BinaryDataType::SignedI32));
        assert_eq!(BinaryDataType::from_u8(6), Some(BinaryDataType::UnsignedU32));
        assert_eq!(BinaryDataType::from_u8(7), Some(BinaryDataType::SignedI64));
        assert_eq!(BinaryDataType::from_u8(8), Some(BinaryDataType::UnsignedU64));
        assert_eq!(BinaryDataType::from_u8(9), Some(BinaryDataType::Float32));
        assert_eq!(BinaryDataType::from_u8(10), Some(BinaryDataType::Float64));
        assert_eq!(BinaryDataType::from_u8(11), None);
        assert_eq!(BinaryDataType::from_u8(255), None);
    }

     #[test]
    fn test_binary_data_type_size() {
        assert_eq!(BinaryDataType::InvalidRequest.size_in_bytes(), 0);
        assert_eq!(BinaryDataType::SignedI8.size_in_bytes(), 1);
        assert_eq!(BinaryDataType::UnsignedU8.size_in_bytes(), 1);
        assert_eq!(BinaryDataType::SignedI16.size_in_bytes(), 2);
        assert_eq!(BinaryDataType::UnsignedU16.size_in_bytes(), 2);
        assert_eq!(BinaryDataType::SignedI32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::UnsignedU32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::SignedI64.size_in_bytes(), 8);
        assert_eq!(BinaryDataType::UnsignedU64.size_in_bytes(), 8);
        assert_eq!(BinaryDataType::Float32.size_in_bytes(), 4);
        assert_eq!(BinaryDataType::Float64.size_in_bytes(), 8);
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/lib.rs
=======================
// src/lib.rs

#![no_std] // Specify no_std at the crate root

#[cfg(feature = "alloc")]
extern crate alloc;

pub mod common;
pub mod recorder;
pub mod sensor;

// Re-export key types for convenience
pub use common::Sdi12Addr;
pub use common::Sdi12Error;

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/recorder/mod.rs
=======================
// src/recorder/mod.rs

use crate::common::{
    address::Sdi12Addr,
    command::Command,
    error::Sdi12Error,
    hal_traits::{Sdi12Serial, Sdi12Timer},
    response::{PayloadSlice, ResponseParseError}, // Keep ResponseParseError
    timing, // Need timing constants
    FrameFormat, // Need frame format enum
};
use core::fmt::Debug; // Needed for IF::Error bound
use core::time::Duration; // May be needed for timeouts later

// Use nb::Result for non-blocking operations from Sdi12Serial
use nb::Result as NbResult;


/// Represents an SDI-12 Recorder (Datalogger) instance for SYNCHRONOUS operations.
///
/// This struct owns the SDI-12 interface (serial and timer abstraction)
/// and provides methods to interact with sensors on the bus using a blocking approach.
#[derive(Debug)]
pub struct SyncRecorder<IF> {
    interface: IF,
    // TODO: Add internal state if needed (e.g., last communication time, requires_break flag)
}

// --- Constructor ---

impl<IF> SyncRecorder<IF>
where
    // The interface needs to provide both Serial and Timer capabilities
    IF: Sdi12Serial + Sdi12Timer,
    // Require Debug on the serial error for mapping in execute_blocking_io
    IF::Error: Debug,
{
    /// Creates a new SyncRecorder instance using the provided SDI-12 interface.
    ///
    /// The interface must implement both `Sdi12Serial` for communication
    /// and `Sdi12Timer` for handling delays and timeouts. Adapter structs
    /// provided by `sdi12-rs` (like `NativeAdapter`, `GenericHalAdapter`)
    /// typically implement both.
    ///
    /// # Arguments
    ///
    /// * `interface`: An object implementing `Sdi12Serial` and `Sdi12Timer`.
    pub fn new(interface: IF) -> Self {
        SyncRecorder {
            interface,
            // TODO: Initialize internal state
        }
    }

    // --- Public Blocking Methods ---

    /// Sends the Acknowledge Active command (`a!`) and waits for a valid acknowledgement.
    ///
    /// Returns `Ok(())` if the sensor acknowledges correctly (empty payload received).
    /// Returns `Err(Sdi12Error::...)` on timeout, CRC error (if applicable later),
    /// incorrect response payload, or communication errors.
    pub fn acknowledge(&mut self, address: Sdi12Addr) -> Result<(), Sdi12Error<IF::Error>> {
        let cmd = Command::AcknowledgeActive { address };
        // TODO: Determine appropriate buffer size or pass slice from caller
        let mut read_buffer = [0u8; 8]; // Small buffer for simple ack/error
        let payload = self.execute_transaction(&cmd, &mut read_buffer)?;

        // For acknowledge, the payload should be empty after stripping address/CRC/CRLF
        if payload.as_bytes().is_empty() {
            Ok(())
        } else {
            // Received unexpected data after address
            Err(Sdi12Error::InvalidFormat) // Or maybe UnexpectedResponse?
        }
    }

    // --- Core Transaction Logic (Private Helper) ---

    /// Executes a full command-response transaction with retries.
    /// Handles break signal (if needed), command formatting/sending, response reading/validation.
    fn execute_transaction<'buf>(
        &mut self,
        command: &Command,
        read_buffer: &'buf mut [u8] // Buffer provided by caller
    ) -> Result<PayloadSlice<'buf>, Sdi12Error<IF::Error>>
    {
        // TODO: Implement full sequence:
        // 1. Check timing state - Do we need a break? Call check_and_send_break()
        // 2. Format command into a temporary buffer (needs allocation or stack buffer)
        //    let command_bytes = format_command(command)?; // Need this helper
        // 3. Retry loop (e.g., up to 3 times per spec)
        //    a. send_command_bytes(&command_bytes)?
        //    b. read_response_line(read_buffer)?
        //    c. process_response_payload(line)? -> Returns PayloadSlice on success
        //    d. If successful, break loop and return PayloadSlice
        //    e. If timeout/error, handle retry wait logic (Sec 7.2) - might need break on some retries.
        // 4. If retries exhausted, return last error (e.g., Timeout)
        // 5. Update timing state after successful communication

        // Placeholder implementation
        let _ = command;
        let _ = read_buffer;
        Err(Sdi12Error::Timeout)
    }


    // --- Low-Level I/O Helpers (Private) ---

    // TODO: Implement check_and_send_break (needs timing state)
    // fn check_and_send_break(&mut self) -> Result<(), Sdi12Error<IF::Error>> { ... }

    // TODO: Implement send_command_bytes (needs formatting helper)
    // fn send_command_bytes(&mut self, cmd_bytes_with_term: &[u8]) -> Result<(), Sdi12Error<IF::Error>> { ... }

    // TODO: Implement read_response_line (needs timeout logic)
    // fn read_response_line<'buf>(&mut self, buffer: &'buf mut [u8]) -> Result<&'buf [u8], Sdi12Error<IF::Error>> { ... }

    // TODO: Implement process_response_payload (needs CRC check, address check)
    // fn process_response_payload<'buf>(&mut self, response_line: &'buf [u8]) -> Result<PayloadSlice<'buf>, Sdi12Error<IF::Error>> { ... }

    /// Executes a non-blocking I/O operation (`f`) repeatedly until it
    /// stops returning `WouldBlock`, returning the final result.
    /// Effectively a blocking wrapper around an nb::Result returning function.
    /// NOTE: Current implementation lacks timeout!
    fn execute_blocking_io<F, T>(&mut self, mut f: F) -> Result<T, Sdi12Error<IF::Error>>
    where
        F: FnMut(&mut IF) -> NbResult<T, IF::Error>,
    {
        loop {
            match f(&mut self.interface) {
                Ok(result) => return Ok(result),
                Err(nb::Error::WouldBlock) => {
                    // WARNING: Lacks timeout logic!
                    // In a real scenario, check elapsed time against a deadline here.
                    // If deadline exceeded, return Err(Sdi12Error::Timeout).
                    // A simple busy loop or short delay might be used temporarily,
                    // but isn't ideal for responsiveness or power consumption.
                    // self.interface.delay_us(100); // Example short delay - use with caution!
                    continue; // Retry the operation
                }
                Err(nb::Error::Other(e)) => return Err(Sdi12Error::Io(e)), // Map HAL error
            }
        }
        // Note: Could use nb::block! macro if IF::Error implements Copy.
        // nb::block!(f(&mut self.interface)).map_err(Sdi12Error::Io)
    }

} // end impl SyncRecorder


// --- Async Recorder Definition (Placeholder) ---
#[cfg(feature = "async")]
pub struct AsyncRecorder<IF> {
    interface: IF,
    // ... state ...
}

#[cfg(feature = "async")]
impl<IF> AsyncRecorder<IF>
where
    IF: crate::common::hal_traits::Sdi12SerialAsync + Sdi12Timer, // Assume timer can be sync or need async version
    IF::Error: Debug,
{
     pub fn new(interface: IF) -> Self {
         // ... constructor ...
         unimplemented!()
     }

     pub async fn acknowledge(&mut self, _address: Sdi12Addr) -> Result<(), Sdi12Error<IF::Error>> {
         // ... async implementation using .await ...
         unimplemented!()
     }

     // ... other async methods and helpers ...
}


// --- Tests ---
#[cfg(test)]
mod tests {
    use super::*;
    use crate::common::{
        address::Sdi12Addr,
        hal_traits::{Sdi12Serial, Sdi12Timer},
        FrameFormat, Sdi12Error, Command, // Added Command for acknowledge test
    };
    use nb;

    // --- Mock Interface ---
    #[derive(Debug, Copy, Clone, PartialEq, Eq)]
    struct MockCommError;

    struct MockInterface {
        break_sent: bool,
        config: FrameFormat,
        // Add fields to control mock behavior for specific tests
        // e.g. bytes_to_read: Vec<u8>, write_calls: Vec<u8>, read_calls: usize etc.
    }
    impl MockInterface { fn new() -> Self { MockInterface { break_sent: false, config: FrameFormat::Sdi12_7e1 } } }
    impl Sdi12Timer for MockInterface { fn delay_us(&mut self, _us: u32) {} fn delay_ms(&mut self, _ms: u32) {} }
    impl Sdi12Serial for MockInterface {
        type Error = MockCommError;
        fn read_byte(&mut self) -> NbResult<u8, Self::Error> { Err(nb::Error::WouldBlock) } // Default: no data
        fn write_byte(&mut self, _byte: u8) -> NbResult<(), Self::Error> { Ok(()) } // Default: success
        fn flush(&mut self) -> NbResult<(), Self::Error> { Ok(()) }
        fn send_break(&mut self) -> NbResult<(), Self::Error> { self.break_sent = true; Ok(()) }
        fn set_config(&mut self, config: FrameFormat) -> Result<(), Self::Error> { self.config = config; Ok(()) }
    }


    #[test]
    fn test_recorder_construction() {
        let mock_interface = MockInterface::new();
        let _recorder = SyncRecorder::new(mock_interface);
    }

     #[test]
    fn test_acknowledge_placeholder() {
         let mock_interface = MockInterface::new();
         let mut recorder = SyncRecorder::new(mock_interface);
         let addr = Sdi12Addr::new('0').unwrap();
         // Still expecting placeholder error from execute_transaction
         assert!(matches!(recorder.acknowledge(addr), Err(Sdi12Error::Timeout)));
     }

     // src/recorder/mod.rs
// ... inside #[cfg(test)] mod tests ...

    #[test]
    fn test_execute_blocking_io_helper() {
        let mut mock_interface = MockInterface::new();
        let mut recorder = SyncRecorder::new(mock_interface);

        let mut call_count = 0;
        // Test the Ok path, T is i32
        let result: Result<i32, Sdi12Error<MockCommError>> = recorder.execute_blocking_io(|_iface| {
             call_count += 1;
             if call_count < 3 { Err(nb::Error::WouldBlock) } else { Ok(123) }
        });
        assert_eq!(call_count, 3);
        assert_eq!(result, Ok(123));

        call_count = 0;
         // Test the Err path. Specify the Ok type T as () for the Result.
         let result_err: Result<(), Sdi12Error<MockCommError>> = recorder.execute_blocking_io(|_iface| {
             call_count += 1;
              if call_count < 2 {
                  Err(nb::Error::WouldBlock)
              } else {
                  // Ensure the closure returns nb::Result<(), MockCommError> in the error case
                  Err(nb::Error::Other(MockCommError))
              }
              // No Ok(()) path needed here as it's unreachable for the error test logic,
              // but the type annotation on result_err tells the compiler T = ().
         });
         assert_eq!(call_count, 2);
         assert_eq!(result_err, Err(Sdi12Error::Io(MockCommError)));
         assert!(matches!(result_err, Err(Sdi12Error::Io(MockCommError))));

        // TODO: Test timeout case once timer logic added to helper
    }
}

=======================
FILE: /Users/rileyleff/Documents/dev/try/trysdi12/sdi12/src/sensor/mod.rs
=======================


